package controller

import (
	"fmt"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"

	"github.com/threeport/threeport/internal/sdk/gen"
	"github.com/threeport/threeport/internal/sdk/util"
	cli "github.com/threeport/threeport/pkg/cli/v0"
)

// GenReconcilerOperations generates the reconciler create, update and delete
// operation function scaffolding.
func GenReconcilerOperations(gen *gen.Generator) error {
	for _, objGroup := range gen.ApiObjectGroups {
		for _, obj := range objGroup.ReconciledObjects {
			for _, version := range obj.Versions {
				f := NewFile(objGroup.ControllerPackageName)
				f.HeaderComment("generated by 'threeport-sdk gen' but will not be regenerated - intended for modification")

				for _, version := range obj.Versions {
					f.ImportAlias(
						fmt.Sprintf("github.com/threeport/threeport/pkg/controller/%s", version),
						"controller",
					)
				}

				createdFuncName := fmt.Sprintf("%s%sCreated", version, obj.Name)
				updatedFuncName := fmt.Sprintf("%s%sUpdated", version, obj.Name)
				deletedFuncName := fmt.Sprintf("%s%sDeleted", version, obj.Name)

				reconcilerParam := Line().Id("r").Op("*").Qual(
					"github.com/threeport/threeport/pkg/controller/v0",
					"Reconciler",
				)
				objectParam := Line().Id(strcase.ToLowerCamel(obj.Name)).Op("*").Qual(
					fmt.Sprintf("%s/pkg/api/%s", gen.ModulePath, version),
					obj.Name,
				)
				logParam := Line().Id("log").Op("*").Qual("github.com/go-logr/logr", "Logger")
				returnTypes := List(Int64(), Error())

				f.Comment(fmt.Sprintf(
					"%s performs reconciliation when a %s %s",
					createdFuncName,
					version,
					obj.Name,
				))
				f.Comment("has been created.")
				f.Func().Id(createdFuncName).Params(
					reconcilerParam,
					objectParam,
					logParam,
					Line(),
				).Params(returnTypes).Block(
					Return(Lit(0), Nil()),
				)

				f.Comment(fmt.Sprintf(
					"%s performs reconciliation when a %s %s",
					updatedFuncName,
					version,
					obj.Name,
				))
				f.Comment("has been updated.")
				f.Func().Id(updatedFuncName).Params(
					reconcilerParam,
					objectParam,
					logParam,
					Line(),
				).Params(returnTypes).Block(
					Return(Lit(0), Nil()),
				)

				f.Comment(fmt.Sprintf(
					"%s performs reconciliation when a %s %s",
					deletedFuncName,
					version,
					obj.Name,
				))
				f.Comment("has been deleted.")
				f.Func().Id(deletedFuncName).Params(
					reconcilerParam,
					objectParam,
					logParam,
					Line(),
				).Params(returnTypes).Block(
					Return(Lit(0), Nil()),
				)

				// write code to file
				genFilepath := filepath.Join(
					"internal",
					objGroup.ControllerShortName,
					fmt.Sprintf("%s_%s.go", version, strcase.ToSnake(obj.Name)),
				)
				fileWritten, err := util.WriteCodeToFile(f, genFilepath, false)
				if err != nil {
					return fmt.Errorf("failed to write generated code to file %s: %w", genFilepath, err)
				}
				if fileWritten {
					cli.Info(fmt.Sprintf("source code for reconciler operation functions written to %s", genFilepath))
				} else {
					cli.Info(fmt.Sprintf("source code for reconciler operation functions already exists at %s - not overwritten", genFilepath))
				}
			}
		}
	}

	return nil
}
