package versions

import (
	"fmt"
	"os"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
)

// AllRoutes generates the code for the function that adds the REST API routes.
func (gvc *GlobalVersionConfig) AllRoutes() error {

	// put all the model names in a slice
	// since all versions will be in one route function, only add once if a
	// model has multiple versions
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("generated by 'threeport-sdk codegen api-version' - do not edit")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")
		var routeFuncs []string
		for _, mn := range v.RouteNames {
			if !contains(routeFuncs, mn) {
				routeFuncs = append(routeFuncs, fmt.Sprintf("%sRoutes", mn))
			}
		}
		routeFuncCalls := &Statement{}
		for _, rf := range routeFuncs {
			routeFuncCalls.Id(rf).Call(Id("e").Op(",").Id("h"))
			routeFuncCalls.Line()
		}

		f.Func().Id("AddRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("github.com/threeport/threeport/pkg/api-server/%s/handlers", v.VersionName),
				"Handler",
			)).Block(
			routeFuncCalls,
		)

		// write code to file
		routesFilepath := filepath.Join("..", "..", "pkg", "api-server", v.VersionName, "routes", "routes_gen.go")
		file, err := os.OpenFile(routesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for all routes: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for all routes: %w", err)
		}
		fmt.Println("code generation complete for all routes")
	}

	return nil
}

// ExtensionAllRoutes generates the code for the function that adds the REST API routes for an extension.
func (gvc *GlobalVersionConfig) ExtensionAllRoutes(modulePath string) error {

	// put all the model names in a slice
	// since all versions will be in one route function, only add once if a
	// model has multiple versions
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("generated by 'threeport-sdk codegen api-version' - do not edit")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")
		var routeFuncs []string
		for _, mn := range v.RouteNames {
			if !contains(routeFuncs, mn) {
				routeFuncs = append(routeFuncs, fmt.Sprintf("%sRoutes", mn))
			}
		}
		routeFuncCalls := &Statement{}
		for _, rf := range routeFuncs {
			routeFuncCalls.Id(rf).Call(Id("e").Op(",").Id("h"))
			routeFuncCalls.Line()
		}

		f.Func().Id("AddRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("%s/pkg/api-server/%s/handlers", modulePath, v.VersionName),
				"Handler",
			)).Block(
			routeFuncCalls,
		)

		// write code to file
		routesFilepath := filepath.Join("..", "..", "pkg", "api-server", v.VersionName, "routes", "routes_gen.go")
		file, err := os.OpenFile(routesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for all routes: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for all routes: %w", err)
		}
		fmt.Println("code generation complete for all routes")
	}

	return nil
}
