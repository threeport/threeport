package versions

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
)

// AllRoutes generates the code for the function that adds the REST API routes.
func (gvc *GlobalVersionConfig) AllRoutes() error {

	// generated routes for all objects
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("generated by 'threeport-sdk gen' for versioned API routes boilerplate - do not edit")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")
		var routeFuncs []string
		for _, mn := range v.RouteNames {
			if !contains(routeFuncs, mn) {
				routeFuncs = append(routeFuncs, fmt.Sprintf("%sRoutes", mn))
			}
		}
		routeFuncCalls := &Statement{}
		for _, rf := range routeFuncs {
			routeFuncCalls.Id(rf).Call(Id("e").Op(",").Id("h"))
			routeFuncCalls.Line()
		}

		f.Comment("AddRoutes adds routes for all objects of a particular API version.")
		f.Func().Id("AddRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("github.com/threeport/threeport/pkg/api-server/%s/handlers", v.VersionName),
				"Handler",
			),
		).Block(
			routeFuncCalls,
		)

		// write code to file
		routesFilepath := filepath.Join("pkg", "api-server", v.VersionName, "routes", "routes_gen.go")
		file, err := os.OpenFile(routesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for all routes: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for all routes: %w", err)
		}
		fmt.Println("code generation complete for all routes")
	}

	// custom route scaffolding
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("originall generated by 'threeport-sdk gen' for custom API routes - intended for modification")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")

		f.Comment("AddCustomRoutes adds non code-generated routes for special use cases.")
		f.Func().Id("AddCustomRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("github.com/threeport/threeport/pkg/api-server/%s/handlers", v.VersionName),
				"Handler",
			),
		).Block()

		// write custom route code to file if it doesn't already exist
		customRoutesFilepath := filepath.Join("pkg", "api-server", v.VersionName, "routes", "routes.go")
		if _, err := os.Stat(customRoutesFilepath); errors.Is(err, os.ErrNotExist) {
			customRoutesFile, err := os.OpenFile(customRoutesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
			if err != nil {
				return fmt.Errorf("failed to open file to write generated code for custom routes: %w", err)
			}
			defer customRoutesFile.Close()
			if err := f.Render(customRoutesFile); err != nil {
				return fmt.Errorf("failed to render generated source code for custom routes: %w", err)
			}
			fmt.Println("code generation complete for custom routes")
		} else {
			fmt.Println("custom routes code already exists - not regenerated")
		}
	}

	return nil
}

// ExtensionAllRoutes generates the code for the function that adds the REST API routes for an extension.
func (gvc *GlobalVersionConfig) ExtensionAllRoutes(modulePath string) error {

	// generated routes for all objects
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("generated by 'threeport-sdk gen' for versioned API routes boilerplate - do not edit")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")
		var routeFuncs []string
		for _, mn := range v.RouteNames {
			if !contains(routeFuncs, mn) {
				routeFuncs = append(routeFuncs, fmt.Sprintf("%sRoutes", mn))
			}
		}
		routeFuncCalls := &Statement{}
		for _, rf := range routeFuncs {
			routeFuncCalls.Id(rf).Call(Id("e").Op(",").Id("h"))
			routeFuncCalls.Line()
		}

		f.Comment("AddRoutes adds routes for all objects of a particular API version.")
		f.Func().Id("AddRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("%s/pkg/api-server/%s/handlers", modulePath, v.VersionName),
				"Handler",
			)).Block(
			routeFuncCalls,
		)

		// create directories if they don't exist
		routesPath := filepath.Join("pkg", "api-server", v.VersionName, "routes")
		if _, err := os.Stat(routesPath); errors.Is(err, os.ErrNotExist) {
			if err := os.MkdirAll(routesPath, 0755); err != nil {
				return fmt.Errorf("could not create directores for API routes path: %s, %w", routesPath, err)
			}
		}

		// write code to file
		routesFilepath := filepath.Join(routesPath, "routes_gen.go")
		file, err := os.OpenFile(routesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for all routes: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for all routes: %w", err)
		}
		fmt.Println("code generation complete for all routes")
	}

	// custom route scaffolding
	for _, v := range gvc.Versions {
		f := NewFile("routes")
		f.HeaderComment("originall generated by 'threeport-sdk gen' for custom API routes - intended for modification")
		f.ImportAlias("github.com/labstack/echo/v4", "echo")

		f.Comment("AddCustomRoutes adds non code-generated routes for special use cases.")
		f.Func().Id("AddCustomRoutes").Params(
			Id("e").Op("*").Qual(
				"github.com/labstack/echo/v4",
				"Echo",
			).Op(",").Id("h").Op("*").Qual(
				fmt.Sprintf("%s/pkg/api-server/%s/handlers", modulePath, v.VersionName),
				"Handler",
			),
		).Block(
			Comment("SomeCustomRoutes(e, h)"),
		)

		// write custom route code to file if it doesn't already exist
		customRoutesFilepath := filepath.Join("pkg", "api-server", v.VersionName, "routes", "routes.go")
		if _, err := os.Stat(customRoutesFilepath); errors.Is(err, os.ErrNotExist) {
			customRoutesFile, err := os.OpenFile(customRoutesFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
			if err != nil {
				return fmt.Errorf("failed to open file to write generated code for custom routes: %w", err)
			}
			defer customRoutesFile.Close()
			if err := f.Render(customRoutesFile); err != nil {
				return fmt.Errorf("failed to render generated source code for custom routes: %w", err)
			}
			fmt.Println("code generation complete for custom routes")
		} else {
			fmt.Println("custom routes code already exists - not regenerated")
		}
	}

	return nil
}
