package versions

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
)

// ApiHandler generates the API handler boilerplate.
func (gvc *GlobalVersionConfig) ApiHandler() error {
	for _, version := range gvc.Versions {
		f := NewFile("handlers")
		f.HeaderComment("generated by 'threeport-sdk create' for API handler boilerplate' - do not edit")

		f.ImportAlias("github.com/nats-io/nats.go", "nats")

		f.Comment("Handler contains the elements necessary for an API handler to operate")
		f.Type().Id("Handler").Struct(
			Id("DB").Op("*").Qual(
				"gorm.io/gorm",
				"DB",
			),
			Id("NC").Op("*").Qual(
				"github.com/nats-io/nats.go",
				"Conn",
			),
			Id("JS").Qual(
				"github.com/nats-io/nats.go",
				"JetStreamContext",
			),
		)

		f.Comment("New returns a new Handler.")
		f.Func().Id("New").Params(
			Id("db").Op("*").Qual("gorm.io/gorm", "DB"),
			Id("nc").Op("*").Qual("github.com/nats-io/nats.go", "Conn"),
			Id("rc").Qual("github.com/nats-io/nats.go", "JetStreamContext"),
		).Id("Handler").Block(
			Id("handler").Op(":=").Qual(
				"github.com/threeport/threeport/pkg/api-server/v0/handlers",
				"New",
			).Call(List(Id("db"), Id("nc"), Id("rc"))),

			Return(Id("Handler").Values(List(
				Id("db"), Id("nc"), Id("rc"),
			))),
		)

		// create directories if they don't exist
		apiHandlerPath := filepath.Join("pkg", "api-server", version.VersionName, "handlers")
		if _, err := os.Stat(apiHandlerPath); errors.Is(err, os.ErrNotExist) {
			if err := os.MkdirAll(apiHandlerPath, 0755); err != nil {
				return fmt.Errorf("could not create directores for API handler: %s, %w", apiHandlerPath, err)
			}
		}

		// write code to file
		genFilename := "handlers_gen.go"
		genFilepath := filepath.Join(apiHandlerPath, genFilename)
		file, err := os.OpenFile(genFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for API handler: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for API handler: %w", err)
		}
		fmt.Println("code generation complete for API handler")
	}

	return nil
}

// ApiHandler generates the API handler boilerplate for extensions.
func (gvc *GlobalVersionConfig) ExtensionApiHandler() error {
	for _, version := range gvc.Versions {
		f := NewFile("handlers")
		f.HeaderComment("generated by 'threeport-sdk create' for API handler boilerplate' - do not edit")

		f.ImportAlias("github.com/nats-io/nats.go", "nats")

		f.Comment("Handler is a wrapper for the threeport Handler object.")
		f.Type().Id("Handler").Struct(
			Id("Handler").Qual(
				"github.com/threeport/threeport/pkg/api-server/v0/handlers",
				"Handler",
			),
		)

		f.Comment("New returns a new Handler.")
		f.Func().Id("New").Params(
			Id("db").Op("*").Qual("gorm.io/gorm", "DB"),
			Id("nc").Op("*").Qual("github.com/nats-io/nats.go", "Conn"),
			Id("rc").Qual("github.com/nats-io/nats.go", "JetStreamContext"),
		).Id("Handler").Block(
			Id("handler").Op(":=").Qual(
				"github.com/threeport/threeport/pkg/api-server/v0/handlers",
				"New",
			).Call(List(Id("db"), Id("nc"), Id("rc"))),

			Return(Id("Handler").Values(Dict{
				Id("Handler"): Id("handler"),
			})),
		)

		// create directories if they don't exist
		apiHandlerPath := filepath.Join("pkg", "api-server", version.VersionName, "handlers")
		if _, err := os.Stat(apiHandlerPath); errors.Is(err, os.ErrNotExist) {
			if err := os.MkdirAll(apiHandlerPath, 0755); err != nil {
				return fmt.Errorf("could not create directores for API handler: %s, %w", apiHandlerPath, err)
			}
		}

		// write code to file
		genFilename := "handlers_gen.go"
		genFilepath := filepath.Join(apiHandlerPath, genFilename)
		file, err := os.OpenFile(genFilepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to open file to write generated code for API handler: %w", err)
		}
		defer file.Close()
		if err := f.Render(file); err != nil {
			return fmt.Errorf("failed to render generated source code for API handler: %w", err)
		}
		fmt.Println("code generation complete for API handler")
	}

	return nil
}
