package create

import (
	"fmt"
	"path/filepath"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/gertd/go-pluralize"

	"github.com/threeport/threeport/internal/sdk"
	"github.com/threeport/threeport/internal/sdk/util"
	cli "github.com/threeport/threeport/pkg/cli/v0"
)

// CreateApiObjects creates the boilerplate and scaffolding for new API objects.
func CreateApiObjects(sdkConfig *sdk.SdkConfig, extension bool) error {
	// for each of the provided api objects in a new controller domain, create the necessary scaffolding
	for _, objectGroup := range sdkConfig.ApiObjectGroups {
		for _, object := range objectGroup.Objects {
			for _, version := range object.Versions {
				if err := createNewApiFile(
					*version,
					*objectGroup.Name,
					objectGroup.Objects,
					extension,
				); err != nil {
					return fmt.Errorf("could not create API object file: %w", err)
				}
			}
		}
	}

	return nil
}

// createNewApiFile creates the source code scaffolding for a new API object.
func createNewApiFile(
	version string,
	objGroupName string,
	apiObjects []*sdk.ApiObject,
	extension bool,
) error {
	pluralize := pluralize.NewClient()

	f := NewFile(version)
	f.HeaderComment("originally generated by 'threeport-sdk create' for API object")
	f.HeaderComment("scaffolding but will not be re-generated - intended for modification")
	if extension {
		f.ImportAlias("github.com/threeport/threeport/pkg/api/v0", "tpapi_v0")
	}
	f.Line()

	// create the necessary structs for each object in the domain api file
	for _, obj := range apiObjects {
		structFields := make([]Code, 0)
		if extension {
			structFields = append(
				structFields,
				Qual(
					"github.com/threeport/threeport/pkg/api/v0",
					"Common",
				).Tag(map[string]string{"swaggerignore": "true", "mapstructure": ",squash"}),
			)
		} else {
			structFields = append(
				structFields,
				Id("Common").Tag(map[string]string{"swaggerignore": "true", "mapstructure": ",squash"}),
			)
		}

		// infer if object needs to be reconciled and add appropiate field
		if obj.Reconcilable != nil && *obj.Reconcilable {
			if extension {
				structFields = append(
					structFields,
					Qual(
						"github.com/threeport/threeport/pkg/api/v0",
						"Reconciliation",
					).Tag(map[string]string{"mapstructure": ",squash"}),
				)
			} else {
				structFields = append(
					structFields,
					Id("Reconciliation").Tag(map[string]string{"mapstructure": ",squash"}),
				)
			}
		}

		// infer if the object is an instance or a definition and add
		// appropiate DefinedInstance fields for it provided the API object's
		// DefinedInstance field is not false in the SDK config
		definedInstance, definitionName, instanceName := sdk.IsOfDefinedInstance(
			*obj.Name,
			apiObjects,
		)
		switch {
		case definedInstance && strings.HasSuffix(*obj.Name, "Instance"):
			// add Instance field
			if extension {
				structFields = append(
					structFields,
					Qual(
						"github.com/threeport/threeport/pkg/api/v0",
						"Instance",
					).Tag(map[string]string{"mapstructure": ",squash"}),
				)
			} else {
				structFields = append(
					structFields,
					Id("Instance").Tag(map[string]string{"mapstructure": ",squash"}),
				)
			}
			// add field for foreign key to definition
			structFields = append(
				structFields,
				Id(
					fmt.Sprintf("%sID", definitionName),
				).Op("*").Uint().Tag(map[string]string{
					"json": fmt.Sprintf(
						"%sID,omitempty",
						definitionName,
					),
					"query": fmt.Sprintf(
						"%sid", strings.ToLower(definitionName),
					),
					"gorm":     "not null",
					"validate": "required",
				}),
			)
		case definedInstance && strings.HasSuffix(*obj.Name, "Definition"):
			// add Definition field
			if extension {
				structFields = append(
					structFields,
					Qual(
						"github.com/threeport/threeport/pkg/api/v0",
						"Definition",
					).Tag(map[string]string{"mapstructure": ",squash"}),
				)
			} else {
				structFields = append(
					structFields,
					Id("Definition").Tag(map[string]string{"mapstructure": ",squash"}),
				)
			}
			// add field for associated instances
			structFields = append(
				structFields,
				Id(
					pluralize.Pluralize(instanceName, 2, false),
				).Index().Op("*").Id(
					instanceName,
				).Tag(map[string]string{
					"json": fmt.Sprintf(
						"%s,omitempty",
						pluralize.Pluralize(instanceName, 2, false),
					),
					"validate": "optional,association",
				}),
			)
		}

		// define the struct for the object
		f.Type().Id(*obj.Name).Struct(structFields...)
		f.Line()
	}

	// write code to file
	genFilepath := filepath.Join(
		"pkg",
		"api",
		version,
		fmt.Sprintf("%s.go", objGroupName),
	)
	fileWritten, err := util.WriteCodeToFile(f, genFilepath, false)
	if err != nil {
		return fmt.Errorf("failed to write generated code to file %s: %w", genFilepath, err)
	}
	if fileWritten {
		cli.Info(fmt.Sprintf("source code for API object written to %s", genFilepath))
	} else {
		cli.Info(fmt.Sprintf("source code for API object already exists at %s - not overwritten", genFilepath))
	}

	return nil
}
