// generated by 'threeport-codegen api-model' - do not edit

package handlers

import (
	"errors"
	echo "github.com/labstack/echo/v4"
	iapi "github.com/threeport/threeport/internal/api"
	api "github.com/threeport/threeport/pkg/api"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
)

///////////////////////////////////////////////////////////////////////////////
// AwsAccount
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsAccountVersions gets the supported versions for the aws account API.
// @Description Get the supported API versions for aws accounts.
// @ID awsAccount-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /aws-accounts/versions [get]
func (h Handler) GetAwsAccountVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeAwsAccount)])
}

// @Summary adds a new aws account.
// @Description Add a new aws account to the Threeport database.
// @ID add-awsAccount
// @Accept json
// @Produce json
// @Param awsAccount body v0.AwsAccount true "AwsAccount object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts [post]
func (h Handler) AddAwsAccount(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	var awsAccount v0.AwsAccount

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsAccount); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, awsAccount, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsAccount v0.AwsAccount
	nameUsed := true
	result := h.DB.Where("name = ?", awsAccount.Name).First(&existingAwsAccount)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsAccount); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsAccount.NotificationPayload(
		notifications.NotificationOperationCreated,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsAccountCreateSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsAccount)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all aws accounts.
// @Description Get all aws accounts from the Threeport database.
// @ID get-awsAccounts
// @Accept json
// @Produce json
// @Param name query string false "aws account search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts [get]
func (h Handler) GetAwsAccounts(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.AwsAccount
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.AwsAccount{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.AwsAccount{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a aws account.
// @Description Get a particular aws account from the database.
// @ID get-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [get]
func (h Handler) GetAwsAccount(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var awsAccount v0.AwsAccount
	if result := h.DB.First(&awsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, awsAccount)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws account.
// @Description Update a aws account in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsAccount body v0.AwsAccount true "AwsAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [patch]
func (h Handler) UpdateAwsAccount(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var existingAwsAccount v0.AwsAccount
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsAccount v0.AwsAccount
	if err := c.Bind(&updatedAwsAccount); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	if result := h.DB.Model(&existingAwsAccount).Updates(updatedAwsAccount); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsAccount)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws account by replacing the entire object.
// @Description Replace a aws account in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsAccount body v0.AwsAccount true "AwsAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [put]
func (h Handler) ReplaceAwsAccount(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var existingAwsAccount v0.AwsAccount
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsAccount v0.AwsAccount
	if err := c.Bind(&updatedAwsAccount); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedAwsAccount, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsAccount.ID = existingAwsAccount.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsAccount); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsAccount)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a aws account.
// @Description Delete a aws account by ID from the database.
// @ID delete-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [delete]
func (h Handler) DeleteAwsAccount(c echo.Context) error {
	objectType := v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var awsAccount v0.AwsAccount
	if result := h.DB.First(&awsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	if result := h.DB.Delete(&awsAccount); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsAccount.NotificationPayload(
		notifications.NotificationOperationDeleted,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsAccountDeleteSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsAccount)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsEksClusterDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsEksClusterDefinitionVersions gets the supported versions for the aws eks cluster definition API.
// @Description Get the supported API versions for aws eks cluster definitions.
// @ID awsEksClusterDefinition-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /aws-eks-cluster-definitions/versions [get]
func (h Handler) GetAwsEksClusterDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeAwsEksClusterDefinition)])
}

// @Summary adds a new aws eks cluster definition.
// @Description Add a new aws eks cluster definition to the Threeport database.
// @ID add-awsEksClusterDefinition
// @Accept json
// @Produce json
// @Param awsEksClusterDefinition body v0.AwsEksClusterDefinition true "AwsEksClusterDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions [post]
func (h Handler) AddAwsEksClusterDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	var awsEksClusterDefinition v0.AwsEksClusterDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsEksClusterDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, awsEksClusterDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsEksClusterDefinition v0.AwsEksClusterDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", awsEksClusterDefinition.Name).First(&existingAwsEksClusterDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsEksClusterDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsEksClusterDefinition.NotificationPayload(
		notifications.NotificationOperationCreated,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsEksClusterDefinitionCreateSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsEksClusterDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all aws eks cluster definitions.
// @Description Get all aws eks cluster definitions from the Threeport database.
// @ID get-awsEksClusterDefinitions
// @Accept json
// @Produce json
// @Param name query string false "aws eks cluster definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions [get]
func (h Handler) GetAwsEksClusterDefinitions(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.AwsEksClusterDefinition
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.AwsEksClusterDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.AwsEksClusterDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a aws eks cluster definition.
// @Description Get a particular aws eks cluster definition from the database.
// @ID get-awsEksClusterDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions/{id} [get]
func (h Handler) GetAwsEksClusterDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	awsEksClusterDefinitionID := c.Param("id")
	var awsEksClusterDefinition v0.AwsEksClusterDefinition
	if result := h.DB.First(&awsEksClusterDefinition, awsEksClusterDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, awsEksClusterDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws eks cluster definition.
// @Description Update a aws eks cluster definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws eks cluster definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-awsEksClusterDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksClusterDefinition body v0.AwsEksClusterDefinition true "AwsEksClusterDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions/{id} [patch]
func (h Handler) UpdateAwsEksClusterDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	awsEksClusterDefinitionID := c.Param("id")
	var existingAwsEksClusterDefinition v0.AwsEksClusterDefinition
	if result := h.DB.First(&existingAwsEksClusterDefinition, awsEksClusterDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksClusterDefinition v0.AwsEksClusterDefinition
	if err := c.Bind(&updatedAwsEksClusterDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	if result := h.DB.Model(&existingAwsEksClusterDefinition).Updates(updatedAwsEksClusterDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsEksClusterDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws eks cluster definition by replacing the entire object.
// @Description Replace a aws eks cluster definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws eks cluster definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-awsEksClusterDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksClusterDefinition body v0.AwsEksClusterDefinition true "AwsEksClusterDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions/{id} [put]
func (h Handler) ReplaceAwsEksClusterDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	awsEksClusterDefinitionID := c.Param("id")
	var existingAwsEksClusterDefinition v0.AwsEksClusterDefinition
	if result := h.DB.First(&existingAwsEksClusterDefinition, awsEksClusterDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksClusterDefinition v0.AwsEksClusterDefinition
	if err := c.Bind(&updatedAwsEksClusterDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedAwsEksClusterDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsEksClusterDefinition.ID = existingAwsEksClusterDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsEksClusterDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsEksClusterDefinition, awsEksClusterDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsEksClusterDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a aws eks cluster definition.
// @Description Delete a aws eks cluster definition by ID from the database.
// @ID delete-awsEksClusterDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-definitions/{id} [delete]
func (h Handler) DeleteAwsEksClusterDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterDefinition
	awsEksClusterDefinitionID := c.Param("id")
	var awsEksClusterDefinition v0.AwsEksClusterDefinition
	if result := h.DB.First(&awsEksClusterDefinition, awsEksClusterDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	if result := h.DB.Delete(&awsEksClusterDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsEksClusterDefinition.NotificationPayload(
		notifications.NotificationOperationDeleted,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsEksClusterDefinitionDeleteSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsEksClusterDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsEksClusterInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsEksClusterInstanceVersions gets the supported versions for the aws eks cluster instance API.
// @Description Get the supported API versions for aws eks cluster instances.
// @ID awsEksClusterInstance-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /aws-eks-cluster-instances/versions [get]
func (h Handler) GetAwsEksClusterInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeAwsEksClusterInstance)])
}

// @Summary adds a new aws eks cluster instance.
// @Description Add a new aws eks cluster instance to the Threeport database.
// @ID add-awsEksClusterInstance
// @Accept json
// @Produce json
// @Param awsEksClusterInstance body v0.AwsEksClusterInstance true "AwsEksClusterInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances [post]
func (h Handler) AddAwsEksClusterInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	var awsEksClusterInstance v0.AwsEksClusterInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsEksClusterInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, awsEksClusterInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsEksClusterInstance v0.AwsEksClusterInstance
	nameUsed := true
	result := h.DB.Where("name = ?", awsEksClusterInstance.Name).First(&existingAwsEksClusterInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsEksClusterInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsEksClusterInstance.NotificationPayload(
		notifications.NotificationOperationCreated,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsEksClusterInstanceCreateSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsEksClusterInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all aws eks cluster instances.
// @Description Get all aws eks cluster instances from the Threeport database.
// @ID get-awsEksClusterInstances
// @Accept json
// @Produce json
// @Param name query string false "aws eks cluster instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances [get]
func (h Handler) GetAwsEksClusterInstances(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.AwsEksClusterInstance
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.AwsEksClusterInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.AwsEksClusterInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a aws eks cluster instance.
// @Description Get a particular aws eks cluster instance from the database.
// @ID get-awsEksClusterInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances/{id} [get]
func (h Handler) GetAwsEksClusterInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	awsEksClusterInstanceID := c.Param("id")
	var awsEksClusterInstance v0.AwsEksClusterInstance
	if result := h.DB.First(&awsEksClusterInstance, awsEksClusterInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, awsEksClusterInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws eks cluster instance.
// @Description Update a aws eks cluster instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws eks cluster instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-awsEksClusterInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksClusterInstance body v0.AwsEksClusterInstance true "AwsEksClusterInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances/{id} [patch]
func (h Handler) UpdateAwsEksClusterInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	awsEksClusterInstanceID := c.Param("id")
	var existingAwsEksClusterInstance v0.AwsEksClusterInstance
	if result := h.DB.First(&existingAwsEksClusterInstance, awsEksClusterInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksClusterInstance v0.AwsEksClusterInstance
	if err := c.Bind(&updatedAwsEksClusterInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	if result := h.DB.Model(&existingAwsEksClusterInstance).Updates(updatedAwsEksClusterInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsEksClusterInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws eks cluster instance by replacing the entire object.
// @Description Replace a aws eks cluster instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws eks cluster instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-awsEksClusterInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksClusterInstance body v0.AwsEksClusterInstance true "AwsEksClusterInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances/{id} [put]
func (h Handler) ReplaceAwsEksClusterInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	awsEksClusterInstanceID := c.Param("id")
	var existingAwsEksClusterInstance v0.AwsEksClusterInstance
	if result := h.DB.First(&existingAwsEksClusterInstance, awsEksClusterInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksClusterInstance v0.AwsEksClusterInstance
	if err := c.Bind(&updatedAwsEksClusterInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedAwsEksClusterInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsEksClusterInstance.ID = existingAwsEksClusterInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsEksClusterInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsEksClusterInstance, awsEksClusterInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsEksClusterInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a aws eks cluster instance.
// @Description Delete a aws eks cluster instance by ID from the database.
// @ID delete-awsEksClusterInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-cluster-instances/{id} [delete]
func (h Handler) DeleteAwsEksClusterInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsEksClusterInstance
	awsEksClusterInstanceID := c.Param("id")
	var awsEksClusterInstance v0.AwsEksClusterInstance
	if result := h.DB.First(&awsEksClusterInstance, awsEksClusterInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	if result := h.DB.Delete(&awsEksClusterInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsEksClusterInstance.NotificationPayload(
		notifications.NotificationOperationDeleted,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsEksClusterInstanceDeleteSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsEksClusterInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsRelationalDatabaseDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsRelationalDatabaseDefinitionVersions gets the supported versions for the aws relational database definition API.
// @Description Get the supported API versions for aws relational database definitions.
// @ID awsRelationalDatabaseDefinition-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /aws-relational-database-definitions/versions [get]
func (h Handler) GetAwsRelationalDatabaseDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeAwsRelationalDatabaseDefinition)])
}

// @Summary adds a new aws relational database definition.
// @Description Add a new aws relational database definition to the Threeport database.
// @ID add-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param awsRelationalDatabaseDefinition body v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions [post]
func (h Handler) AddAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	var awsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsRelationalDatabaseDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, awsRelationalDatabaseDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", awsRelationalDatabaseDefinition.Name).First(&existingAwsRelationalDatabaseDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsRelationalDatabaseDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsRelationalDatabaseDefinition.NotificationPayload(
		notifications.NotificationOperationCreated,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsRelationalDatabaseDefinitionCreateSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all aws relational database definitions.
// @Description Get all aws relational database definitions from the Threeport database.
// @ID get-awsRelationalDatabaseDefinitions
// @Accept json
// @Produce json
// @Param name query string false "aws relational database definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions [get]
func (h Handler) GetAwsRelationalDatabaseDefinitions(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.AwsRelationalDatabaseDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.AwsRelationalDatabaseDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a aws relational database definition.
// @Description Get a particular aws relational database definition from the database.
// @ID get-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [get]
func (h Handler) GetAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var awsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&awsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws relational database definition.
// @Description Update a aws relational database definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws relational database definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseDefinition body v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [patch]
func (h Handler) UpdateAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var existingAwsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&updatedAwsRelationalDatabaseDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	if result := h.DB.Model(&existingAwsRelationalDatabaseDefinition).Updates(updatedAwsRelationalDatabaseDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsRelationalDatabaseDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws relational database definition by replacing the entire object.
// @Description Replace a aws relational database definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws relational database definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseDefinition body v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [put]
func (h Handler) ReplaceAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var existingAwsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&updatedAwsRelationalDatabaseDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedAwsRelationalDatabaseDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsRelationalDatabaseDefinition.ID = existingAwsRelationalDatabaseDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsRelationalDatabaseDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsRelationalDatabaseDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a aws relational database definition.
// @Description Delete a aws relational database definition by ID from the database.
// @ID delete-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [delete]
func (h Handler) DeleteAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var awsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&awsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	if result := h.DB.Delete(&awsRelationalDatabaseDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsRelationalDatabaseDefinition.NotificationPayload(
		notifications.NotificationOperationDeleted,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsRelationalDatabaseDefinitionDeleteSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseDefinition)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsRelationalDatabaseInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsRelationalDatabaseInstanceVersions gets the supported versions for the aws relational database instance API.
// @Description Get the supported API versions for aws relational database instances.
// @ID awsRelationalDatabaseInstance-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /aws-relational-database-instances/versions [get]
func (h Handler) GetAwsRelationalDatabaseInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeAwsRelationalDatabaseInstance)])
}

// @Summary adds a new aws relational database instance.
// @Description Add a new aws relational database instance to the Threeport database.
// @ID add-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param awsRelationalDatabaseInstance body v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances [post]
func (h Handler) AddAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	var awsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsRelationalDatabaseInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, awsRelationalDatabaseInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	nameUsed := true
	result := h.DB.Where("name = ?", awsRelationalDatabaseInstance.Name).First(&existingAwsRelationalDatabaseInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsRelationalDatabaseInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsRelationalDatabaseInstance.NotificationPayload(
		notifications.NotificationOperationCreated,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsRelationalDatabaseInstanceCreateSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all aws relational database instances.
// @Description Get all aws relational database instances from the Threeport database.
// @ID get-awsRelationalDatabaseInstances
// @Accept json
// @Produce json
// @Param name query string false "aws relational database instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances [get]
func (h Handler) GetAwsRelationalDatabaseInstances(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.AwsRelationalDatabaseInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.AwsRelationalDatabaseInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a aws relational database instance.
// @Description Get a particular aws relational database instance from the database.
// @ID get-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [get]
func (h Handler) GetAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var awsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&awsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws relational database instance.
// @Description Update a aws relational database instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws relational database instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseInstance body v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [patch]
func (h Handler) UpdateAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var existingAwsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&updatedAwsRelationalDatabaseInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	if result := h.DB.Model(&existingAwsRelationalDatabaseInstance).Updates(updatedAwsRelationalDatabaseInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsRelationalDatabaseInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws relational database instance by replacing the entire object.
// @Description Replace a aws relational database instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws relational database instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseInstance body v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [put]
func (h Handler) ReplaceAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var existingAwsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&updatedAwsRelationalDatabaseInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedAwsRelationalDatabaseInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsRelationalDatabaseInstance.ID = existingAwsRelationalDatabaseInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsRelationalDatabaseInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingAwsRelationalDatabaseInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a aws relational database instance.
// @Description Delete a aws relational database instance by ID from the database.
// @ID delete-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [delete]
func (h Handler) DeleteAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var awsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&awsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	if result := h.DB.Delete(&awsRelationalDatabaseInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller
	notifPayload, err := awsRelationalDatabaseInstance.NotificationPayload(
		notifications.NotificationOperationDeleted,
		false,
		0,
	)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}
	h.JS.Publish(v0.AwsRelationalDatabaseInstanceDeleteSubject, *notifPayload)

	response, err := v0.CreateResponse(nil, awsRelationalDatabaseInstance)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}
