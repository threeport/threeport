// generated by 'threeport-sdk gen' - do not edit

//go:build mage
// +build mage

package main

import (
	"fmt"
	mg "github.com/magefile/mage/mg"
	version "github.com/threeport/threeport/internal/version"
	installer "github.com/threeport/threeport/pkg/threeport-installer/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	"os"
	"os/exec"
	"runtime"
)

const releaseArch = "amd64"

// Build provides a type for methods that implement build targets.
type Build mg.Namespace

// Test provides a type for methods that implement test targets.
type Test mg.Namespace

// Install provides a type for methods that implement install targets.
type Install mg.Namespace

// Dev provides a type for methods that implement dev targets.
type Dev mg.Namespace

// ApiBin builds the REST API binary.
func (Build) ApiBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"rest-api",
		"cmd/rest-api/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build rest-api binary: %w", err)
	}

	fmt.Println("binary built and available at bin/rest-api")

	return nil
}

// ApiBinDev builds the REST API binary for the architcture of the machine
// where it is built.
func (Build) ApiBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ApiBin(arch); err != nil {
		return fmt.Errorf("failed to build dev rest-api binary: %w", err)
	}

	return nil
}

// ApiBinRelease builds the REST API binary for release architecture.
func (Build) ApiBinRelease() error {
	build := Build{}
	if err := build.ApiBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release rest-api binary: %w", err)
	}

	return nil
}

// ApiImage builds and pushes a REST API container image.
func (Build) ApiImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/rest-api/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-rest-api",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push rest-api image: %w", err)
	}

	return nil
}

// ApiImageDev builds and pushes a development REST API container image.
func (Build) ApiImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ApiImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev rest-api image: %w", err)
	}

	return nil
}

// ApiImageRelease builds and pushes a release REST API container image.
func (Build) ApiImageRelease() error {
	build := Build{}
	if err := build.ApiImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release rest-api image: %w", err)
	}

	return nil
}

// DbMigratorBin builds the database migrator binary.
func (Build) DbMigratorBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"database-migrator",
		"cmd/database-migrator/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build database-migrator binary: %w", err)
	}

	fmt.Println("binary built and available at bin/database-migrator")

	return nil
}

// DbMigratorBinDev builds the database migrator binary for the architcture of the machine
// where it is built.
func (Build) DbMigratorBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.DbMigratorBin(arch); err != nil {
		return fmt.Errorf("failed to build dev database-migrator binary: %w", err)
	}

	return nil
}

// DbMigratorBinRelease builds the database migrator binary for release architecture.
func (Build) DbMigratorBinRelease() error {
	build := Build{}
	if err := build.DbMigratorBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release database-migrator binary: %w", err)
	}

	return nil
}

// DbMigratorImage builds and pushes a database migrator container image.
func (Build) DbMigratorImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/database-migrator/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-database-migrator",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push database-migrator image: %w", err)
	}

	return nil
}

// DbMigratorImageDev builds and pushes a development database migrator container image.
func (Build) DbMigratorImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.DbMigratorImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev database-migrator image: %w", err)
	}

	return nil
}

// DbMigratorImageRelease builds and pushes a release database migrator container image.
func (Build) DbMigratorImageRelease() error {
	build := Build{}
	if err := build.DbMigratorImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release database-migrator image: %w", err)
	}

	return nil
}

// AgentBin builds the agent binary.
func (Build) AgentBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"agent",
		"cmd/agent/main.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build agent binary: %w", err)
	}

	fmt.Println("binary built and available at bin/agent")

	return nil
}

// AgentBinDev builds the agent binary for the architcture of the machine
// where it is built.
func (Build) AgentBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.AgentBin(arch); err != nil {
		return fmt.Errorf("failed to build dev agent binary: %w", err)
	}

	return nil
}

// AgentBinRelease builds the agent binary for release architecture.
func (Build) AgentBinRelease() error {
	build := Build{}
	if err := build.AgentBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release agent binary: %w", err)
	}

	return nil
}

// AgentImage builds and pushes a agent container image.
func (Build) AgentImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/agent/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-agent",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push agent image: %w", err)
	}

	return nil
}

// AgentImageDev builds and pushes a development agent container image.
func (Build) AgentImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.AgentImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev agent image: %w", err)
	}

	return nil
}

// AgentImageRelease builds and pushes a release agent container image.
func (Build) AgentImageRelease() error {
	build := Build{}
	if err := build.AgentImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release agent image: %w", err)
	}

	return nil
}

// SecretControllerBin builds the binary for the secret-controller.
func (Build) SecretControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"secret-controller",
		"cmd/secret-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build secret-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/secret-controller")

	return nil
}

// SecretControllerBinDev builds the secret-controller binary for the architcture of the machine
// where it is built.
func (Build) SecretControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.SecretControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev secret-controller binary: %w", err)
	}

	return nil
}

// SecretControllerBinRelease builds the secret-controller binary for release architecture.
func (Build) SecretControllerBinRelease() error {
	build := Build{}
	if err := build.SecretControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release secret-controller binary: %w", err)
	}

	return nil
}

// SecretControllerImage builds and pushes the container image for the secret-controller.
func (Build) SecretControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/secret-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-secret-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push secret-controller image: %w", err)
	}

	return nil
}

// SecretControllerImageDev builds and pushes a development secret-controller container image.
func (Build) SecretControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.SecretControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev secret-controller image: %w", err)
	}

	return nil
}

// SecretControllerImageRelease builds and pushes a release secret-controller container image.
func (Build) SecretControllerImageRelease() error {
	build := Build{}
	if err := build.SecretControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release secret-controller image: %w", err)
	}

	return nil
}

// AwsControllerBin builds the binary for the aws-controller.
func (Build) AwsControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"aws-controller",
		"cmd/aws-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build aws-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/aws-controller")

	return nil
}

// AwsControllerBinDev builds the aws-controller binary for the architcture of the machine
// where it is built.
func (Build) AwsControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.AwsControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev aws-controller binary: %w", err)
	}

	return nil
}

// AwsControllerBinRelease builds the aws-controller binary for release architecture.
func (Build) AwsControllerBinRelease() error {
	build := Build{}
	if err := build.AwsControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release aws-controller binary: %w", err)
	}

	return nil
}

// AwsControllerImage builds and pushes the container image for the aws-controller.
func (Build) AwsControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/aws-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-aws-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push aws-controller image: %w", err)
	}

	return nil
}

// AwsControllerImageDev builds and pushes a development aws-controller container image.
func (Build) AwsControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.AwsControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev aws-controller image: %w", err)
	}

	return nil
}

// AwsControllerImageRelease builds and pushes a release aws-controller container image.
func (Build) AwsControllerImageRelease() error {
	build := Build{}
	if err := build.AwsControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release aws-controller image: %w", err)
	}

	return nil
}

// ControlPlaneControllerBin builds the binary for the control-plane-controller.
func (Build) ControlPlaneControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"control-plane-controller",
		"cmd/control-plane-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build control-plane-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/control-plane-controller")

	return nil
}

// ControlPlaneControllerBinDev builds the control-plane-controller binary for the architcture of the machine
// where it is built.
func (Build) ControlPlaneControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ControlPlaneControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev control-plane-controller binary: %w", err)
	}

	return nil
}

// ControlPlaneControllerBinRelease builds the control-plane-controller binary for release architecture.
func (Build) ControlPlaneControllerBinRelease() error {
	build := Build{}
	if err := build.ControlPlaneControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release control-plane-controller binary: %w", err)
	}

	return nil
}

// ControlPlaneControllerImage builds and pushes the container image for the control-plane-controller.
func (Build) ControlPlaneControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/control-plane-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-control-plane-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push control-plane-controller image: %w", err)
	}

	return nil
}

// ControlPlaneControllerImageDev builds and pushes a development control-plane-controller container image.
func (Build) ControlPlaneControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ControlPlaneControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev control-plane-controller image: %w", err)
	}

	return nil
}

// ControlPlaneControllerImageRelease builds and pushes a release control-plane-controller container image.
func (Build) ControlPlaneControllerImageRelease() error {
	build := Build{}
	if err := build.ControlPlaneControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release control-plane-controller image: %w", err)
	}

	return nil
}

// GatewayControllerBin builds the binary for the gateway-controller.
func (Build) GatewayControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"gateway-controller",
		"cmd/gateway-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build gateway-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/gateway-controller")

	return nil
}

// GatewayControllerBinDev builds the gateway-controller binary for the architcture of the machine
// where it is built.
func (Build) GatewayControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.GatewayControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev gateway-controller binary: %w", err)
	}

	return nil
}

// GatewayControllerBinRelease builds the gateway-controller binary for release architecture.
func (Build) GatewayControllerBinRelease() error {
	build := Build{}
	if err := build.GatewayControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release gateway-controller binary: %w", err)
	}

	return nil
}

// GatewayControllerImage builds and pushes the container image for the gateway-controller.
func (Build) GatewayControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/gateway-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-gateway-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push gateway-controller image: %w", err)
	}

	return nil
}

// GatewayControllerImageDev builds and pushes a development gateway-controller container image.
func (Build) GatewayControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.GatewayControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev gateway-controller image: %w", err)
	}

	return nil
}

// GatewayControllerImageRelease builds and pushes a release gateway-controller container image.
func (Build) GatewayControllerImageRelease() error {
	build := Build{}
	if err := build.GatewayControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release gateway-controller image: %w", err)
	}

	return nil
}

// HelmWorkloadControllerBin builds the binary for the helm-workload-controller.
func (Build) HelmWorkloadControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"helm-workload-controller",
		"cmd/helm-workload-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build helm-workload-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/helm-workload-controller")

	return nil
}

// HelmWorkloadControllerBinDev builds the helm-workload-controller binary for the architcture of the machine
// where it is built.
func (Build) HelmWorkloadControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.HelmWorkloadControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev helm-workload-controller binary: %w", err)
	}

	return nil
}

// HelmWorkloadControllerBinRelease builds the helm-workload-controller binary for release architecture.
func (Build) HelmWorkloadControllerBinRelease() error {
	build := Build{}
	if err := build.HelmWorkloadControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release helm-workload-controller binary: %w", err)
	}

	return nil
}

// HelmWorkloadControllerImage builds and pushes the container image for the helm-workload-controller.
func (Build) HelmWorkloadControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/helm-workload-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-helm-workload-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push helm-workload-controller image: %w", err)
	}

	return nil
}

// HelmWorkloadControllerImageDev builds and pushes a development helm-workload-controller container image.
func (Build) HelmWorkloadControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.HelmWorkloadControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev helm-workload-controller image: %w", err)
	}

	return nil
}

// HelmWorkloadControllerImageRelease builds and pushes a release helm-workload-controller container image.
func (Build) HelmWorkloadControllerImageRelease() error {
	build := Build{}
	if err := build.HelmWorkloadControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release helm-workload-controller image: %w", err)
	}

	return nil
}

// KubernetesRuntimeControllerBin builds the binary for the kubernetes-runtime-controller.
func (Build) KubernetesRuntimeControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"kubernetes-runtime-controller",
		"cmd/kubernetes-runtime-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build kubernetes-runtime-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/kubernetes-runtime-controller")

	return nil
}

// KubernetesRuntimeControllerBinDev builds the kubernetes-runtime-controller binary for the architcture of the machine
// where it is built.
func (Build) KubernetesRuntimeControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.KubernetesRuntimeControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev kubernetes-runtime-controller binary: %w", err)
	}

	return nil
}

// KubernetesRuntimeControllerBinRelease builds the kubernetes-runtime-controller binary for release architecture.
func (Build) KubernetesRuntimeControllerBinRelease() error {
	build := Build{}
	if err := build.KubernetesRuntimeControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release kubernetes-runtime-controller binary: %w", err)
	}

	return nil
}

// KubernetesRuntimeControllerImage builds and pushes the container image for the kubernetes-runtime-controller.
func (Build) KubernetesRuntimeControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/kubernetes-runtime-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-kubernetes-runtime-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push kubernetes-runtime-controller image: %w", err)
	}

	return nil
}

// KubernetesRuntimeControllerImageDev builds and pushes a development kubernetes-runtime-controller container image.
func (Build) KubernetesRuntimeControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.KubernetesRuntimeControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev kubernetes-runtime-controller image: %w", err)
	}

	return nil
}

// KubernetesRuntimeControllerImageRelease builds and pushes a release kubernetes-runtime-controller container image.
func (Build) KubernetesRuntimeControllerImageRelease() error {
	build := Build{}
	if err := build.KubernetesRuntimeControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release kubernetes-runtime-controller image: %w", err)
	}

	return nil
}

// ObservabilityControllerBin builds the binary for the observability-controller.
func (Build) ObservabilityControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"observability-controller",
		"cmd/observability-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build observability-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/observability-controller")

	return nil
}

// ObservabilityControllerBinDev builds the observability-controller binary for the architcture of the machine
// where it is built.
func (Build) ObservabilityControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ObservabilityControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev observability-controller binary: %w", err)
	}

	return nil
}

// ObservabilityControllerBinRelease builds the observability-controller binary for release architecture.
func (Build) ObservabilityControllerBinRelease() error {
	build := Build{}
	if err := build.ObservabilityControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release observability-controller binary: %w", err)
	}

	return nil
}

// ObservabilityControllerImage builds and pushes the container image for the observability-controller.
func (Build) ObservabilityControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/observability-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-observability-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push observability-controller image: %w", err)
	}

	return nil
}

// ObservabilityControllerImageDev builds and pushes a development observability-controller container image.
func (Build) ObservabilityControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.ObservabilityControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev observability-controller image: %w", err)
	}

	return nil
}

// ObservabilityControllerImageRelease builds and pushes a release observability-controller container image.
func (Build) ObservabilityControllerImageRelease() error {
	build := Build{}
	if err := build.ObservabilityControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release observability-controller image: %w", err)
	}

	return nil
}

// TerraformControllerBin builds the binary for the terraform-controller.
func (Build) TerraformControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"terraform-controller",
		"cmd/terraform-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build terraform-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/terraform-controller")

	return nil
}

// TerraformControllerBinDev builds the terraform-controller binary for the architcture of the machine
// where it is built.
func (Build) TerraformControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.TerraformControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev terraform-controller binary: %w", err)
	}

	return nil
}

// TerraformControllerBinRelease builds the terraform-controller binary for release architecture.
func (Build) TerraformControllerBinRelease() error {
	build := Build{}
	if err := build.TerraformControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release terraform-controller binary: %w", err)
	}

	return nil
}

// TerraformControllerImage builds and pushes the container image for the terraform-controller.
func (Build) TerraformControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/terraform-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-terraform-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push terraform-controller image: %w", err)
	}

	return nil
}

// TerraformControllerImageDev builds and pushes a development terraform-controller container image.
func (Build) TerraformControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.TerraformControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev terraform-controller image: %w", err)
	}

	return nil
}

// TerraformControllerImageRelease builds and pushes a release terraform-controller container image.
func (Build) TerraformControllerImageRelease() error {
	build := Build{}
	if err := build.TerraformControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release terraform-controller image: %w", err)
	}

	return nil
}

// WorkloadControllerBin builds the binary for the workload-controller.
func (Build) WorkloadControllerBin(arch string) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildBinary(
		workingDir,
		arch,
		"workload-controller",
		"cmd/workload-controller/main_gen.go",
		false,
	); err != nil {
		return fmt.Errorf("failed to build workload-controller binary: %w", err)
	}

	fmt.Println("binary built and available at bin/workload-controller")

	return nil
}

// WorkloadControllerBinDev builds the workload-controller binary for the architcture of the machine
// where it is built.
func (Build) WorkloadControllerBinDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.WorkloadControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build dev workload-controller binary: %w", err)
	}

	return nil
}

// WorkloadControllerBinRelease builds the workload-controller binary for release architecture.
func (Build) WorkloadControllerBinRelease() error {
	build := Build{}
	if err := build.WorkloadControllerBin(releaseArch); err != nil {
		return fmt.Errorf("failed to build release workload-controller binary: %w", err)
	}

	return nil
}

// WorkloadControllerImage builds and pushes the container image for the workload-controller.
func (Build) WorkloadControllerImage(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	workingDir, _, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get working directory for extension repo: %w", err)
	}

	if err := util.BuildImage(
		workingDir,
		"cmd/workload-controller/image/Dockerfile-alpine",
		arch,
		imageRepo,
		"threeport-workload-controller",
		imageTag,
		true,
		false,
		"",
	); err != nil {
		return fmt.Errorf("failed to build and push workload-controller image: %w", err)
	}

	return nil
}

// WorkloadControllerImageDev builds and pushes a development workload-controller container image.
func (Build) WorkloadControllerImageDev() error {
	_, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get local CPU architecture: %w", err)
	}

	build := Build{}
	if err := build.WorkloadControllerImage(
		installer.DevImageRepo,
		version.GetVersion(),
		arch,
	); err != nil {
		return fmt.Errorf("failed to build and push dev workload-controller image: %w", err)
	}

	return nil
}

// WorkloadControllerImageRelease builds and pushes a release workload-controller container image.
func (Build) WorkloadControllerImageRelease() error {
	build := Build{}
	if err := build.WorkloadControllerImage(
		installer.ThreeportImageRepo,
		version.GetVersion(),
		releaseArch,
	); err != nil {
		return fmt.Errorf("failed to build and push release workload-controller image: %w", err)
	}

	return nil
}

// AllBins builds the binaries for all components.
func (Build) AllBins(arch string) error {
	build := Build{}
	if err := build.ApiBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.DbMigratorBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AgentBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.SecretControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AwsControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ControlPlaneControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.GatewayControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.HelmWorkloadControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.KubernetesRuntimeControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ObservabilityControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.TerraformControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.WorkloadControllerBin(arch); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	return nil
}

// AllBins builds the development binaries for all components.
func (Build) AllBinsDev() error {
	build := Build{}
	if err := build.ApiBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.DbMigratorBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AgentBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.SecretControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AwsControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ControlPlaneControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.GatewayControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.HelmWorkloadControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.KubernetesRuntimeControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ObservabilityControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.TerraformControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.WorkloadControllerBinDev(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	return nil
}

// AllBins builds the release binaries for all components.
func (Build) AllBinsRelease() error {
	build := Build{}
	if err := build.ApiBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.DbMigratorBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AgentBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.SecretControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.AwsControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ControlPlaneControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.GatewayControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.HelmWorkloadControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.KubernetesRuntimeControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.ObservabilityControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.TerraformControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	if err := build.WorkloadControllerBinRelease(); err != nil {
		return fmt.Errorf("failed to build binary: %w", err)
	}

	return nil
}

// AllImages builds and pushes images for all components.
func (Build) AllImages(
	imageRepo string,
	imageTag string,
	arch string,
) error {
	build := Build{}
	if err := build.ApiImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.DbMigratorImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AgentImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.SecretControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AwsControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ControlPlaneControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.GatewayControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.HelmWorkloadControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.KubernetesRuntimeControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ObservabilityControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.TerraformControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.WorkloadControllerImage(imageRepo, imageTag, arch); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	return nil
}

// AllImagesDev builds and pushes development images for all components.
func (Build) AllImagesDev() error {
	build := Build{}
	if err := build.ApiImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.DbMigratorImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AgentImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.SecretControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AwsControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ControlPlaneControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.GatewayControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.HelmWorkloadControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.KubernetesRuntimeControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ObservabilityControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.TerraformControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.WorkloadControllerImageDev(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	return nil
}

// AllImagesRelease builds and pushes development images for all components.
func (Build) AllImagesRelease() error {
	build := Build{}
	if err := build.ApiImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.DbMigratorImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AgentImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.SecretControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.AwsControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ControlPlaneControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.GatewayControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.HelmWorkloadControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.KubernetesRuntimeControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.ObservabilityControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.TerraformControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	if err := build.WorkloadControllerImageRelease(); err != nil {
		return fmt.Errorf("failed to build and push image: %w", err)
	}

	return nil
}

// LoadImage builds and loads an image to the provided kind cluster.
func (Dev) LoadImage(kindClusterName string, component string) error {
	workingDir, arch, err := getBuildVals()
	if err != nil {
		return fmt.Errorf("failed to get build values: %w", err)
	}

	imageName := fmt.Sprintf("threeport-%s", component)

	if err := util.BuildImage(
		workingDir,
		fmt.Sprintf("cmd/%s/image/Dockerfile-alpine", component),
		arch,
		installer.DevImageRepo,
		imageName,
		version.GetVersion(),
		false,
		true,
		kindClusterName,
	); err != nil {
		return fmt.Errorf("failed to build and load image: %w", err)
	}

	return nil
}

// GenerateSwaggerDocs generates the API server swagger documentation served by the API.
func (Dev) GenerateSwaggerDocs() error {
	docsDestination := "pkg/api-server/v0/docs"
	swagCmd := exec.Command(
		"swag",
		"init",
		"--dir",
		"cmd/rest-api,pkg/api,pkg/api-server/v0",
		"--parseDependency",
		"--generalInfo",
		"main_gen.go",
		"--output",
		docsDestination,
	)

	output, err := swagCmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("API docs generation failed with output '%s': %w", output, err)
	}

	fmt.Printf("API docs generated in %s\n", docsDestination)

	return nil
}

// getBuildVals returns the working directory and arch for builds.
func getBuildVals() (string, string, error) {
	workingDir, err := os.Getwd()
	if err != nil {
		return "", "", fmt.Errorf("failed to get working directory: %w", err)
	}

	arch := runtime.GOARCH

	return workingDir, arch, nil
}
