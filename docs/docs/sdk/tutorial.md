# Threeport SDK Tutorial

The following tutorial walks through building a Threeport extension for managing
Wordpress deployments.

> Note: This tutorial provides instructions to build a new Golang project from
> scratch.  If you'd like to skip to the end, the finished project can be viewed on
> [GitHub](https://github.com/threeport/wordpress-threeport-extension).

## Prerequisites

* [Install threeport-sdk](install.md)
* [Install tptctl](../install/install-tptctl.md)
* [Install docker](https://docs.docker.com/engine/install/)
* [Install golang](https://go.dev/doc/install)
* [Install mage](https://magefile.org/)

## Initialize Project

```bash
mkdir wordpress-threeport-extension
cd wordpress-threeport-extension
git init
go mod init wordpress-threeport-extension
```

## Create SDK Config

Create a new file at the root of the repo called `sdk-config.yaml` with the
following contents.  Replace the `ImageRepo` value for one that you have access
to.

```yaml
ExtensionName: Wordpress
ApiNamespace: example.com
ApiDocs:
  Title: WordPress Threeport API
  Description: API server for the WordPress extension to Threeport.
  ContactName: John Doe
  ContactEmail: john@example.com
ImageRepo: ghcr.io/myorg/myimage
ApiObjectGroups:
- Name: wordpress
  Objects:
    - Name: WordpressDefinition
      Versions:
        - v0
      Reconcilable: true
      Tptctl:
        Enabled: true
    - Name: WordpressInstance
      Versions:
        - v0
      Reconcilable: true
      Tptctl:
        Enabled: true
```

## Define API

Use the Threeport SDK to create scaffolding for new API objects.  This will
create a source code file for each API object group defined in the SDK config.
In each source code file, an object that corresponds to a database table will be
scaffolded.

```bash
threeport-sdk create --config sdk-config.yaml
```

For the SDK config shown above, it will create the following.

```go
// originally generated by 'threeport-sdk create' for API object
// scaffolding but will not be re-generated - intended for modification

package v0

import tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"

type WordpressDefinition struct {
	tpapi_v0.Common         `mapstructure:",squash" swaggerignore:"true"`
	tpapi_v0.Reconciliation `mapstructure:",squash"`
	tpapi_v0.Definition     `mapstructure:",squash"`
	WordpressInstances      []*WordpressInstance `json:"WordpressInstances,omitempty" validate:"optional,association"`
}

type WordpressInstance struct {
	tpapi_v0.Common         `mapstructure:",squash" swaggerignore:"true"`
	tpapi_v0.Reconciliation `mapstructure:",squash"`
	tpapi_v0.Instance       `mapstructure:",squash"`
	WordpressDefinitionID   *uint `gorm:"not null" json:"WordpressDefinitionID,omitempty" query:"wordpressdefinitionid" validate:"required"`
}
```

This constitutes your Threeport extension's data model.  Add fields to these
objects for config information that will need to be persisted.

Add the following fields so that the file looks as follows when you are
finished.

```go
// originally generated by 'threeport-sdk create' for API object
// scaffolding but will not be re-generated - intended for modification

package v0

import tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"

type WordpressDefinition struct {
	tpapi_v0.Common         `mapstructure:",squash" swaggerignore:"true"`
	tpapi_v0.Reconciliation `mapstructure:",squash"`
	tpapi_v0.Definition     `mapstructure:",squash"`

	// The environment type used to determine config settings for a wordpress
	// definition.
	Environment *string `json:"Environment,omitempty" query:"environment" gorm:"default:dev" validate:"optional"`

	// The number of pod replicas to deploy for the WordPress app
	Replicas *int `json:"Replicas,omitempty" query:"replicas" validate:"optional"`

	// If true, a cloud provider's managed database will be used for the
	// WordPress DB.  If false, a containerized database will be deployed to
	// Kubernetes.
	ManagedDatabase *bool `json:"ManagedDatabase,omitempty" query:"manageddatabase" gorm:"default:false" validate:"optional"`

	WordpressInstances []*WordpressInstance `json:"WordpressInstances,omitempty" validate:"optional,association"`
}

type WordpressInstance struct {
	tpapi_v0.Common         `mapstructure:",squash" swaggerignore:"true"`
	tpapi_v0.Reconciliation `mapstructure:",squash"`
	tpapi_v0.Instance       `mapstructure:",squash"`

	// When using a DomainName, the subdomain to use to reach the WordPress
	// instance.
	SubDomain *string `jaon:"SubDomain,omitempty" query:"subdomain" validate:"optional"`

	WordpressDefinitionID *uint `gorm:"not null" json:"WordpressDefinitionID,omitempty" query:"wordpressdefinitionid" validate:"required"`
}
```

## Generate Source Code

```bash
threeport-sdk gen --config sdk-config.yaml
```

This will generate all the source code boilerplate and scaffolding needed for the
project.

## Add Controller Business Logic

The next step is to add the business logic for managing wordpress instances to
the scaffolding for the wordpress controller.

### Updates to `internal/wordpress/v0_wordpress_definition.go`

The first file we will modify managed `WordpressDefinition` objects.  The file
is located at `internal/wordpress/v0_wordpress_definition.go`.  If you open that
file, you'll see functions to create, update and delete those objects.  These
functions run when the corresponding actions are executed through the Threeport
API.

Now, let's update that file to insert some business logic.  In the following
code snippet, is a new constant and the contents for the `v0WordpressDefinitionCreated`
function.  Update your code to reflect these changes.


```go
const wordpressDbConnSecretName = "wordpress-db-conn"

// v0WordpressDefinitionCreated performs reconciliation when a v0 WordpressDefinition
// has been created.
func v0WordpressDefinitionCreated(
	r *controller.Reconciler,
	wordpressDefinition *v0.WordpressDefinition,
	log *logr.Logger,
) (int64, error) {
	// set wordpress deployment replicas
	var wordpressReplicas int
	if wordpressDefinition.Replicas != nil {
		wordpressReplicas = *wordpressDefinition.Replicas
	} else {
		wordpressReplicas = setWordpressReplicasByEnv(*wordpressDefinition.Environment)
	}

	// set wordpress DB storage volume size
	wordpressDbStorageGb := setWordpressDbStorage(*wordpressDefinition.Environment)

	// generate YAML manifest for wordpress app
	yamlDoc, err := wordpressYaml(
		*wordpressDefinition.Name,
		wordpressReplicas,
		*wordpressDefinition.Environment,
		*wordpressDefinition.ManagedDatabase,
		wordpressDbStorageGb,
		wordpressDbConnSecretName,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to generate wordpress YAML manifest: %w", err)
	}

	// create wordpress workload definition if it doesn't already exist
	nameQuery := fmt.Sprintf("name=%s", *wordpressDefinition.Name)
	existingWorkloadDefinitions, err := tpclient.GetWorkloadDefinitionsByQueryString(
		r.APIClient,
		r.APIServer,
		nameQuery,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to check for workload definitions with name %s: %w", *wordpressDefinition.Name, err)
	}
	var createdWorkloadDefinition *tpapi.WorkloadDefinition
	if len(*existingWorkloadDefinitions) == 0 {
		workloadDefinition := tpapi.WorkloadDefinition{
			Definition: tpapi.Definition{
				Name: wordpressDefinition.Name,
			},
			YAMLDocument: &yamlDoc,
		}
		createdWorkloadDef, err := tpclient.CreateWorkloadDefinition(
			r.APIClient,
			r.APIServer,
			&workloadDefinition,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create Threeport workload definition: %w", err)
		}
		createdWorkloadDefinition = createdWorkloadDef
	} else {
		createdWorkloadDefinition = &(*existingWorkloadDefinitions)[0]
	}

	// establish attachment between wordpress definition and workload definition
	if err := tpclient.EnsureAttachedObjectReferenceExists(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadDefinition,
		createdWorkloadDefinition.ID,
		v0.ObjectTypeWordpressDefinition,
		wordpressDefinition.ID,
	); err != nil {
		return 0, fmt.Errorf("failed to attach wordpress definition to workload definition: %w", err)
	}

	// create relational database definition if requested
	if *wordpressDefinition.ManagedDatabase {
		storageGb := setWordpressDbStorage(*wordpressDefinition.Environment)
		var backupDays int
		var machineSize string
		switch *wordpressDefinition.Environment {
		case "prod":
			backupDays = 30
			machineSize = "Large"
		default:
			backupDays = 0
			machineSize = "XSmall"
		}
		// get AWS account ID
		awsAccountId, err := tpclient.GetObjectIdByAttachedObject(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeAwsAccount,
			v0.ObjectTypeWordpressDefinition,
			*wordpressDefinition.ID,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to get attached AWS account ID: %w", err)
		}
		// construct relational database definition
		awsRdsDefinition := tpapi.AwsRelationalDatabaseDefinition{
			Definition: tpapi.Definition{
				Name: wordpressDefinition.Name,
			},
			Engine:             util.Ptr("mariadb"),
			EngineVersion:      util.Ptr("10.11"),
			DatabaseName:       util.Ptr("wordpress"),
			DatabasePort:       util.Ptr(3306),
			BackupDays:         util.Ptr(backupDays),
			StorageGb:          util.Ptr(storageGb),
			MachineSize:        util.Ptr(machineSize),
			WorkloadSecretName: util.Ptr(wordpressDbConnSecretName),
			AwsAccountID:       awsAccountId,
		}
		// create releational database definition
		createdAwsRdsDefinition, err := tpclient.CreateAwsRelationalDatabaseDefinition(
			r.APIClient,
			r.APIServer,
			&awsRdsDefinition,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create AWS relational database definition: %w", err)
		}
		// establish attachment between wordpress definition and relational
		// database definition
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeAwsRelationalDatabaseDefinition,
			createdAwsRdsDefinition.ID,
			v0.ObjectTypeWordpressDefinition,
			wordpressDefinition.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to attach wordpress definition to AWS relational database definition: %w", err)
		}
	}

	return 0, nil
}
```

Now, let's update the `v0WordpressDefinitionDeleted` function with the code shown
below.

```go
// v0WordpressDefinitionDeleted performs reconciliation when a v0 WordpressDefinition
// has been deleted.
func v0WordpressDefinitionDeleted(
	r *controller.Reconciler,
	wordpressDefinition *v0.WordpressDefinition,
	log *logr.Logger,
) (int64, error) {
	// get attached workload definition
	workloadDefinitionId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadDefinition,
		v0.ObjectTypeWordpressDefinition,
		*wordpressDefinition.ID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to find attached workload definition: %w", err)
	}

	// delete workload definition
	_, err = tpclient.DeleteWorkloadDefinition(
		r.APIClient,
		r.APIServer,
		*workloadDefinitionId,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to delete workload definition: %w", err)
	}

	// remove workload definition attachment
	if err := tpclient.EnsureAttachedObjectReferenceRemoved(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadDefinition,
		workloadDefinitionId,
		v0.ObjectTypeWordpressDefinition,
		wordpressDefinition.ID,
	); err != nil {
		return 0, fmt.Errorf("failed to remove attachment to deleted workload definition: %w", err)
	}

	// delete relational database definition if it exists
	awsRdsDefinitionIds, err := tpclient.GetObjectIdsByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeAwsRelationalDatabaseDefinition,
		v0.ObjectTypeWordpressDefinition,
		*wordpressDefinition.ID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get attached AWS relational database definition IDs: %w", err)
	}
	for _, awsRdsDefinitionId := range awsRdsDefinitionIds {
		_, err := tpclient.DeleteGatewayInstance(
			r.APIClient,
			r.APIServer,
			*awsRdsDefinitionId,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to delete AWS relational database definition with ID %d: %w", *awsRdsDefinitionId, err)
		}
		if err := tpclient.EnsureAttachedObjectReferenceRemoved(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeGatewayDefinition,
			awsRdsDefinitionId,
			v0.ObjectTypeWordpressDefinition,
			wordpressDefinition.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to remove wordpress definition attachment to deleted AWS relational database definition: %w", err)
		}
	}

	return 0, nil
}
```

Lastly, add these two functions at the end of that file.

```go
// setWordpressReplicasByEnv sets default replicas for the Wordpress deployment
// based on the environment value.
func setWordpressReplicasByEnv(env string) int {
	switch env {
	case "prod":
		return 5
	default:
		return 2
	}
}

// setWordpressDbStorage sets the database storage volume size.
func setWordpressDbStorage(env string) int {
	switch env {
	case "prod":
		return 100
	default:
		return 20
	}
}
```

Ensure the following imports are included in this file.

```go
import (
	"fmt"

	logr "github.com/go-logr/logr"
	tpapi "github.com/threeport/threeport/pkg/api/v0"
	tpclient "github.com/threeport/threeport/pkg/client/v0"
	controller "github.com/threeport/threeport/pkg/controller/v0"
	util "github.com/threeport/threeport/pkg/util/v0"

	v0 "wordpress-threeport-extension/pkg/api/v0"
)
```


### Updates to `internal/wordpress/v0_wordpress_instance.go`

Lastly, let's add the operations to mange `WordpressInstance` objects.  The
scaffolding for this is in `internal/wordpress/v0_wordpress_instance.go`.  If
you open that file, you'll see empty functions to create, update and delete
these objects.  Again, when actions are executed through the Threeport API,
these functions will be called to reconcile the desired operations.

Update the `v0WordpressInstanceCreated` function as shown below.

```go
// v0WordpressInstanceCreated performs reconciliation when a v0 WordpressInstance
// has been created.
func v0WordpressInstanceCreated(
	r *controller.Reconciler,
	wordpressInstance *v0.WordpressInstance,
	log *logr.Logger,
) (int64, error) {
	// get attached Kubernetes runtime instance ID
	kubernetesRuntimeInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeKubernetesRuntimeInstance,
		v0.ObjectTypeWordpressInstance,
		*wordpressInstance.ID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get Kubernetes runtime instance by attachment: %w", err)
	}

	// get workload definition attached to wordpress definition
	workloadDefinitionId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadDefinition,
		v0.ObjectTypeWordpressDefinition,
		*wordpressInstance.WordpressDefinitionID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get workload definition by attachment: %w", err)
	}

	// create workload instance if it doesn't already exist
	nameQuery := fmt.Sprintf("name=%s", *wordpressInstance.Name)
	existingWorkloadInstances, err := tpclient.GetWorkloadInstancesByQueryString(
		r.APIClient,
		r.APIServer,
		nameQuery,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to check for workload instance with name %s: %w", *wordpressInstance.Name, err)
	}
	var createdWorkloadInstance *tpapi.WorkloadInstance
	if len(*existingWorkloadInstances) == 0 {
		workloadInstance := tpapi.WorkloadInstance{
			Instance: tpapi.Instance{
				Name: wordpressInstance.Name,
			},
			KubernetesRuntimeInstanceID: kubernetesRuntimeInstanceId,
			WorkloadDefinitionID:        workloadDefinitionId,
		}
		createdWorkloadInst, err := tpclient.CreateWorkloadInstance(
			r.APIClient,
			r.APIServer,
			&workloadInstance,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create workload instance: %w", err)
		}
		createdWorkloadInstance = createdWorkloadInst
	}

	// establish attachment between wordpress instance and workload instance
	if err := tpclient.EnsureAttachedObjectReferenceExists(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadInstance,
		createdWorkloadInstance.ID,
		v0.ObjectTypeWordpressInstance,
		wordpressInstance.ID,
	); err != nil {
		return 0, fmt.Errorf("failed to attach wordpress instance to workload instance: %w", err)
	}

	// get wordpress definition
	wordpressDefinition, err := client.GetWordpressDefinitionByID(
		r.APIClient,
		r.APIServer,
		*wordpressInstance.WordpressDefinitionID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get wordpress definition: %w", err)
	}

	// get infra provider for kubernetes runtime - needed to determine storage
	// class for wordpress PVC
	infraProvider, err := tpclient.GetInfraProviderByKubernetesRuntimeInstanceID(
		r.APIClient,
		r.APIServer,
		kubernetesRuntimeInstanceId,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to determine infra provider for Kubernetes runtime: %w", err)
	}

	// get the manifest for the PVC
	pvcManifest, err := getPvcManifest(
		*infraProvider,
		*wordpressDefinition.Name,
		*wordpressDefinition.Environment,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get Kubernetes manifest for persistent volume claim: %w", err)
	}

	// create the workload resource instance for the PVC
	pvcWri := tpapi.WorkloadResourceInstance{
		JSONDefinition:     pvcManifest,
		WorkloadInstanceID: createdWorkloadInstance.ID,
	}
	_, err = tpclient.CreateWorkloadResourceInstance(
		r.APIClient,
		r.APIServer,
		&pvcWri,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to create workload resource instance for persistent volume claim: %w", err)
	}

	// trigger reconciliation to create the PVC
	unreconciledWorkloadInstance := tpapi.WorkloadInstance{
		Common: tpapi.Common{
			ID: createdWorkloadInstance.ID,
		},
		Reconciliation: tpapi.Reconciliation{
			Reconciled: util.Ptr(false),
		},
	}
	_, err = tpclient.UpdateWorkloadInstance(
		r.APIClient,
		r.APIServer,
		&unreconciledWorkloadInstance,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to update workload instance as unreconciled: %w", err)
	}

	// create relational database instance if requested
	if *wordpressDefinition.ManagedDatabase {
		// get relational database definition ID
		awsRdsDefinitionId, err := tpclient.GetObjectIdByAttachedObject(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeAwsRelationalDatabaseDefinition,
			v0.ObjectTypeWordpressDefinition,
			*wordpressDefinition.ID,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to get AWS relational database definition ID by attachment: %w", err)
		}
		// construct relational database instance
		awsRdsInstance := tpapi.AwsRelationalDatabaseInstance{
			Instance: tpapi.Instance{
				Name: wordpressInstance.Name,
			},
			AwsRelationalDatabaseDefinitionID: awsRdsDefinitionId,
			WorkloadInstanceID:                createdWorkloadInstance.ID,
		}
		// create relational database instance
		createdRdsInstance, err := tpclient.CreateAwsRelationalDatabaseInstance(
			r.APIClient,
			r.APIServer,
			&awsRdsInstance,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create AWS relational database instance: %w", err)
		}
		// establish attachment between wordpress instance and relational
		// database instance
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeAwsRelationalDatabaseInstance,
			createdRdsInstance.ID,
			v0.ObjectTypeWordpressInstance,
			wordpressInstance.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to attach wordpress instance to AWS relational database instance: %w", err)
		}
	}

	// create gateway and subdomain DNS record if requested
	if wordpressInstance.SubDomain != nil && *wordpressInstance.SubDomain != "" {
		// get attached domain name definition ID
		domainNameDefinitionId, err := tpclient.GetObjectIdByAttachedObject(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeDomainNameDefinition,
			v0.ObjectTypeWordpressDefinition,
			*wordpressDefinition.ID,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to get attached domain name definition: %w", err)
		}
		// contruct gateway definition object
		gatewayDefinition := tpapi.GatewayDefinition{
			Definition: tpapi.Definition{
				Name: util.Ptr("web-service-gateway"),
			},
			HttpPorts: []*tpapi.GatewayHttpPort{
				{
					Port:          util.Ptr(80),
					Path:          util.Ptr("/"),
					HTTPSRedirect: util.Ptr(true),
				}, {
					Port:       util.Ptr(443),
					Path:       util.Ptr("/"),
					TLSEnabled: util.Ptr(true),
				},
			},
			DomainNameDefinitionID: domainNameDefinitionId,
			SubDomain:              wordpressInstance.SubDomain,
			ServiceName:            util.Ptr(getWordpressServiceName(*wordpressDefinition.Name)),
			WorkloadDefinitionID:   workloadDefinitionId,
		}
		// create gateway definition
		createdGatewayDefinition, err := tpclient.CreateGatewayDefinition(
			r.APIClient,
			r.APIServer,
			&gatewayDefinition,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create gateway definition: %w", err)
		}
		// construct gateway instance
		gatewayInstance := tpapi.GatewayInstance{
			Instance: tpapi.Instance{
				Name: util.Ptr(fmt.Sprintf("%s-gateway", *wordpressInstance.Name)),
			},
			KubernetesRuntimeInstanceID: kubernetesRuntimeInstanceId,
			GatewayDefinitionID:         createdGatewayDefinition.ID,
			WorkloadInstanceID:          createdWorkloadInstance.ID,
		}
		// created gateway instance
		createdGatewayInstance, err := tpclient.CreateGatewayInstance(
			r.APIClient,
			r.APIServer,
			&gatewayInstance,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create gateway instance: %w", err)
		}
		// create attachment between gateway instance and wordpress instance
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeGatewayInstance,
			createdGatewayInstance.ID,
			v0.ObjectTypeWordpressInstance,
			wordpressInstance.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to create attachment between wordpress instance and gateway instance: %w", err)
		}
		// construct domain name instance
		domainNameInstance := tpapi.DomainNameInstance{
			Instance: tpapi.Instance{
				Name: util.Ptr(fmt.Sprintf("%s-domain-name", *wordpressInstance.Name)),
			},
			DomainNameDefinitionID:      domainNameDefinitionId,
			WorkloadInstanceID:          createdWorkloadInstance.ID,
			KubernetesRuntimeInstanceID: kubernetesRuntimeInstanceId,
		}
		// create domain name instance
		createdDomainNameInstance, err := tpclient.CreateDomainNameInstance(
			r.APIClient,
			r.APIServer,
			&domainNameInstance,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to create domain name instance: %w", err)
		}
		// create attachment between domain name instance and wordpress instance
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeDomainNameInstance,
			createdDomainNameInstance.ID,
			v0.ObjectTypeWordpressInstance,
			wordpressInstance.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to create attachment between wordpress instance and domain name instance: %w", err)
		}
	}

	return 0, nil
}
```

Now, update the `v0WordpressInstanceDeleted` function with the code below.

```go
// v0WordpressInstanceDeleted performs reconciliation when a v0 WordpressInstance
// has been deleted.
func v0WordpressInstanceDeleted(
	r *controller.Reconciler,
	wordpressInstance *v0.WordpressInstance,
	log *logr.Logger,
) (int64, error) {
	// get attached workload instance
	workloadInstanceId, err := tpclient.GetObjectIdByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadInstance,
		v0.ObjectTypeWordpressInstance,
		*wordpressInstance.ID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to find attached workload instance: %w", err)
	}

	// delete workload instance
	_, err = tpclient.DeleteWorkloadInstance(
		r.APIClient,
		r.APIServer,
		*workloadInstanceId,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to delete workload instance: %w", err)
	}

	// remove workload instance attachment
	if err := tpclient.EnsureAttachedObjectReferenceRemoved(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeWorkloadInstance,
		workloadInstanceId,
		v0.ObjectTypeWordpressInstance,
		wordpressInstance.ID,
	); err != nil {
		return 0, fmt.Errorf("failed to remove attachment to deleted workload instance: %w", err)
	}

	// delete relational database instance if it exists
	awsRdsInstanceIds, err := tpclient.GetObjectIdsByAttachedObject(
		r.APIClient,
		r.APIServer,
		tpapi.ObjectTypeAwsRelationalDatabaseInstance,
		v0.ObjectTypeWordpressInstance,
		*wordpressInstance.ID,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get attached relational database IDs: %w", err)
	}
	for _, rdsInstanceId := range awsRdsInstanceIds {
		_, err := tpclient.DeleteAwsRelationalDatabaseInstance(
			r.APIClient,
			r.APIServer,
			*rdsInstanceId,
		)
		if err != nil {
			return 0, fmt.Errorf("failed to delete AWS RDS instance with id %d: %w", *rdsInstanceId, err)
		}
		if err := tpclient.EnsureAttachedObjectReferenceRemoved(
			r.APIClient,
			r.APIServer,
			tpapi.ObjectTypeAwsRelationalDatabaseInstance,
			rdsInstanceId,
			v0.ObjectTypeWordpressInstance,
			wordpressInstance.ID,
		); err != nil {
			return 0, fmt.Errorf("failed to remove attachment to deleted AWS relational database instance: %w", err)
		}
	}

	return 0, nil
}
```

Ensure the following imports are included in this file.

```go
import (
	"fmt"

	logr "github.com/go-logr/logr"
	tpapi "github.com/threeport/threeport/pkg/api/v0"
	tpclient "github.com/threeport/threeport/pkg/client/v0"
	controller "github.com/threeport/threeport/pkg/controller/v0"
	util "github.com/threeport/threeport/pkg/util/v0"

	v0 "wordpress-threeport-extension/pkg/api/v0"
	client "wordpress-threeport-extension/pkg/client/v0"
)
```

### Add `internal/wordpress/wordpress_manifest.go`

The updates we've made so far reference some functions that don't exist yet.
These functions define the Kubernetes configurations for the WordPress workloads
and set the variables needed for different install options.

Add a new file `internal/wordpress/wordpress_manifest.go` with the following
contents.

```go
package wordpress

import (
	"errors"
	"fmt"

	tpapi "github.com/threeport/threeport/pkg/api/v0"
	kube "github.com/threeport/threeport/pkg/kube/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	"gorm.io/datatypes"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// wordpressYaml returns a YAML manifest for the wordpress workload.
func wordpressYaml(
	definitionName string,
	wordpressReplicas int,
	environment string,
	managedDatabase bool,
	dbStorageGb int,
	dbConnectionSecret string,
) (string, error) {
	var yamlDoc string

	if !managedDatabase {
		var unmanagedDbYamlDoc string

		var serviceAccountMariadb = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "v1",
				"kind":       "ServiceAccount",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-mariadb", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "mariadb",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"environment":                  environment,
					},
				},
				"automountServiceAccountToken": false,
			},
		}
		unmanagedDbYamlDoc, err := kube.AppendObjectToYamlDoc(serviceAccountMariadb, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		var secretMariadb = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "v1",
				"kind":       "Secret",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-mariadb", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "mariadb",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"environment":                  environment,
					},
				},
				"type": "Opaque",
				"data": map[string]interface{}{
					"mariadb-root-password": "WHZOWUhMZ3RFUw==",
					"mariadb-password":      "VHlycG1KVDVPTg==",
				},
			},
		}
		unmanagedDbYamlDoc, err = kube.AppendObjectToYamlDoc(secretMariadb, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		var configMapMariadb = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "v1",
				"kind":       "ConfigMap",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-mariadb", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "mariadb",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"app.kubernetes.io/component":  "primary",
						"environment":                  environment,
					},
				},
				"data": map[string]interface{}{
					"my.cnf": `[mysqld]
skip-name-resolve
explicit_defaults_for_timestamp
basedir=/opt/bitnami/mariadb
plugin_dir=/opt/bitnami/mariadb/plugin
port=3306
socket=/opt/bitnami/mariadb/tmp/mysql.sock
tmpdir=/opt/bitnami/mariadb/tmp
max_allowed_packet=16M
bind-address=*
pid-file=/opt/bitnami/mariadb/tmp/mysqld.pid
log-error=/opt/bitnami/mariadb/logs/mysqld.log
character-set-server=UTF8
collation-server=utf8_general_ci
slow_query_log=0
slow_query_log_file=/opt/bitnami/mariadb/logs/mysqld.log
long_query_time=10.0

[client]
port=3306
socket=/opt/bitnami/mariadb/tmp/mysql.sock
default-character-set=UTF8
plugin_dir=/opt/bitnami/mariadb/plugin

[manager]
port=3306
socket=/opt/bitnami/mariadb/tmp/mysql.sock
pid-file=/opt/bitnami/mariadb/tmp/mysqld.pid`,
				},
			},
		}
		unmanagedDbYamlDoc, err = kube.AppendObjectToYamlDoc(configMapMariadb, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		var serviceMariadb = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "v1",
				"kind":       "Service",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-mariadb", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "mariadb",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"app.kubernetes.io/component":  "primary",
						"environment":                  environment,
					},
					"annotations": nil,
				},
				"spec": map[string]interface{}{
					"type":            "ClusterIP",
					"sessionAffinity": "None",
					"ports": []interface{}{
						map[string]interface{}{
							"name":       "mysql",
							"port":       3306,
							"protocol":   "TCP",
							"targetPort": "mysql",
							"nodePort":   nil,
						},
					},
					"selector": map[string]interface{}{
						"app.kubernetes.io/name":      "mariadb",
						"app.kubernetes.io/instance":  definitionName,
						"app.kubernetes.io/component": "primary",
					},
				},
			},
		}
		unmanagedDbYamlDoc, err = kube.AppendObjectToYamlDoc(serviceMariadb, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		var statefulSetMariadb = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "apps/v1",
				"kind":       "StatefulSet",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-mariadb", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "mariadb",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"app.kubernetes.io/component":  "primary",
						"environment":                  environment,
					},
				},
				"spec": map[string]interface{}{
					"replicas":             1,
					"revisionHistoryLimit": 10,
					"selector": map[string]interface{}{
						"matchLabels": map[string]interface{}{
							"app.kubernetes.io/name":      "mariadb",
							"app.kubernetes.io/instance":  definitionName,
							"app.kubernetes.io/component": "primary",
						},
					},
					"serviceName": fmt.Sprintf("%s-mariadb", definitionName),
					"updateStrategy": map[string]interface{}{
						"type": "RollingUpdate",
					},
					"template": map[string]interface{}{
						"metadata": map[string]interface{}{
							"annotations": map[string]interface{}{
								"checksum/configuration": "abe9c954f29a801817e9c9bae83f5353a24b42f21603fd18da496edd12991d82",
							},
							"labels": map[string]interface{}{
								"app.kubernetes.io/name":       "mariadb",
								"app.kubernetes.io/instance":   definitionName,
								"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
								"app.kubernetes.io/component":  "primary",
								"environment":                  environment,
							},
						},
						"spec": map[string]interface{}{
							"serviceAccountName": fmt.Sprintf("%s-mariadb", definitionName),
							"affinity": map[string]interface{}{
								"podAffinity": nil,
								"podAntiAffinity": map[string]interface{}{
									"preferredDuringSchedulingIgnoredDuringExecution": []interface{}{
										map[string]interface{}{
											"podAffinityTerm": map[string]interface{}{
												"labelSelector": map[string]interface{}{
													"matchLabels": map[string]interface{}{
														"app.kubernetes.io/name":      "mariadb",
														"app.kubernetes.io/instance":  definitionName,
														"app.kubernetes.io/component": "primary",
													},
												},
												"topologyKey": "kubernetes.io/hostname",
											},
											"weight": 1,
										},
									},
								},
								"nodeAffinity": nil,
							},
							"securityContext": map[string]interface{}{
								"fsGroup": 1001,
							},
							"containers": []interface{}{
								map[string]interface{}{
									"name":            "mariadb",
									"image":           "docker.io/bitnami/mariadb:10.11.3-debian-11-r0",
									"imagePullPolicy": "IfNotPresent",
									"securityContext": map[string]interface{}{
										"allowPrivilegeEscalation": false,
										"privileged":               false,
										"runAsNonRoot":             true,
										"runAsUser":                1001,
									},
									"env": []interface{}{
										map[string]interface{}{
											"name":  "BITNAMI_DEBUG",
											"value": "false",
										},
										map[string]interface{}{
											"name": "MARIADB_ROOT_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": fmt.Sprintf("%s-mariadb", definitionName),
													"key":  "mariadb-root-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "MARIADB_USER",
											"value": "bn_wordpress",
										},
										map[string]interface{}{
											"name": "MARIADB_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": fmt.Sprintf("%s-mariadb", definitionName),
													"key":  "mariadb-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "MARIADB_DATABASE",
											"value": "bitnami_wordpress",
										},
									},
									"ports": []interface{}{
										map[string]interface{}{
											"name":          "mysql",
											"containerPort": 3306,
										},
									},
									"livenessProbe": map[string]interface{}{
										"failureThreshold":    3,
										"initialDelaySeconds": 120,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      1,
										"exec": map[string]interface{}{
											"command": []interface{}{
												"/bin/bash",
												"-ec",
												`password_aux="${MARIADB_ROOT_PASSWORD:-}"
if [[ -f "${MARIADB_ROOT_PASSWORD_FILE:-}" ]]; then
	password_aux=$(cat "$MARIADB_ROOT_PASSWORD_FILE")
fi
mysqladmin status -uroot -p"${password_aux}"
`,
											},
										},
									},
									"readinessProbe": map[string]interface{}{
										"failureThreshold":    3,
										"initialDelaySeconds": 30,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      1,
										"exec": map[string]interface{}{
											"command": []interface{}{
												"/bin/bash",
												"-ec",
												`password_aux="${MARIADB_ROOT_PASSWORD:-}"
if [[ -f "${MARIADB_ROOT_PASSWORD_FILE:-}" ]]; then
	password_aux=$(cat "$MARIADB_ROOT_PASSWORD_FILE")
fi
mysqladmin status -uroot -p"${password_aux}"
`,
											},
										},
									},
									"resources": map[string]interface{}{
										"limits":   map[string]interface{}{},
										"requests": map[string]interface{}{},
									},
									"volumeMounts": []interface{}{
										map[string]interface{}{
											"name":      "data",
											"mountPath": "/bitnami/mariadb",
										},
										map[string]interface{}{
											"name":      "config",
											"mountPath": "/opt/bitnami/mariadb/conf/my.cnf",
											"subPath":   "my.cnf",
										},
									},
								},
							},
							"volumes": []interface{}{
								map[string]interface{}{
									"name": "config",
									"configMap": map[string]interface{}{
										"name": fmt.Sprintf("%s-mariadb", definitionName),
									},
								},
							},
						},
					},
					"volumeClaimTemplates": []interface{}{
						map[string]interface{}{
							"metadata": map[string]interface{}{
								"name": "data",
								"labels": map[string]interface{}{
									"app.kubernetes.io/name":      "mariadb",
									"app.kubernetes.io/instance":  definitionName,
									"app.kubernetes.io/component": "primary",
									"environment":                 environment,
								},
							},
							"spec": map[string]interface{}{
								"accessModes": []interface{}{
									"ReadWriteOnce",
								},
								"resources": map[string]interface{}{
									"requests": map[string]interface{}{
										"storage": fmt.Sprintf("%dGi", dbStorageGb),
									},
								},
							},
						},
					},
				},
			},
		}
		unmanagedDbYamlDoc, err = kube.AppendObjectToYamlDoc(statefulSetMariadb, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		var deploymentWordpress = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "apps/v1",
				"kind":       "Deployment",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-wordpress", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "wordpress",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"environment":                  environment,
					},
				},
				"spec": map[string]interface{}{
					"selector": map[string]interface{}{
						"matchLabels": map[string]interface{}{
							"app.kubernetes.io/name":     "wordpress",
							"app.kubernetes.io/instance": definitionName,
						},
					},
					"strategy": map[string]interface{}{
						"type": "RollingUpdate",
					},
					"replicas": wordpressReplicas,
					"template": map[string]interface{}{
						"metadata": map[string]interface{}{
							"labels": map[string]interface{}{
								"app.kubernetes.io/name":       "wordpress",
								"app.kubernetes.io/instance":   definitionName,
								"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
								"environment":                  environment,
							},
						},
						"spec": map[string]interface{}{
							// yamllint disable rule:indentation
							"hostAliases": []interface{}{
								map[string]interface{}{
									"hostnames": []interface{}{
										"status.localhost",
									},
									"ip": "127.0.0.1",
								},
							},
							// yamllint enable rule:indentation
							"affinity": map[string]interface{}{
								"podAffinity": nil,
								"podAntiAffinity": map[string]interface{}{
									"preferredDuringSchedulingIgnoredDuringExecution": []interface{}{
										map[string]interface{}{
											"podAffinityTerm": map[string]interface{}{
												"labelSelector": map[string]interface{}{
													"matchLabels": map[string]interface{}{
														"app.kubernetes.io/name":     "wordpress",
														"app.kubernetes.io/instance": definitionName,
													},
												},
												"topologyKey": "kubernetes.io/hostname",
											},
											"weight": 1,
										},
									},
								},
								"nodeAffinity": nil,
							},
							"securityContext": map[string]interface{}{
								"fsGroup": 1001,
								"seccompProfile": map[string]interface{}{
									"type": "RuntimeDefault",
								},
							},
							"serviceAccountName": "default",
							"containers": []interface{}{
								map[string]interface{}{
									"name":            "wordpress",
									"image":           "docker.io/bitnami/wordpress:6.2.0-debian-11-r22",
									"imagePullPolicy": "IfNotPresent",
									"securityContext": map[string]interface{}{
										"allowPrivilegeEscalation": false,
										"capabilities": map[string]interface{}{
											"drop": []interface{}{
												"ALL",
											},
										},
										"runAsNonRoot": true,
										"runAsUser":    1001,
									},
									"env": []interface{}{
										map[string]interface{}{
											"name":  "BITNAMI_DEBUG",
											"value": "false",
										},
										map[string]interface{}{
											"name":  "ALLOW_EMPTY_PASSWORD",
											"value": "yes",
										},
										map[string]interface{}{
											"name":  "MARIADB_HOST",
											"value": fmt.Sprintf("%s-mariadb", definitionName),
										},
										map[string]interface{}{
											"name":  "MARIADB_PORT_NUMBER",
											"value": "3306",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_DATABASE_NAME",
											"value": "bitnami_wordpress",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_DATABASE_USER",
											"value": "bn_wordpress",
										},
										map[string]interface{}{
											"name": "WORDPRESS_DATABASE_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": fmt.Sprintf("%s-mariadb", definitionName),
													"key":  "mariadb-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "WORDPRESS_USERNAME",
											"value": "user",
										},
										map[string]interface{}{
											"name": "WORDPRESS_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": fmt.Sprintf("%s-wordpress", definitionName),
													"key":  "wordpress-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "WORDPRESS_EMAIL",
											"value": "user@example.com",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_FIRST_NAME",
											"value": "FirstName",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_LAST_NAME",
											"value": "LastName",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_HTACCESS_OVERRIDE_NONE",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_ENABLE_HTACCESS_PERSISTENCE",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_BLOG_NAME",
											"value": "User's Blog!",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_SKIP_BOOTSTRAP",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_TABLE_PREFIX",
											"value": "wp_",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_SCHEME",
											"value": "http",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_EXTRA_WP_CONFIG_CONTENT",
											"value": "",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_PLUGINS",
											"value": "none",
										},
										map[string]interface{}{
											"name":  "APACHE_HTTP_PORT_NUMBER",
											"value": "8080",
										},
										map[string]interface{}{
											"name":  "APACHE_HTTPS_PORT_NUMBER",
											"value": "8443",
										},
									},
									"envFrom": nil,
									"ports": []interface{}{
										map[string]interface{}{
											"name":          "http",
											"containerPort": 8080,
										},
										map[string]interface{}{
											"name":          "https",
											"containerPort": 8443,
										},
									},
									"livenessProbe": map[string]interface{}{
										"failureThreshold": 6,
										"httpGet": map[string]interface{}{
											"httpHeaders": []interface{}{},
											"path":        "/wp-admin/install.php",
											"port":        "http",
											"scheme":      "HTTP",
										},
										"initialDelaySeconds": 120,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      5,
									},
									"readinessProbe": map[string]interface{}{
										"failureThreshold": 6,
										"httpGet": map[string]interface{}{
											"httpHeaders": []interface{}{},
											"path":        "/wp-login.php",
											"port":        "http",
											"scheme":      "HTTP",
										},
										"initialDelaySeconds": 30,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      5,
									},
									"resources": map[string]interface{}{
										"limits": map[string]interface{}{},
										"requests": map[string]interface{}{
											"cpu":    "300m",
											"memory": "512Mi",
										},
									},
									"volumeMounts": []interface{}{
										map[string]interface{}{
											"mountPath": "/bitnami/wordpress",
											"name":      "wordpress-data",
											"subPath":   "wordpress",
										},
									},
								},
							},
							"volumes": []interface{}{
								map[string]interface{}{
									"name": "wordpress-data",
									"persistentVolumeClaim": map[string]interface{}{
										"claimName": fmt.Sprintf("%s-wordpress", definitionName),
									},
								},
							},
						},
					},
				},
			},
		}
		unmanagedDbYamlDoc, err = kube.AppendObjectToYamlDoc(deploymentWordpress, unmanagedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		yamlDoc = unmanagedDbYamlDoc
	} else {
		var managedDbYamlDoc string

		var deploymentWordpress = &unstructured.Unstructured{
			Object: map[string]interface{}{
				"apiVersion": "apps/v1",
				"kind":       "Deployment",
				"metadata": map[string]interface{}{
					"name":      fmt.Sprintf("%s-wordpress", definitionName),
					"namespace": "default",
					"labels": map[string]interface{}{
						"app.kubernetes.io/name":       "wordpress",
						"app.kubernetes.io/instance":   definitionName,
						"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
						"environment":                  environment,
					},
				},
				"spec": map[string]interface{}{
					"selector": map[string]interface{}{
						"matchLabels": map[string]interface{}{
							"app.kubernetes.io/name":     "wordpress",
							"app.kubernetes.io/instance": definitionName,
						},
					},
					"strategy": map[string]interface{}{
						"type": "RollingUpdate",
					},
					"replicas": wordpressReplicas,
					"template": map[string]interface{}{
						"metadata": map[string]interface{}{
							"labels": map[string]interface{}{
								"app.kubernetes.io/name":       "wordpress",
								"app.kubernetes.io/instance":   definitionName,
								"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
								"environment":                  environment,
							},
						},
						"spec": map[string]interface{}{
							// yamllint disable rule:indentation
							"hostAliases": []interface{}{
								map[string]interface{}{
									"hostnames": []interface{}{
										"status.localhost",
									},
									"ip": "127.0.0.1",
								},
							},
							// yamllint enable rule:indentation
							"affinity": map[string]interface{}{
								"podAffinity": nil,
								"podAntiAffinity": map[string]interface{}{
									"preferredDuringSchedulingIgnoredDuringExecution": []interface{}{
										map[string]interface{}{
											"podAffinityTerm": map[string]interface{}{
												"labelSelector": map[string]interface{}{
													"matchLabels": map[string]interface{}{
														"app.kubernetes.io/name":     "wordpress",
														"app.kubernetes.io/instance": definitionName,
													},
												},
												"topologyKey": "kubernetes.io/hostname",
											},
											"weight": 1,
										},
									},
								},
								"nodeAffinity": nil,
							},
							"securityContext": map[string]interface{}{
								"fsGroup": 1001,
								"seccompProfile": map[string]interface{}{
									"type": "RuntimeDefault",
								},
							},
							"serviceAccountName": "default",
							"containers": []interface{}{
								map[string]interface{}{
									"name":            "wordpress",
									"image":           "docker.io/bitnami/wordpress:6.2.0-debian-11-r22",
									"imagePullPolicy": "IfNotPresent",
									"securityContext": map[string]interface{}{
										"allowPrivilegeEscalation": false,
										"capabilities": map[string]interface{}{
											"drop": []interface{}{
												"ALL",
											},
										},
										"runAsNonRoot": true,
										"runAsUser":    1001,
									},
									"env": []interface{}{
										map[string]interface{}{
											"name":  "BITNAMI_DEBUG",
											"value": "false",
										},
										map[string]interface{}{
											"name":  "ALLOW_EMPTY_PASSWORD",
											"value": "yes",
										},
										map[string]interface{}{
											"name": "MARIADB_HOST",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": dbConnectionSecret,
													"key":  "db-endpoint",
												},
											},
										},
										map[string]interface{}{
											"name": "MARIADB_PORT_NUMBER",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": dbConnectionSecret,
													"key":  "db-port",
												},
											},
										},
										map[string]interface{}{
											"name": "WORDPRESS_DATABASE_NAME",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": dbConnectionSecret,
													"key":  "db-name",
												},
											},
										},
										map[string]interface{}{
											"name": "WORDPRESS_DATABASE_USER",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": dbConnectionSecret,
													"key":  "db-user",
												},
											},
										},
										map[string]interface{}{
											"name": "WORDPRESS_DATABASE_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": dbConnectionSecret,
													"key":  "db-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "WORDPRESS_USERNAME",
											"value": "user",
										},
										map[string]interface{}{
											"name": "WORDPRESS_PASSWORD",
											"valueFrom": map[string]interface{}{
												"secretKeyRef": map[string]interface{}{
													"name": fmt.Sprintf("%s-wordpress", definitionName),
													"key":  "wordpress-password",
												},
											},
										},
										map[string]interface{}{
											"name":  "WORDPRESS_EMAIL",
											"value": "user@example.com",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_FIRST_NAME",
											"value": "FirstName",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_LAST_NAME",
											"value": "LastName",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_HTACCESS_OVERRIDE_NONE",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_ENABLE_HTACCESS_PERSISTENCE",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_BLOG_NAME",
											"value": "User's Blog!",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_SKIP_BOOTSTRAP",
											"value": "no",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_TABLE_PREFIX",
											"value": "wp_",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_SCHEME",
											"value": "http",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_EXTRA_WP_CONFIG_CONTENT",
											"value": "",
										},
										map[string]interface{}{
											"name":  "WORDPRESS_PLUGINS",
											"value": "none",
										},
										map[string]interface{}{
											"name":  "APACHE_HTTP_PORT_NUMBER",
											"value": "8080",
										},
										map[string]interface{}{
											"name":  "APACHE_HTTPS_PORT_NUMBER",
											"value": "8443",
										},
									},
									"envFrom": nil,
									"ports": []interface{}{
										map[string]interface{}{
											"name":          "http",
											"containerPort": 8080,
										},
										map[string]interface{}{
											"name":          "https",
											"containerPort": 8443,
										},
									},
									"livenessProbe": map[string]interface{}{
										"failureThreshold": 6,
										"httpGet": map[string]interface{}{
											"httpHeaders": []interface{}{},
											"path":        "/wp-admin/install.php",
											"port":        "http",
											"scheme":      "HTTP",
										},
										"initialDelaySeconds": 120,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      5,
									},
									"readinessProbe": map[string]interface{}{
										"failureThreshold": 6,
										"httpGet": map[string]interface{}{
											"httpHeaders": []interface{}{},
											"path":        "/wp-login.php",
											"port":        "http",
											"scheme":      "HTTP",
										},
										"initialDelaySeconds": 30,
										"periodSeconds":       10,
										"successThreshold":    1,
										"timeoutSeconds":      5,
									},
									"resources": map[string]interface{}{
										"limits": map[string]interface{}{},
										"requests": map[string]interface{}{
											"cpu":    "300m",
											"memory": "512Mi",
										},
									},
									"volumeMounts": []interface{}{
										map[string]interface{}{
											"mountPath": "/bitnami/wordpress",
											"name":      "wordpress-data",
											"subPath":   "wordpress",
										},
									},
								},
							},
							"volumes": []interface{}{
								map[string]interface{}{
									"name": "wordpress-data",
									"persistentVolumeClaim": map[string]interface{}{
										"claimName": fmt.Sprintf("%s-wordpress", definitionName),
									},
								},
							},
						},
					},
				},
			},
		}
		managedDbYamlDoc, err := kube.AppendObjectToYamlDoc(deploymentWordpress, managedDbYamlDoc)
		if err != nil {
			return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
		}

		yamlDoc = managedDbYamlDoc
	}

	var secretWordpress = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "v1",
			"kind":       "Secret",
			"metadata": map[string]interface{}{
				"name":      fmt.Sprintf("%s-wordpress", definitionName),
				"namespace": "default",
				"labels": map[string]interface{}{
					"app.kubernetes.io/name":       "wordpress",
					"app.kubernetes.io/instance":   definitionName,
					"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
					"environment":                  environment,
				},
			},
			"type": "Opaque",
			"data": map[string]interface{}{
				"wordpress-password": "VkR5MUJhSno5Uw==",
			},
		},
	}
	yamlDoc, err := kube.AppendObjectToYamlDoc(secretWordpress, yamlDoc)
	if err != nil {
		return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
	}

	var serviceWordpress = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "v1",
			"kind":       "Service",
			"metadata": map[string]interface{}{
				"name":      getWordpressServiceName(definitionName),
				"namespace": "default",
				"labels": map[string]interface{}{
					"app.kubernetes.io/name":       "wordpress",
					"app.kubernetes.io/instance":   definitionName,
					"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
					"environment":                  environment,
				},
			},
			"spec": map[string]interface{}{
				"type":            "ClusterIP",
				"sessionAffinity": "None",
				"ports": []interface{}{
					map[string]interface{}{
						"name":       "http",
						"port":       80,
						"protocol":   "TCP",
						"targetPort": "http",
					},
					map[string]interface{}{
						"name":       "https",
						"port":       443,
						"protocol":   "TCP",
						"targetPort": "https",
					},
				},
				"selector": map[string]interface{}{
					"app.kubernetes.io/name":     "wordpress",
					"app.kubernetes.io/instance": definitionName,
				},
			},
		},
	}
	yamlDoc, err = kube.AppendObjectToYamlDoc(serviceWordpress, yamlDoc)
	if err != nil {
		return yamlDoc, fmt.Errorf("failed to append object to YAML manifest: %w", err)
	}

	return yamlDoc, nil
}

// getWordpressServiceName returns the WordPress deployment's service name.
func getWordpressServiceName(definitionName string) string {
	return fmt.Sprintf("%s-wordpress", definitionName)
}

// getPvcManifest returns the JSON for the persistent volume claim with the
// storage class name set for the infra provider.
func getPvcManifest(
	infraProvider string,
	definitionName string,
	environment string,
) (*datatypes.JSON, error) {
	var storageClassName string
	switch infraProvider {
	case tpapi.KubernetesRuntimeInfraProviderKind:
		storageClassName = "standard"
	case tpapi.KubernetesRuntimeInfraProviderEKS:
		storageClassName = "gp2"
	default:
		return nil, errors.New("unrecognized infra provider")
	}

	var persistentVolumeClaimWordpress = &unstructured.Unstructured{
		Object: map[string]interface{}{
			"kind":       "PersistentVolumeClaim",
			"apiVersion": "v1",
			"metadata": map[string]interface{}{
				"name":      fmt.Sprintf("%s-wordpress", definitionName),
				"namespace": "default",
				"labels": map[string]interface{}{
					"app.kubernetes.io/name":       "wordpress",
					"app.kubernetes.io/instance":   definitionName,
					"app.kubernetes.io/managed-by": "wordrpess-threepport-extension",
					"environment":                  environment,
				},
			},
			"spec": map[string]interface{}{
				"storageClassName": storageClassName,
				"accessModes": []interface{}{
					"ReadWriteOnce",
				},
				"resources": map[string]interface{}{
					"requests": map[string]interface{}{
						"storage": "10Gi",
					},
				},
			},
		},
	}

	jsonData, err := util.UnstructuredToDatatypesJson(persistentVolumeClaimWordpress)
	if err != nil {
		return nil, fmt.Errorf("failed to generate JSON for PVC: %w", err)
	}

	return &jsonData, nil
}
```

At this point the create and delete functionality for the WordPress objects has
been implemented.  For now, we will skip the update functionality for now.  That
can be added later.

## Add Config Abstractions

### Updates to `pkg/config/v0/wordpress.go`

The file `pkg/config/v0/wordpress.go` contains scaffolding for config
abstractions that allow a single user command to make multiple API calls on the
user's behalf.  This is an important way to reduce toil on the user of the
system and provide useful user abstractions.

Let's add the source code to provide these config abstractions.

First, we need to update three types.  These types determine the schema for
config interfaces that will be used to manage WordPress objects.

Find the types below in that file and update them to match the code below.

```go
// WordpressValues contains the attributes needed to manage a wordpress
// definition and wordpress instance with a single operation.
type WordpressValues struct {
	Name                      *string                                   `yaml:"Name"`
	Environment               *string                                   `yaml:"Environment"`
	Replicas                  *int                                      `yaml:"Replicas"`
	ManagedDatabase           *bool                                     `yaml:"ManagedDatabase"`
	DomainName                *tpconfig.DomainNameValues                `yaml:"DomainName"`
	SubDomain                 *string                                   `yaml:"SubDomain"`
	KubernetesRuntimeInstance *tpconfig.KubernetesRuntimeInstanceValues `yaml:"KubernetesRuntimeInstance"`
	AwsAccountName            *string                                   `yaml:"AwsAccountName"`
}

...

// WordpressDefinitionValues contains the attributes for the wordpress definition
// config abstraction.
type WordpressDefinitionValues struct {
	Name            *string                    `yaml:"Name"`
	Environment     *string                    `yaml:"Environment"`
	Replicas        *int                       `yaml:"Replicas"`
	ManagedDatabase *bool                      `yaml:"ManagedDatabase"`
	DomainName      *tpconfig.DomainNameValues `yaml:"DomainName"`
	AwsAccountName  *string                    `yaml:"AwsAccount"`
}

...

// WordpressInstanceValues contains the attributes for the wordpress instance
// config abstraction.
type WordpressInstanceValues struct {
	Name                      *string                                   `yaml:"Name"`
	SubDomain                 *string                                   `yaml:"SubDomain"`
	WordpressDefinition       WordpressDefinitionValues                 `yaml:"WordpressDefinition"`
	KubernetesRuntimeInstance *tpconfig.KubernetesRuntimeInstanceValues `yaml:"KubernetesRuntimeInstance"`
}
```

Next, let's update the methods on the `WordpressValues` object to match the code
shown here.

```go
// Create creates a wordpress definition and instance in the Threeport API.
func (w *WordpressValues) Create(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressDefinition, *api_v0.WordpressInstance, error) {
	// get operations
	operations, createdWordpressDefinition, createdWordpressInstance := w.GetOperations(
		apiClient,
		apiEndpoint,
	)

	// execute create operations
	if err := operations.Create(); err != nil {
		return nil, nil, fmt.Errorf(
			"failed to execute create operations for wordpress defined instance with name %s: %w",
			*w.Name,
			err,
		)
	}

	return createdWordpressDefinition, createdWordpressInstance, nil
}

// Delete deletes a wordpress definition and instance from the Threeport API.
func (w *WordpressValues) Delete(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressDefinition, *api_v0.WordpressInstance, error) {
	// get operations
	operations, _, _ := w.GetOperations(
		apiClient,
		apiEndpoint,
	)

	// execute delete operations
	if err := operations.Delete(); err != nil {
		return nil, nil, fmt.Errorf(
			"failed to execute delete operations for wordpress defined instance with name %s: %w",
			*w.Name,
			err,
		)
	}

	return nil, nil, nil
}

// GetOperations returns a slice of operations used to create or delete a
// wordpress defined instance.
func (w *WordpressValues) GetOperations(
	apiClient *http.Client,
	apiEndpoint string,
) (*util.Operations, *api_v0.WordpressDefinition, *api_v0.WordpressInstance) {
	var err error
	var createdWordpressDefinition api_v0.WordpressDefinition
	var createdWordpressInstance api_v0.WordpressInstance

	operations := util.Operations{}

	// add wordpress definition operation
	wordpressDefinitionValues := WordpressDefinitionValues{
		Name:            w.Name,
		Environment:     w.Environment,
		Replicas:        w.Replicas,
		ManagedDatabase: w.ManagedDatabase,
		DomainName:      w.DomainName,
		AwsAccountName:  w.AwsAccountName,
	}
	operations.AppendOperation(util.Operation{
		Create: func() error {
			wordpressDefinition, err := wordpressDefinitionValues.Create(apiClient, apiEndpoint)
			if err != nil {
				return fmt.Errorf("failed to create wordpress definition with name %s: %w", *w.Name, err)
			}
			createdWordpressDefinition = *wordpressDefinition
			return nil
		},
		Delete: func() error {
			_, err = wordpressDefinitionValues.Delete(apiClient, apiEndpoint)
			if err != nil {
				return fmt.Errorf("failed to delete wordpress definition with name %s: %w", *w.Name, err)
			}
			return nil
		},
		Name: "wordpress definition",
	})

	// add wordpress instance operation
	wordpressInstanceValues := WordpressInstanceValues{
		Name:      w.Name,
		SubDomain: w.SubDomain,
		WordpressDefinition: WordpressDefinitionValues{
			Name: w.Name,
		},
		KubernetesRuntimeInstance: w.KubernetesRuntimeInstance,
	}
	operations.AppendOperation(util.Operation{
		Create: func() error {
			wordpressInstance, err := wordpressInstanceValues.Create(apiClient, apiEndpoint)
			if err != nil {
				return fmt.Errorf("failed to create wordpress instance with name %s: %w", *w.Name, err)
			}
			createdWordpressInstance = *wordpressInstance
			return nil
		},
		Delete: func() error {
			_, err = wordpressInstanceValues.Delete(apiClient, apiEndpoint)
			if err != nil {
				return fmt.Errorf("failed to delete wordpress instance with name %s: %w", *w.Name, err)
			}
			return nil
		},
		Name: "wordpress instance",
	})

	return &operations, &createdWordpressDefinition, &createdWordpressInstance
}
```

Now, update the `Create` and `Delete` methods on the `WordpressDefinitionValues`
object as shown below.

```go
// Create creates a wordpress definition in the Threeport API.
func (w *WordpressDefinitionValues) Create(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressDefinition, error) {
	// validate config
	// environment
	if w.Environment != nil {
		validEnvs := []string{"dev", "prod"}
		envValid := false
		for _, env := range validEnvs {
			if *w.Environment == env {
				envValid = true
				break
			}
		}
		if !envValid {
			return nil, fmt.Errorf("invalid Environment - must be one of %s", validEnvs)
		}
	}
	// domain name
	if w.DomainName != nil {
		if w.DomainName.Name == nil {
			return nil, errors.New("must provide a name for the domain name definition to use")
		}
	}

	// construct wordpress definition object
	wordpressDefinition := api_v0.WordpressDefinition{
		Definition: tpapi_v0.Definition{
			Name: w.Name,
		},
	}
	if w.Environment != nil {
		wordpressDefinition.Environment = w.Environment
	}
	if w.Replicas != nil {
		wordpressDefinition.Replicas = w.Replicas
	}
	if w.ManagedDatabase != nil {
		wordpressDefinition.ManagedDatabase = w.ManagedDatabase
	}
	// create wordpress definition
	createdWordpressDefinition, err := client_v0.CreateWordpressDefinition(
		apiClient,
		apiEndpoint,
		&wordpressDefinition,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create wordpress definition in threeport API: %w", err)
	}

	// make domain name definition attachment if defined
	if w.DomainName != nil {
		// look up domain name by name
		domainNameDefinition, err := tpclient.GetDomainNameDefinitionByName(
			apiClient,
			apiEndpoint,
			*w.DomainName.Name,
		)
		if err != nil {
			return nil, fmt.Errorf("domain name definition %s not found: %w", *w.DomainName.Name, err)
		}
		// set attachment of wordpress definition to domain name definition
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			apiClient,
			apiEndpoint,
			tpapi_v0.ObjectTypeDomainNameDefinition,
			domainNameDefinition.ID,
			api_v0.ObjectTypeWordpressDefinition,
			createdWordpressDefinition.ID,
		); err != nil {
			return nil, fmt.Errorf("failed to attach wordpress definition to domain name definition: %w", err)
		}
	}

	// make AWS account attachment if needed
	if w.ManagedDatabase != nil && *w.ManagedDatabase {
		var awsAccountId uint
		if w.AwsAccountName == nil {
			// look for default account
			queryString := "default=true"
			awsAccounts, err := tpclient.GetAwsAccountsByQueryString(
				apiClient,
				apiEndpoint,
				queryString,
			)
			if err != nil {
				return nil, fmt.Errorf("failed to get default AWS account: %w", err)
			}
			if len(*awsAccounts) == 0 {
				return nil, errors.New("no AWS account name provided and no default account found")
			}
			awsAccountId = *(*awsAccounts)[0].ID
		} else {
			// look up AWS account by name
			awsAccount, err := tpclient.GetAwsAccountByName(
				apiClient,
				apiEndpoint,
				*w.AwsAccountName,
			)
			if err != nil {
				return nil, fmt.Errorf("failed to get AWS account by name %s: %w", *w.AwsAccountName, err)
			}
			awsAccountId = *awsAccount.ID
		}
		// set attachment of wordpress definition to AWS account
		if err := tpclient.EnsureAttachedObjectReferenceExists(
			apiClient,
			apiEndpoint,
			tpapi_v0.ObjectTypeAwsAccount,
			&awsAccountId,
			api_v0.ObjectTypeWordpressDefinition,
			createdWordpressDefinition.ID,
		); err != nil {
			return nil, fmt.Errorf("failed to attach wordpress definition to AWS account: %w", err)
		}
	}

	return createdWordpressDefinition, nil
}

// Delete deletes a wordpress definition from the Threeport API.
func (w *WordpressDefinitionValues) Delete(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressDefinition, error) {
	// get wordpress definition by name
	wordpressDefinition, err := client_v0.GetWordpressDefinitionByName(
		apiClient,
		apiEndpoint,
		*w.Name,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to find wordpress definition with name %s: %w", *w.Name, err)
	}

	// delete wordpress definition
	deletedWordpressDefinition, err := client_v0.DeleteWordpressDefinition(
		apiClient,
		apiEndpoint,
		*wordpressDefinition.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to delete wordpress definition from Threeport API: %w", err)
	}

	return deletedWordpressDefinition, nil
}
```

Finally, update the `Create` and `Delete` methods on the `WordpressInstanceValues`
object as shown below.

```go
// Create creates a wordpress instance in the Threeport API.
func (w *WordpressInstanceValues) Create(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressInstance, error) {
	// validate config
	// TODO

	// get kubernetes runtime instance API object
	kubernetesRuntimeInstance, err := tpconfig.SetKubernetesRuntimeInstanceForConfig(
		w.KubernetesRuntimeInstance,
		apiClient,
		apiEndpoint,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to set kubernetes runtime instance: %w", err)
	}

	// get wordpress definition by name
	wordpressDefinition, err := client_v0.GetWordpressDefinitionByName(
		apiClient,
		apiEndpoint,
		*w.WordpressDefinition.Name,
	)
	if err != nil {
		return nil, fmt.Errorf(
			"failed to get wordpress definition by name %s: %w",
			w.WordpressDefinition.Name,
			err,
		)
	}

	// construct wordpress instance object
	wordpressInstance := api_v0.WordpressInstance{
		Instance: tpapi_v0.Instance{
			Name: w.Name,
		},
		WordpressDefinitionID: wordpressDefinition.ID,
	}
	if w.SubDomain != nil {
		wordpressInstance.SubDomain = w.SubDomain
	}

	// create wordpress instance
	createdWordpressInstance, err := client_v0.CreateWordpressInstance(
		apiClient,
		apiEndpoint,
		&wordpressInstance,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create wordpress instance in threeport API: %w", err)
	}

	// create attached object reference to kubernetes runtime instance
	if err := tpclient.EnsureAttachedObjectReferenceExists(
		apiClient,
		apiEndpoint,
		tpapi_v0.ObjectTypeKubernetesRuntimeInstance,
		kubernetesRuntimeInstance.ID,
		api_v0.ObjectTypeWordpressInstance,
		createdWordpressInstance.ID,
	); err != nil {
		return nil, fmt.Errorf("failed to attach wordpress instance to kubernetes runtime instance: %w", err)
	}

	return createdWordpressInstance, nil
}

// Delete deletes a wordpress instance from the Threeport API.
func (w *WordpressInstanceValues) Delete(
	apiClient *http.Client,
	apiEndpoint string,
) (*api_v0.WordpressInstance, error) {
	// get wordpress instance by name
	wordpressInstance, err := client_v0.GetWordpressInstanceByName(
		apiClient,
		apiEndpoint,
		*w.Name,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to find wordpress instance with name %s: %w", *w.Name, err)
	}

	// delete wordpress instance
	deletedWordpressInstance, err := client_v0.DeleteWordpressInstance(
		apiClient,
		apiEndpoint,
		*wordpressInstance.ID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to delete wordpress instance from Threeport API: %w", err)
	}

	// wait for workload instance to be deleted
	util.Retry(60, 1, func() error {
		if _, err := client_v0.GetWordpressInstanceByName(apiClient, apiEndpoint, *w.Name); err == nil {
			return errors.New("workload instance not deleted")
		}
		return nil
	})

	// get kubernetes runtime instance API object
	kubernetesRuntimeInstance, err := tpconfig.SetKubernetesRuntimeInstanceForConfig(
		w.KubernetesRuntimeInstance,
		apiClient,
		apiEndpoint,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to set kubernetes runtime instance: %w", err)
	}

	// remove attached object reference to kubernetes runtime instance
	if err := tpclient.EnsureAttachedObjectReferenceRemoved(
		apiClient,
		apiEndpoint,
		tpapi_v0.ObjectTypeKubernetesRuntimeInstance,
		kubernetesRuntimeInstance.ID,
		api_v0.ObjectTypeWordpressInstance,
		deletedWordpressInstance.ID,
	); err != nil {
		return nil, fmt.Errorf("failed to remove wordpress instance attachment to kubernetes runtime instance: %w", err)
	}

	return deletedWordpressInstance, nil
}
```

Ensure the imports for this `pkg/config/v0/wordpress.go` file match the
following.

```go
import (
	"errors"
	"fmt"
	"net/http"

	tpapi_v0 "github.com/threeport/threeport/pkg/api/v0"
	tpclient "github.com/threeport/threeport/pkg/client/v0"
	tpconfig "github.com/threeport/threeport/pkg/config/v0"
	util "github.com/threeport/threeport/pkg/util/v0"

	api_v0 "wordpress-threeport-extension/pkg/api/v0"
	client_v0 "wordpress-threeport-extension/pkg/client/v0"
)
```

That's it!  We've added 1 file and modified 3 others.  We're ready to build and
deploy the extension to Threeport.

## Build

First, we need to satisfy the project's package dependencies.

```bash
go mod tidy
```

The Threeport SDK provides [mage](https://magefile.org/) targets with convenient
development utilities.  To see all available mage targets, simple run `mage`.

Next, let's build the `tptctl` plugin for the WordPress extension.

```bash
mage build:plugin
```

To install a tptctl plugin, simply copy the plugin binary to the tptctl plugin
directory - by default `~/.threeport/plugins`.  See `tptctl help` for more info
on installing tptctl plugins.

```bash
cp bin/wordpress ~/.threeport/plugins/
```

Check the plugin was successfully installed.

```bash
tptctl wordpress -h
```

> Note:  If you're using a Mac, you may encounter security restrictions that
> prevent your workstation from running the plugin.  If, when you run it, you
> see output similar to this:
> ``` bash
> [1]    40259 killed     tptctl wordpress -h
> ```
> Then run the following command.
> ```bash
> codesign -f -s - bin/wordpress
> ```
> Then repeat the two steps below to install and test the plugin.

You should see the help output for the wordpress plugin similar to that shown below.

```bash
Manage the Wordpress Threeport extension

Usage:
  wordpress [command]

Available Commands:
  completion  Generate the autocompletion script for the specified shell
  create      Create a Threeport Wordpress object
  delete      Delete a Threeport Wordpress object
  describe    Describe a Threeport Wordpress object
  get         Get a Threeport Wordpress object
  help        Help about any command
  install     Install the Wordpress extension to an existing Threeport control plane

Flags:
  -h, --help                      help for wordpress
      --provider-config string    Path to infra provider config directory (default is $HOME/.threeport/).
      --threeport-config string   Path to config file (default is $HOME/.threeport/config.yaml). Can also be set with environment variable THREEPORT_CONFIG
  -t, --toggle                    Help message for toggle

Additional help topics:
  wordpress update     Update a Threeport Wordpress object

Use "wordpress [command] --help" for more information about a command.
```

Next, we need to build the binaries and container images for each containerized
component that will be installed into a Threeport control plane.  After the
images are built, they will be pushed to a container registry to make them
available for installation.

> Note: In this and other following sections, you will have the option to
> test the WordPress extension in a "Local Dev Environment" on your
> workstation, or in a "Remote Environment" running in AWS.
>
> The remote environment option will provide a more realistic use case and will
> allow you to test using AWS RDS as the persistent data store for WordPress,
> but requires an AWS account, will cost money and take a little longer.  This
> tutorial will also require a Route53 hosted zone you can use for DNS.  The
> local dev environment will be faster to spin up and down and cost nothing on
> your cloud bill.  Choose the appropriate tab in each section for the method
> you choose.

=== "Local Dev Environment"

    If you're going to test this locally, first spin up a local container registry
    so we don't have to wait for images to pushed to - and pulled from - a remote
    registry.  This mage target will create run a local docker container to serve as
    the container registry.

    ```bash
    mage dev:localRegistryUp
    ```

    Now we can build and push the container images to the local registry.

    ```bash
    mage build:allImagesDev
    ```

=== "Remote Environment"

    If using a remote AWS environment, build for the release architecture (amd64).
    This step will build the binaries and container images, then push them to your
    registry (as defined in the `sdk-config.yaml` file).  This may take a few
    minutes as three container images will be pushed to your remote container
    registry.  You will need to be logged in to your container registry from your
    command line.

    ```bash
    mage build:allImagesRelease
    ```

## Threeport Control Plane

If you don't aleady have one, install a Threeport control plane for testing.

=== "Local Dev Environment"

    To install Threeport that will pull images from a local registry, use the
    following command.

    ```bash
    tptctl up \
        --name test \
        --provider kind \
        --auth-enabled false \
        --local-registry
    ```

    For more info on installing Threeport locally, see the
    [documentation to Install Threeport
    Locally](../../install/install-threeport-local).

=== "Remote Environment"

    To install Threeport in AWS, use the following command.  Substitute your
    region of choice as needed.

    ```bash
    tptctl up \
        --name test \
        --provider eks \
        --aws-region us-east-2
    ```

    For more info on installing Threeport remotely, see the
    [documentation to Install Threeport on AWS](../../install/install-threeport-aws).

## Install WordPress Extension

=== "Local Dev Environment"

    To install the WordPress extension using the image pushed to the local dev
    registry, use the following command.

    ```bash
    tptctl wordpress install -r localhost:5001
    ```

=== "Remote Environment"

    If installing remotely, run the install as shown here to pull images from
    your default image repo (as declared in your `sdk-config.yaml` file).

    ```
    tptctl wordpress install
    ```

## Use the WordpressExtension

=== "Local Dev Environment"

    For a local install of WordPress use the following config.  The `Environment`
    and `ManagedDatabase` fields are shown with their default values and aren't
    required.  They are only included for the sake of explicitness for this
    tutorial.

    ```yaml
    # wordpress-local.yaml
    Wordpress:
      Name: local
      Environment: dev
      ManagedDatabase: false
    ```

    Install WordPress.

    ```bash
    tptctl wordpress create wordpress -c wordpress-local.yaml
    ```

=== "Remote Environment"

    In order to use a Route53 hosted zone to manage DNS for your WordPress app,
    you will need to register that with Threeport.  Create a domain name
    definition config like this.  Replace the values for the `Domain` and
    `AdminEmail` fields to work for your setup.

    ```yaml
    # domain-name.yaml
	DomainNameDefinition:
	  Name: test-domain
	  Domain: example.com
	  Zone: Public
	  AdminEmail: admin@example.com
    ```

    Now you can register this hosted zone with Threeport.

    ```bash
    tptctl create domain-name-definition -c domain-name.yaml
    ```

    For a remote install, we can use AWS RDS for the database as well as Route53 for
    DNS.

    ```yaml
    # wordpress-remote.yaml
    Wordpress:
      Name: remote
      Environment: dev
      ManagedDatabase: true
      DomainName:
        Name: test-domain
      SubDomain: blog
      KubernetesRuntimeInstance:
        Name: threeport-test
    ```

    Install WordPress.

    ```bash
    tptctl wordpress create wordpress -c wordpress-remote.yaml
    ```

## Verification

After a few minutes, the wordpress instance should be running.  You can view the
app in your browser by following the following steps.

=== "Local Dev Environment"

    > Note: You will need to have
    > [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl) installed on your
    > machine to perform these steps.

    Get the Threeport-managed namespace that was created for the WordPress app.

    ```bash
    WORDPRESS_NAMESPACE=$(kubectl get ns -A -l app.kubernetes.io/name=local -o=jsonpath='{.items[0].metadata.name}')
    ```

    Start a port forward to the WordPress service.

    ```bash
    kubectl port-forward -n $WORDPRESS_NAMESPACE svc/local-wordpress 8080:80
    ```

    Now visit [http://localhost:8080](http://localhost:8080) in your browser.

    When finished, hit Ctrl+C in the terminal where the port forward is running to
    cancel it.

=== "Remote Environment"

    To verify the app is up and running, just type `blog.[your domain]` (using
    the domain you configured in `domain-name.yaml`) into a browser.  By
    default, [Let's Encrypt](https://letsencrypt.org/) is used as the TLS cert
    provider.  Also, by default, the staging environment is used.  This means
    the certificate will be valid but not publicly trusted.  So your browser
    will give you a warning.  You can tell your browser to proceed anyway, and
    you should get the default homepage served to you.

## Clean Up

Follow the instructions to remove the WordPress app and Threeport for either the
Local or Remote environment.

=== "Local Dev Environment"

    Remove the WordPress app by deleting it with tptctl.

    ```bash
    tptctl wordpress delete wordpress -c wordpress-local.yaml
    ```

    Remove the local Threeport control plane.

    ```bash
    tptctl down -n test
    ```

    Remove the local container registry.

    ```bash
    mage dev:localRegistryDown
    ```

=== "Remote Environment"

    Remove the WordPress app by deleting it with tptctl.

    ```bash
    tptctl wordpress delete wordpress -c wordpress-remote.yaml
    ```

    After deleting the WordPress app, wait a few minutes before proceeding.  We
    need to give the system enough time to clean up your Route53 hosted zone
    before removing the support services in the next step.  If you like, you can check
    your Route53 hosted zone in the AWS portal before proceeding.  Otherwise,
    just wait 5 minutes to be safe.

    Next, we need to Remove the support service workloads that were deployed.  By default,
    Threeport will not remove a Kubernetes runtime with workloads deployed.  We
    can view them with this command.

    ```bash
    tptctl get workloads
    ```

    Delete the support service workloads.

    ```bash
    tptctl delete workload-instance -n gloo-edge-threeport-test
    tptctl delete workload-instance -n external-dns-threeport-test
    ```

    Wait another 5 minutes before proceeding to ensure the AWS load balancer
    connected to your ingress layer is removed before deleting the control plane
    altogether in the next step.

    Remove the local Threeport control plane.

    ```bash
    tptctl down -n test
    ```

## Summary

In this tutorial we walked through each and every step to build a sample
extension to the Threeport control plane.  You can apply the same process to
create any extension to Threeport that you like.  Use cases are not limited to
particular workload support.  Other use cases can include:

* Support for alternative infrastructure providers.
* Support for managed services on infrastructure providers.  This is not limited
  to cloud providers.  It could include services like DataDog, Splunk, MongoDB,
  or literally any other software service that has an API.
* Support for alternative runtime environments besides Kubernetes, e.g. VMs or
  function-as-a-service offerings.

