// generated by 'threeport-sdk gen' - do not edit

package v0

import (
	"encoding/json"
	"fmt"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	"time"
)

const (
	ObjectTypeAwsAccount                        string = "AwsAccount"
	ObjectTypeAwsEksKubernetesRuntimeDefinition string = "AwsEksKubernetesRuntimeDefinition"
	ObjectTypeAwsEksKubernetesRuntimeInstance   string = "AwsEksKubernetesRuntimeInstance"
	ObjectTypeAwsObjectStorageBucketDefinition  string = "AwsObjectStorageBucketDefinition"
	ObjectTypeAwsObjectStorageBucketInstance    string = "AwsObjectStorageBucketInstance"
	ObjectTypeAwsRelationalDatabaseDefinition   string = "AwsRelationalDatabaseDefinition"
	ObjectTypeAwsRelationalDatabaseInstance     string = "AwsRelationalDatabaseInstance"

	PathAwsAccounts                        = "/v0/aws-accounts"
	PathAwsEksKubernetesRuntimeDefinitions = "/v0/aws-eks-kubernetes-runtime-definitions"
	PathAwsEksKubernetesRuntimeInstances   = "/v0/aws-eks-kubernetes-runtime-instances"
	PathAwsObjectStorageBucketDefinitions  = "/v0/aws-object-storage-bucket-definitions"
	PathAwsObjectStorageBucketInstances    = "/v0/aws-object-storage-bucket-instances"
	PathAwsRelationalDatabaseDefinitions   = "/v0/aws-relational-database-definitions"
	PathAwsRelationalDatabaseInstances     = "/v0/aws-relational-database-instances"
)

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aa *AwsAccount) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aa,
		ObjectVersion: aa.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aa, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aa *AwsAccount) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aa); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aa *AwsAccount) GetId() uint {
	return *aa.ID
}

// Type returns the object type.
func (aa *AwsAccount) GetType() string {
	return "AwsAccount"
}

// Version returns the version of the API object.
func (aa *AwsAccount) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aekrd *AwsEksKubernetesRuntimeDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aekrd,
		ObjectVersion: aekrd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aekrd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aekrd *AwsEksKubernetesRuntimeDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aekrd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aekrd *AwsEksKubernetesRuntimeDefinition) GetId() uint {
	return *aekrd.ID
}

// Type returns the object type.
func (aekrd *AwsEksKubernetesRuntimeDefinition) GetType() string {
	return "AwsEksKubernetesRuntimeDefinition"
}

// Version returns the version of the API object.
func (aekrd *AwsEksKubernetesRuntimeDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aekri *AwsEksKubernetesRuntimeInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aekri,
		ObjectVersion: aekri.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aekri, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aekri *AwsEksKubernetesRuntimeInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aekri); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aekri *AwsEksKubernetesRuntimeInstance) GetId() uint {
	return *aekri.ID
}

// Type returns the object type.
func (aekri *AwsEksKubernetesRuntimeInstance) GetType() string {
	return "AwsEksKubernetesRuntimeInstance"
}

// Version returns the version of the API object.
func (aekri *AwsEksKubernetesRuntimeInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (aekri *AwsEksKubernetesRuntimeInstance) ScheduledForDeletion() *time.Time {
	return aekri.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aosbd *AwsObjectStorageBucketDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aosbd,
		ObjectVersion: aosbd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aosbd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aosbd *AwsObjectStorageBucketDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aosbd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aosbd *AwsObjectStorageBucketDefinition) GetId() uint {
	return *aosbd.ID
}

// Type returns the object type.
func (aosbd *AwsObjectStorageBucketDefinition) GetType() string {
	return "AwsObjectStorageBucketDefinition"
}

// Version returns the version of the API object.
func (aosbd *AwsObjectStorageBucketDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aosbi *AwsObjectStorageBucketInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aosbi,
		ObjectVersion: aosbi.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aosbi, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aosbi *AwsObjectStorageBucketInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aosbi); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aosbi *AwsObjectStorageBucketInstance) GetId() uint {
	return *aosbi.ID
}

// Type returns the object type.
func (aosbi *AwsObjectStorageBucketInstance) GetType() string {
	return "AwsObjectStorageBucketInstance"
}

// Version returns the version of the API object.
func (aosbi *AwsObjectStorageBucketInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (aosbi *AwsObjectStorageBucketInstance) ScheduledForDeletion() *time.Time {
	return aosbi.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (ardd *AwsRelationalDatabaseDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        ardd,
		ObjectVersion: ardd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", ardd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (ardd *AwsRelationalDatabaseDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &ardd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (ardd *AwsRelationalDatabaseDefinition) GetId() uint {
	return *ardd.ID
}

// Type returns the object type.
func (ardd *AwsRelationalDatabaseDefinition) GetType() string {
	return "AwsRelationalDatabaseDefinition"
}

// Version returns the version of the API object.
func (ardd *AwsRelationalDatabaseDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (ardi *AwsRelationalDatabaseInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        ardi,
		ObjectVersion: ardi.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", ardi, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (ardi *AwsRelationalDatabaseInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &ardi); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (ardi *AwsRelationalDatabaseInstance) GetId() uint {
	return *ardi.ID
}

// Type returns the object type.
func (ardi *AwsRelationalDatabaseInstance) GetType() string {
	return "AwsRelationalDatabaseInstance"
}

// Version returns the version of the API object.
func (ardi *AwsRelationalDatabaseInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (ardi *AwsRelationalDatabaseInstance) ScheduledForDeletion() *time.Time {
	return ardi.DeletionScheduled
}
