// generated by 'threeport-sdk gen' - do not edit

package v0

import (
	"encoding/json"
	"fmt"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	"time"
)

const (
	ObjectTypeDomainNameDefinition string = "DomainNameDefinition"
	ObjectTypeDomainNameInstance   string = "DomainNameInstance"
	ObjectTypeGatewayDefinition    string = "GatewayDefinition"
	ObjectTypeGatewayHttpPort      string = "GatewayHttpPort"
	ObjectTypeGatewayInstance      string = "GatewayInstance"
	ObjectTypeGatewayTcpPort       string = "GatewayTcpPort"

	PathDomainNameDefinitionVersions = "/domain-name-definitions/versions"
	PathDomainNameDefinitions        = "/v0/domain-name-definitions"
	PathDomainNameInstanceVersions   = "/domain-name-instances/versions"
	PathDomainNameInstances          = "/v0/domain-name-instances"
	PathGatewayDefinitionVersions    = "/gateway-definitions/versions"
	PathGatewayDefinitions           = "/v0/gateway-definitions"
	PathGatewayHttpPortVersions      = "/gateway-http-ports/versions"
	PathGatewayHttpPorts             = "/v0/gateway-http-ports"
	PathGatewayInstanceVersions      = "/gateway-instances/versions"
	PathGatewayInstances             = "/v0/gateway-instances"
	PathGatewayTcpPortVersions       = "/gateway-tcp-ports/versions"
	PathGatewayTcpPorts              = "/v0/gateway-tcp-ports"
)

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (dnd *DomainNameDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        dnd,
		ObjectVersion: dnd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", dnd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (dnd *DomainNameDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &dnd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (dnd *DomainNameDefinition) GetId() uint {
	return *dnd.ID
}

// Type returns the object type.
func (dnd *DomainNameDefinition) GetType() string {
	return "DomainNameDefinition"
}

// Version returns the version of the API object.
func (dnd *DomainNameDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (dni *DomainNameInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        dni,
		ObjectVersion: dni.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", dni, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (dni *DomainNameInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &dni); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (dni *DomainNameInstance) GetId() uint {
	return *dni.ID
}

// Type returns the object type.
func (dni *DomainNameInstance) GetType() string {
	return "DomainNameInstance"
}

// Version returns the version of the API object.
func (dni *DomainNameInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (dni *DomainNameInstance) ScheduledForDeletion() *time.Time {
	return dni.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (gd *GatewayDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        gd,
		ObjectVersion: gd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", gd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (gd *GatewayDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &gd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (gd *GatewayDefinition) GetId() uint {
	return *gd.ID
}

// Type returns the object type.
func (gd *GatewayDefinition) GetType() string {
	return "GatewayDefinition"
}

// Version returns the version of the API object.
func (gd *GatewayDefinition) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (gd *GatewayDefinition) ScheduledForDeletion() *time.Time {
	return gd.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (ghp *GatewayHttpPort) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        ghp,
		ObjectVersion: ghp.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", ghp, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (ghp *GatewayHttpPort) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &ghp); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (ghp *GatewayHttpPort) GetId() uint {
	return *ghp.ID
}

// Type returns the object type.
func (ghp *GatewayHttpPort) GetType() string {
	return "GatewayHttpPort"
}

// Version returns the version of the API object.
func (ghp *GatewayHttpPort) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (gi *GatewayInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        gi,
		ObjectVersion: gi.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", gi, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (gi *GatewayInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &gi); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (gi *GatewayInstance) GetId() uint {
	return *gi.ID
}

// Type returns the object type.
func (gi *GatewayInstance) GetType() string {
	return "GatewayInstance"
}

// Version returns the version of the API object.
func (gi *GatewayInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (gi *GatewayInstance) ScheduledForDeletion() *time.Time {
	return gi.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (gtp *GatewayTcpPort) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        gtp,
		ObjectVersion: gtp.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", gtp, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (gtp *GatewayTcpPort) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &gtp); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (gtp *GatewayTcpPort) GetId() uint {
	return *gtp.ID
}

// Type returns the object type.
func (gtp *GatewayTcpPort) GetType() string {
	return "GatewayTcpPort"
}

// Version returns the version of the API object.
func (gtp *GatewayTcpPort) GetVersion() string {
	return "v0"
}
