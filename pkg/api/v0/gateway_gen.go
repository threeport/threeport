// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"encoding/json"
	"fmt"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
)

const (
	ObjectTypeGatewayDefinition    ObjectType = "GatewayDefinition"
	ObjectTypeGatewayInstance      ObjectType = "GatewayInstance"
	ObjectTypeDomainNameDefinition ObjectType = "DomainNameDefinition"
	ObjectTypeDomainNameInstance   ObjectType = "DomainNameInstance"

	GatewayStreamName = "gatewayStream"

	GatewayDefinitionSubject       = "gatewayDefinition.*"
	GatewayDefinitionCreateSubject = "gatewayDefinition.create"
	GatewayDefinitionUpdateSubject = "gatewayDefinition.update"
	GatewayDefinitionDeleteSubject = "gatewayDefinition.delete"

	GatewayInstanceSubject       = "gatewayInstance.*"
	GatewayInstanceCreateSubject = "gatewayInstance.create"
	GatewayInstanceUpdateSubject = "gatewayInstance.update"
	GatewayInstanceDeleteSubject = "gatewayInstance.delete"

	DomainNameDefinitionSubject       = "domainNameDefinition.*"
	DomainNameDefinitionCreateSubject = "domainNameDefinition.create"
	DomainNameDefinitionUpdateSubject = "domainNameDefinition.update"
	DomainNameDefinitionDeleteSubject = "domainNameDefinition.delete"

	DomainNameInstanceSubject       = "domainNameInstance.*"
	DomainNameInstanceCreateSubject = "domainNameInstance.create"
	DomainNameInstanceUpdateSubject = "domainNameInstance.update"
	DomainNameInstanceDeleteSubject = "domainNameInstance.delete"

	PathGatewayDefinitions    = "/v0/gateway-definitions"
	PathGatewayInstances      = "/v0/gateway-instances"
	PathDomainNameDefinitions = "/v0/domain-name-definitions"
	PathDomainNameInstances   = "/v0/domain-name-instances"
)

// GetGatewayDefinitionSubjects returns the NATS subjects
// for gateway definitions.
func GetGatewayDefinitionSubjects() []string {
	return []string{
		GatewayDefinitionCreateSubject,
		GatewayDefinitionUpdateSubject,
		GatewayDefinitionDeleteSubject,
	}
}

// GetGatewayInstanceSubjects returns the NATS subjects
// for gateway instances.
func GetGatewayInstanceSubjects() []string {
	return []string{
		GatewayInstanceCreateSubject,
		GatewayInstanceUpdateSubject,
		GatewayInstanceDeleteSubject,
	}
}

// GetDomainNameDefinitionSubjects returns the NATS subjects
// for domain name definitions.
func GetDomainNameDefinitionSubjects() []string {
	return []string{
		DomainNameDefinitionCreateSubject,
		DomainNameDefinitionUpdateSubject,
		DomainNameDefinitionDeleteSubject,
	}
}

// GetDomainNameInstanceSubjects returns the NATS subjects
// for domain name instances.
func GetDomainNameInstanceSubjects() []string {
	return []string{
		DomainNameInstanceCreateSubject,
		DomainNameInstanceUpdateSubject,
		DomainNameInstanceDeleteSubject,
	}
}

// GetGatewaySubjects returns the NATS subjects
// for all gateway objects.
func GetGatewaySubjects() []string {
	var gatewaySubjects []string

	gatewaySubjects = append(gatewaySubjects, GetGatewayDefinitionSubjects()...)
	gatewaySubjects = append(gatewaySubjects, GetGatewayInstanceSubjects()...)
	gatewaySubjects = append(gatewaySubjects, GetDomainNameDefinitionSubjects()...)
	gatewaySubjects = append(gatewaySubjects, GetDomainNameInstanceSubjects()...)

	return gatewaySubjects
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (gd *GatewayDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime: &creationTime,
		Object:       gd,
		Operation:    operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", gd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (gd *GatewayDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message", err)
	}
	if err := json.Unmarshal(jsonObject, &gd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object", err)
	}
	return nil
}

// GetID returns the unique ID for the object.
func (gd *GatewayDefinition) GetID() uint {
	return *gd.ID
}

// String returns a string representation of the ojbect.
func (gd GatewayDefinition) String() string {
	return fmt.Sprintf("v0.GatewayDefinition")
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (gi *GatewayInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime: &creationTime,
		Object:       gi,
		Operation:    operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", gi, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (gi *GatewayInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message", err)
	}
	if err := json.Unmarshal(jsonObject, &gi); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object", err)
	}
	return nil
}

// GetID returns the unique ID for the object.
func (gi *GatewayInstance) GetID() uint {
	return *gi.ID
}

// String returns a string representation of the ojbect.
func (gi GatewayInstance) String() string {
	return fmt.Sprintf("v0.GatewayInstance")
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (dnd *DomainNameDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	lastDelay int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		LastRequeueDelay: &lastDelay,
		Object:           dnd,
		Operation:        operation,
		Requeue:          requeue,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", dnd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (dnd *DomainNameDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &dnd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetID returns the unique ID for the object.
func (dnd *DomainNameDefinition) GetID() uint {
	return *dnd.ID
}

// String returns a string representation of the ojbect.
func (dnd DomainNameDefinition) String() string {
	return fmt.Sprintf("v0.DomainNameDefinition")
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (dni *DomainNameInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	lastDelay int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		LastRequeueDelay: &lastDelay,
		Object:           dni,
		Operation:        operation,
		Requeue:          requeue,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", dni, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (dni *DomainNameInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &dni); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetID returns the unique ID for the object.
func (dni *DomainNameInstance) GetID() uint {
	return *dni.ID
}

// String returns a string representation of the ojbect.
func (dni DomainNameInstance) String() string {
	return fmt.Sprintf("v0.DomainNameInstance")
}
