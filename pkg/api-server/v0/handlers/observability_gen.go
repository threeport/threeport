// generated by 'threeport-sdk gen' - do not edit

package handlers

import (
	"errors"
	"fmt"
	echo "github.com/labstack/echo/v4"
	notif "github.com/threeport/threeport/internal/observability/notif"
	apiserver_lib "github.com/threeport/threeport/pkg/api-server/lib/v0"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// LoggingDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetLoggingDefinitionVersions gets the supported versions for the logging definition API.
// @Description Get the supported API versions for logging definitions.
// @ID loggingDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /logging-definitions/versions [GET]
func (h Handler) GetLoggingDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeLoggingDefinition)])
}

// @Summary adds a new logging definition.
// @Description Add a new logging definition to the Threeport database.
// @ID add-v0-loggingDefinition
// @Accept json
// @Produce json
// @Param loggingDefinition body api_v0.LoggingDefinition true "LoggingDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions [POST]
func (h Handler) AddLoggingDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	var loggingDefinition api_v0.LoggingDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, loggingDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&loggingDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, loggingDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingLoggingDefinition api_v0.LoggingDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", loggingDefinition.Name).First(&existingLoggingDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&loggingDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*loggingDefinition.Reconciled {
		notifPayload, err := loggingDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingDefinitionCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all logging definitions.
// @Description Get all logging definitions from the Threeport database.
// @ID get-v0-loggingDefinitions
// @Accept json
// @Produce json
// @Param name query string false "logging definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions [GET]
func (h Handler) GetLoggingDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.LoggingDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.LoggingDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.LoggingDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a logging definition.
// @Description Get a particular logging definition from the database.
// @ID get-v0-loggingDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions/{id} [GET]
func (h Handler) GetLoggingDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	loggingDefinitionID := c.Param("id")
	var loggingDefinition api_v0.LoggingDefinition
	if result := h.DB.First(&loggingDefinition, loggingDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing logging definition.
// @Description Update a logging definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating logging definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-loggingDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param loggingDefinition body api_v0.LoggingDefinition true "LoggingDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions/{id} [PATCH]
func (h Handler) UpdateLoggingDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	loggingDefinitionID := c.Param("id")
	var existingLoggingDefinition api_v0.LoggingDefinition
	if result := h.DB.First(&existingLoggingDefinition, loggingDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingLoggingDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedLoggingDefinition api_v0.LoggingDefinition
	if err := c.Bind(&updatedLoggingDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingLoggingDefinition).Updates(updatedLoggingDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingLoggingDefinition.Reconciled {
		notifPayload, err := existingLoggingDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingDefinitionUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingLoggingDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing logging definition by replacing the entire object.
// @Description Replace a logging definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating logging definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-loggingDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param loggingDefinition body api_v0.LoggingDefinition true "LoggingDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions/{id} [PUT]
func (h Handler) ReplaceLoggingDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	loggingDefinitionID := c.Param("id")
	var existingLoggingDefinition api_v0.LoggingDefinition
	if result := h.DB.First(&existingLoggingDefinition, loggingDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingLoggingDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedLoggingDefinition api_v0.LoggingDefinition
	if err := c.Bind(&updatedLoggingDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedLoggingDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedLoggingDefinition.ID = existingLoggingDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedLoggingDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingLoggingDefinition, loggingDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingLoggingDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a logging definition.
// @Description Delete a logging definition by ID from the database.
// @ID delete-v0-loggingDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-definitions/{id} [DELETE]
func (h Handler) DeleteLoggingDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingDefinition
	loggingDefinitionID := c.Param("id")
	var loggingDefinition api_v0.LoggingDefinition
	if result := h.DB.Preload("LoggingInstances").First(&loggingDefinition, loggingDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(loggingDefinition.LoggingInstances) != 0 {
		err := errors.New("logging definition has related logging instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if loggingDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledLoggingDefinition := api_v0.LoggingDefinition{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&loggingDefinition).Updates(scheduledLoggingDefinition); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := loggingDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingDefinitionDeleteSubject, *notifPayload)
	} else {
		if loggingDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*loggingDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&loggingDefinition); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// LoggingInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetLoggingInstanceVersions gets the supported versions for the logging instance API.
// @Description Get the supported API versions for logging instances.
// @ID loggingInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /logging-instances/versions [GET]
func (h Handler) GetLoggingInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeLoggingInstance)])
}

// @Summary adds a new logging instance.
// @Description Add a new logging instance to the Threeport database.
// @ID add-v0-loggingInstance
// @Accept json
// @Produce json
// @Param loggingInstance body api_v0.LoggingInstance true "LoggingInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances [POST]
func (h Handler) AddLoggingInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	var loggingInstance api_v0.LoggingInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, loggingInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&loggingInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, loggingInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingLoggingInstance api_v0.LoggingInstance
	nameUsed := true
	result := h.DB.Where("name = ?", loggingInstance.Name).First(&existingLoggingInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&loggingInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*loggingInstance.Reconciled {
		notifPayload, err := loggingInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all logging instances.
// @Description Get all logging instances from the Threeport database.
// @ID get-v0-loggingInstances
// @Accept json
// @Produce json
// @Param name query string false "logging instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances [GET]
func (h Handler) GetLoggingInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.LoggingInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.LoggingInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.LoggingInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a logging instance.
// @Description Get a particular logging instance from the database.
// @ID get-v0-loggingInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances/{id} [GET]
func (h Handler) GetLoggingInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	loggingInstanceID := c.Param("id")
	var loggingInstance api_v0.LoggingInstance
	if result := h.DB.First(&loggingInstance, loggingInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing logging instance.
// @Description Update a logging instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating logging instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-loggingInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param loggingInstance body api_v0.LoggingInstance true "LoggingInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances/{id} [PATCH]
func (h Handler) UpdateLoggingInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	loggingInstanceID := c.Param("id")
	var existingLoggingInstance api_v0.LoggingInstance
	if result := h.DB.First(&existingLoggingInstance, loggingInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingLoggingInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedLoggingInstance api_v0.LoggingInstance
	if err := c.Bind(&updatedLoggingInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingLoggingInstance).Updates(updatedLoggingInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingLoggingInstance.Reconciled {
		notifPayload, err := existingLoggingInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingLoggingInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing logging instance by replacing the entire object.
// @Description Replace a logging instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating logging instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-loggingInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param loggingInstance body api_v0.LoggingInstance true "LoggingInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances/{id} [PUT]
func (h Handler) ReplaceLoggingInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	loggingInstanceID := c.Param("id")
	var existingLoggingInstance api_v0.LoggingInstance
	if result := h.DB.First(&existingLoggingInstance, loggingInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingLoggingInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedLoggingInstance api_v0.LoggingInstance
	if err := c.Bind(&updatedLoggingInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedLoggingInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedLoggingInstance.ID = existingLoggingInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedLoggingInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingLoggingInstance, loggingInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingLoggingInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a logging instance.
// @Description Delete a logging instance by ID from the database.
// @ID delete-v0-loggingInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/logging-instances/{id} [DELETE]
func (h Handler) DeleteLoggingInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeLoggingInstance
	loggingInstanceID := c.Param("id")
	var loggingInstance api_v0.LoggingInstance
	if result := h.DB.First(&loggingInstance, loggingInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if loggingInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledLoggingInstance := api_v0.LoggingInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&loggingInstance).Updates(scheduledLoggingInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := loggingInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.LoggingInstanceDeleteSubject, *notifPayload)
	} else {
		if loggingInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*loggingInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&loggingInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, loggingInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// MetricsDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetMetricsDefinitionVersions gets the supported versions for the metrics definition API.
// @Description Get the supported API versions for metrics definitions.
// @ID metricsDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /metrics-definitions/versions [GET]
func (h Handler) GetMetricsDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeMetricsDefinition)])
}

// @Summary adds a new metrics definition.
// @Description Add a new metrics definition to the Threeport database.
// @ID add-v0-metricsDefinition
// @Accept json
// @Produce json
// @Param metricsDefinition body api_v0.MetricsDefinition true "MetricsDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions [POST]
func (h Handler) AddMetricsDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	var metricsDefinition api_v0.MetricsDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, metricsDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&metricsDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, metricsDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingMetricsDefinition api_v0.MetricsDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", metricsDefinition.Name).First(&existingMetricsDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&metricsDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*metricsDefinition.Reconciled {
		notifPayload, err := metricsDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsDefinitionCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all metrics definitions.
// @Description Get all metrics definitions from the Threeport database.
// @ID get-v0-metricsDefinitions
// @Accept json
// @Produce json
// @Param name query string false "metrics definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions [GET]
func (h Handler) GetMetricsDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.MetricsDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.MetricsDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.MetricsDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a metrics definition.
// @Description Get a particular metrics definition from the database.
// @ID get-v0-metricsDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions/{id} [GET]
func (h Handler) GetMetricsDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	metricsDefinitionID := c.Param("id")
	var metricsDefinition api_v0.MetricsDefinition
	if result := h.DB.First(&metricsDefinition, metricsDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing metrics definition.
// @Description Update a metrics definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating metrics definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-metricsDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param metricsDefinition body api_v0.MetricsDefinition true "MetricsDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions/{id} [PATCH]
func (h Handler) UpdateMetricsDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	metricsDefinitionID := c.Param("id")
	var existingMetricsDefinition api_v0.MetricsDefinition
	if result := h.DB.First(&existingMetricsDefinition, metricsDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingMetricsDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedMetricsDefinition api_v0.MetricsDefinition
	if err := c.Bind(&updatedMetricsDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingMetricsDefinition).Updates(updatedMetricsDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingMetricsDefinition.Reconciled {
		notifPayload, err := existingMetricsDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsDefinitionUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingMetricsDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing metrics definition by replacing the entire object.
// @Description Replace a metrics definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating metrics definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-metricsDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param metricsDefinition body api_v0.MetricsDefinition true "MetricsDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions/{id} [PUT]
func (h Handler) ReplaceMetricsDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	metricsDefinitionID := c.Param("id")
	var existingMetricsDefinition api_v0.MetricsDefinition
	if result := h.DB.First(&existingMetricsDefinition, metricsDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingMetricsDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedMetricsDefinition api_v0.MetricsDefinition
	if err := c.Bind(&updatedMetricsDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedMetricsDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedMetricsDefinition.ID = existingMetricsDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedMetricsDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingMetricsDefinition, metricsDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingMetricsDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a metrics definition.
// @Description Delete a metrics definition by ID from the database.
// @ID delete-v0-metricsDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-definitions/{id} [DELETE]
func (h Handler) DeleteMetricsDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsDefinition
	metricsDefinitionID := c.Param("id")
	var metricsDefinition api_v0.MetricsDefinition
	if result := h.DB.Preload("MetricsInstances").First(&metricsDefinition, metricsDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(metricsDefinition.MetricsInstances) != 0 {
		err := errors.New("metrics definition has related metrics instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if metricsDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledMetricsDefinition := api_v0.MetricsDefinition{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&metricsDefinition).Updates(scheduledMetricsDefinition); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := metricsDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsDefinitionDeleteSubject, *notifPayload)
	} else {
		if metricsDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*metricsDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&metricsDefinition); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// MetricsInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetMetricsInstanceVersions gets the supported versions for the metrics instance API.
// @Description Get the supported API versions for metrics instances.
// @ID metricsInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /metrics-instances/versions [GET]
func (h Handler) GetMetricsInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeMetricsInstance)])
}

// @Summary adds a new metrics instance.
// @Description Add a new metrics instance to the Threeport database.
// @ID add-v0-metricsInstance
// @Accept json
// @Produce json
// @Param metricsInstance body api_v0.MetricsInstance true "MetricsInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances [POST]
func (h Handler) AddMetricsInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	var metricsInstance api_v0.MetricsInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, metricsInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&metricsInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, metricsInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingMetricsInstance api_v0.MetricsInstance
	nameUsed := true
	result := h.DB.Where("name = ?", metricsInstance.Name).First(&existingMetricsInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&metricsInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*metricsInstance.Reconciled {
		notifPayload, err := metricsInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all metrics instances.
// @Description Get all metrics instances from the Threeport database.
// @ID get-v0-metricsInstances
// @Accept json
// @Produce json
// @Param name query string false "metrics instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances [GET]
func (h Handler) GetMetricsInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.MetricsInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.MetricsInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.MetricsInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a metrics instance.
// @Description Get a particular metrics instance from the database.
// @ID get-v0-metricsInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances/{id} [GET]
func (h Handler) GetMetricsInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	metricsInstanceID := c.Param("id")
	var metricsInstance api_v0.MetricsInstance
	if result := h.DB.First(&metricsInstance, metricsInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing metrics instance.
// @Description Update a metrics instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating metrics instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-metricsInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param metricsInstance body api_v0.MetricsInstance true "MetricsInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances/{id} [PATCH]
func (h Handler) UpdateMetricsInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	metricsInstanceID := c.Param("id")
	var existingMetricsInstance api_v0.MetricsInstance
	if result := h.DB.First(&existingMetricsInstance, metricsInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingMetricsInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedMetricsInstance api_v0.MetricsInstance
	if err := c.Bind(&updatedMetricsInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingMetricsInstance).Updates(updatedMetricsInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingMetricsInstance.Reconciled {
		notifPayload, err := existingMetricsInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingMetricsInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing metrics instance by replacing the entire object.
// @Description Replace a metrics instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating metrics instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-metricsInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param metricsInstance body api_v0.MetricsInstance true "MetricsInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances/{id} [PUT]
func (h Handler) ReplaceMetricsInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	metricsInstanceID := c.Param("id")
	var existingMetricsInstance api_v0.MetricsInstance
	if result := h.DB.First(&existingMetricsInstance, metricsInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingMetricsInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedMetricsInstance api_v0.MetricsInstance
	if err := c.Bind(&updatedMetricsInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedMetricsInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedMetricsInstance.ID = existingMetricsInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedMetricsInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingMetricsInstance, metricsInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingMetricsInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a metrics instance.
// @Description Delete a metrics instance by ID from the database.
// @ID delete-v0-metricsInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/metrics-instances/{id} [DELETE]
func (h Handler) DeleteMetricsInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeMetricsInstance
	metricsInstanceID := c.Param("id")
	var metricsInstance api_v0.MetricsInstance
	if result := h.DB.First(&metricsInstance, metricsInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if metricsInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledMetricsInstance := api_v0.MetricsInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&metricsInstance).Updates(scheduledMetricsInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := metricsInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.MetricsInstanceDeleteSubject, *notifPayload)
	} else {
		if metricsInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*metricsInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&metricsInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, metricsInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// ObservabilityDashboardDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetObservabilityDashboardDefinitionVersions gets the supported versions for the observability dashboard definition API.
// @Description Get the supported API versions for observability dashboard definitions.
// @ID observabilityDashboardDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /observability-dashboard-definitions/versions [GET]
func (h Handler) GetObservabilityDashboardDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeObservabilityDashboardDefinition)])
}

// @Summary adds a new observability dashboard definition.
// @Description Add a new observability dashboard definition to the Threeport database.
// @ID add-v0-observabilityDashboardDefinition
// @Accept json
// @Produce json
// @Param observabilityDashboardDefinition body api_v0.ObservabilityDashboardDefinition true "ObservabilityDashboardDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions [POST]
func (h Handler) AddObservabilityDashboardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	var observabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, observabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&observabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, observabilityDashboardDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingObservabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", observabilityDashboardDefinition.Name).First(&existingObservabilityDashboardDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&observabilityDashboardDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*observabilityDashboardDefinition.Reconciled {
		notifPayload, err := observabilityDashboardDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardDefinitionCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all observability dashboard definitions.
// @Description Get all observability dashboard definitions from the Threeport database.
// @ID get-v0-observabilityDashboardDefinitions
// @Accept json
// @Produce json
// @Param name query string false "observability dashboard definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions [GET]
func (h Handler) GetObservabilityDashboardDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.ObservabilityDashboardDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.ObservabilityDashboardDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.ObservabilityDashboardDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a observability dashboard definition.
// @Description Get a particular observability dashboard definition from the database.
// @ID get-v0-observabilityDashboardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions/{id} [GET]
func (h Handler) GetObservabilityDashboardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	observabilityDashboardDefinitionID := c.Param("id")
	var observabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if result := h.DB.First(&observabilityDashboardDefinition, observabilityDashboardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing observability dashboard definition.
// @Description Update a observability dashboard definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating observability dashboard definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-observabilityDashboardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityDashboardDefinition body api_v0.ObservabilityDashboardDefinition true "ObservabilityDashboardDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions/{id} [PATCH]
func (h Handler) UpdateObservabilityDashboardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	observabilityDashboardDefinitionID := c.Param("id")
	var existingObservabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if result := h.DB.First(&existingObservabilityDashboardDefinition, observabilityDashboardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if err := c.Bind(&updatedObservabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingObservabilityDashboardDefinition).Updates(updatedObservabilityDashboardDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingObservabilityDashboardDefinition.Reconciled {
		notifPayload, err := existingObservabilityDashboardDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardDefinitionUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityDashboardDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing observability dashboard definition by replacing the entire object.
// @Description Replace a observability dashboard definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating observability dashboard definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-observabilityDashboardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityDashboardDefinition body api_v0.ObservabilityDashboardDefinition true "ObservabilityDashboardDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions/{id} [PUT]
func (h Handler) ReplaceObservabilityDashboardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	observabilityDashboardDefinitionID := c.Param("id")
	var existingObservabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if result := h.DB.First(&existingObservabilityDashboardDefinition, observabilityDashboardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if err := c.Bind(&updatedObservabilityDashboardDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedObservabilityDashboardDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedObservabilityDashboardDefinition.ID = existingObservabilityDashboardDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedObservabilityDashboardDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingObservabilityDashboardDefinition, observabilityDashboardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityDashboardDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a observability dashboard definition.
// @Description Delete a observability dashboard definition by ID from the database.
// @ID delete-v0-observabilityDashboardDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-definitions/{id} [DELETE]
func (h Handler) DeleteObservabilityDashboardDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardDefinition
	observabilityDashboardDefinitionID := c.Param("id")
	var observabilityDashboardDefinition api_v0.ObservabilityDashboardDefinition
	if result := h.DB.Preload("ObservabilityDashboardInstances").First(&observabilityDashboardDefinition, observabilityDashboardDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(observabilityDashboardDefinition.ObservabilityDashboardInstances) != 0 {
		err := errors.New("observability dashboard definition has related observability dashboard instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if observabilityDashboardDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledObservabilityDashboardDefinition := api_v0.ObservabilityDashboardDefinition{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&observabilityDashboardDefinition).Updates(scheduledObservabilityDashboardDefinition); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := observabilityDashboardDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardDefinitionDeleteSubject, *notifPayload)
	} else {
		if observabilityDashboardDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*observabilityDashboardDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&observabilityDashboardDefinition); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// ObservabilityDashboardInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetObservabilityDashboardInstanceVersions gets the supported versions for the observability dashboard instance API.
// @Description Get the supported API versions for observability dashboard instances.
// @ID observabilityDashboardInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /observability-dashboard-instances/versions [GET]
func (h Handler) GetObservabilityDashboardInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeObservabilityDashboardInstance)])
}

// @Summary adds a new observability dashboard instance.
// @Description Add a new observability dashboard instance to the Threeport database.
// @ID add-v0-observabilityDashboardInstance
// @Accept json
// @Produce json
// @Param observabilityDashboardInstance body api_v0.ObservabilityDashboardInstance true "ObservabilityDashboardInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances [POST]
func (h Handler) AddObservabilityDashboardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	var observabilityDashboardInstance api_v0.ObservabilityDashboardInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, observabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&observabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, observabilityDashboardInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingObservabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	nameUsed := true
	result := h.DB.Where("name = ?", observabilityDashboardInstance.Name).First(&existingObservabilityDashboardInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&observabilityDashboardInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*observabilityDashboardInstance.Reconciled {
		notifPayload, err := observabilityDashboardInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all observability dashboard instances.
// @Description Get all observability dashboard instances from the Threeport database.
// @ID get-v0-observabilityDashboardInstances
// @Accept json
// @Produce json
// @Param name query string false "observability dashboard instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances [GET]
func (h Handler) GetObservabilityDashboardInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.ObservabilityDashboardInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.ObservabilityDashboardInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.ObservabilityDashboardInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a observability dashboard instance.
// @Description Get a particular observability dashboard instance from the database.
// @ID get-v0-observabilityDashboardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances/{id} [GET]
func (h Handler) GetObservabilityDashboardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	observabilityDashboardInstanceID := c.Param("id")
	var observabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if result := h.DB.First(&observabilityDashboardInstance, observabilityDashboardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing observability dashboard instance.
// @Description Update a observability dashboard instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating observability dashboard instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-observabilityDashboardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityDashboardInstance body api_v0.ObservabilityDashboardInstance true "ObservabilityDashboardInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances/{id} [PATCH]
func (h Handler) UpdateObservabilityDashboardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	observabilityDashboardInstanceID := c.Param("id")
	var existingObservabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if result := h.DB.First(&existingObservabilityDashboardInstance, observabilityDashboardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if err := c.Bind(&updatedObservabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingObservabilityDashboardInstance).Updates(updatedObservabilityDashboardInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingObservabilityDashboardInstance.Reconciled {
		notifPayload, err := existingObservabilityDashboardInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityDashboardInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing observability dashboard instance by replacing the entire object.
// @Description Replace a observability dashboard instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating observability dashboard instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-observabilityDashboardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityDashboardInstance body api_v0.ObservabilityDashboardInstance true "ObservabilityDashboardInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances/{id} [PUT]
func (h Handler) ReplaceObservabilityDashboardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	observabilityDashboardInstanceID := c.Param("id")
	var existingObservabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if result := h.DB.First(&existingObservabilityDashboardInstance, observabilityDashboardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if err := c.Bind(&updatedObservabilityDashboardInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedObservabilityDashboardInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedObservabilityDashboardInstance.ID = existingObservabilityDashboardInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedObservabilityDashboardInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingObservabilityDashboardInstance, observabilityDashboardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityDashboardInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a observability dashboard instance.
// @Description Delete a observability dashboard instance by ID from the database.
// @ID delete-v0-observabilityDashboardInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-dashboard-instances/{id} [DELETE]
func (h Handler) DeleteObservabilityDashboardInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityDashboardInstance
	observabilityDashboardInstanceID := c.Param("id")
	var observabilityDashboardInstance api_v0.ObservabilityDashboardInstance
	if result := h.DB.First(&observabilityDashboardInstance, observabilityDashboardInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if observabilityDashboardInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledObservabilityDashboardInstance := api_v0.ObservabilityDashboardInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&observabilityDashboardInstance).Updates(scheduledObservabilityDashboardInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := observabilityDashboardInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityDashboardInstanceDeleteSubject, *notifPayload)
	} else {
		if observabilityDashboardInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*observabilityDashboardInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&observabilityDashboardInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityDashboardInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// ObservabilityStackDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetObservabilityStackDefinitionVersions gets the supported versions for the observability stack definition API.
// @Description Get the supported API versions for observability stack definitions.
// @ID observabilityStackDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /observability-stack-definitions/versions [GET]
func (h Handler) GetObservabilityStackDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeObservabilityStackDefinition)])
}

// @Summary adds a new observability stack definition.
// @Description Add a new observability stack definition to the Threeport database.
// @ID add-v0-observabilityStackDefinition
// @Accept json
// @Produce json
// @Param observabilityStackDefinition body api_v0.ObservabilityStackDefinition true "ObservabilityStackDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions [POST]
func (h Handler) AddObservabilityStackDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	var observabilityStackDefinition api_v0.ObservabilityStackDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, observabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&observabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, observabilityStackDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingObservabilityStackDefinition api_v0.ObservabilityStackDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", observabilityStackDefinition.Name).First(&existingObservabilityStackDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&observabilityStackDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*observabilityStackDefinition.Reconciled {
		notifPayload, err := observabilityStackDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackDefinitionCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all observability stack definitions.
// @Description Get all observability stack definitions from the Threeport database.
// @ID get-v0-observabilityStackDefinitions
// @Accept json
// @Produce json
// @Param name query string false "observability stack definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions [GET]
func (h Handler) GetObservabilityStackDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.ObservabilityStackDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.ObservabilityStackDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.ObservabilityStackDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a observability stack definition.
// @Description Get a particular observability stack definition from the database.
// @ID get-v0-observabilityStackDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions/{id} [GET]
func (h Handler) GetObservabilityStackDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	observabilityStackDefinitionID := c.Param("id")
	var observabilityStackDefinition api_v0.ObservabilityStackDefinition
	if result := h.DB.First(&observabilityStackDefinition, observabilityStackDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing observability stack definition.
// @Description Update a observability stack definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating observability stack definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-observabilityStackDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityStackDefinition body api_v0.ObservabilityStackDefinition true "ObservabilityStackDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions/{id} [PATCH]
func (h Handler) UpdateObservabilityStackDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	observabilityStackDefinitionID := c.Param("id")
	var existingObservabilityStackDefinition api_v0.ObservabilityStackDefinition
	if result := h.DB.First(&existingObservabilityStackDefinition, observabilityStackDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityStackDefinition api_v0.ObservabilityStackDefinition
	if err := c.Bind(&updatedObservabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingObservabilityStackDefinition).Updates(updatedObservabilityStackDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingObservabilityStackDefinition.Reconciled {
		notifPayload, err := existingObservabilityStackDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackDefinitionUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityStackDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing observability stack definition by replacing the entire object.
// @Description Replace a observability stack definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating observability stack definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-observabilityStackDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityStackDefinition body api_v0.ObservabilityStackDefinition true "ObservabilityStackDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions/{id} [PUT]
func (h Handler) ReplaceObservabilityStackDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	observabilityStackDefinitionID := c.Param("id")
	var existingObservabilityStackDefinition api_v0.ObservabilityStackDefinition
	if result := h.DB.First(&existingObservabilityStackDefinition, observabilityStackDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityStackDefinition api_v0.ObservabilityStackDefinition
	if err := c.Bind(&updatedObservabilityStackDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedObservabilityStackDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedObservabilityStackDefinition.ID = existingObservabilityStackDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedObservabilityStackDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingObservabilityStackDefinition, observabilityStackDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityStackDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a observability stack definition.
// @Description Delete a observability stack definition by ID from the database.
// @ID delete-v0-observabilityStackDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-definitions/{id} [DELETE]
func (h Handler) DeleteObservabilityStackDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackDefinition
	observabilityStackDefinitionID := c.Param("id")
	var observabilityStackDefinition api_v0.ObservabilityStackDefinition
	if result := h.DB.Preload("ObservabilityStackInstances").First(&observabilityStackDefinition, observabilityStackDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(observabilityStackDefinition.ObservabilityStackInstances) != 0 {
		err := errors.New("observability stack definition has related observability stack instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if observabilityStackDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledObservabilityStackDefinition := api_v0.ObservabilityStackDefinition{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&observabilityStackDefinition).Updates(scheduledObservabilityStackDefinition); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := observabilityStackDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackDefinitionDeleteSubject, *notifPayload)
	} else {
		if observabilityStackDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*observabilityStackDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&observabilityStackDefinition); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// ObservabilityStackInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetObservabilityStackInstanceVersions gets the supported versions for the observability stack instance API.
// @Description Get the supported API versions for observability stack instances.
// @ID observabilityStackInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /observability-stack-instances/versions [GET]
func (h Handler) GetObservabilityStackInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeObservabilityStackInstance)])
}

// @Summary adds a new observability stack instance.
// @Description Add a new observability stack instance to the Threeport database.
// @ID add-v0-observabilityStackInstance
// @Accept json
// @Produce json
// @Param observabilityStackInstance body api_v0.ObservabilityStackInstance true "ObservabilityStackInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances [POST]
func (h Handler) AddObservabilityStackInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	var observabilityStackInstance api_v0.ObservabilityStackInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, observabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&observabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, observabilityStackInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingObservabilityStackInstance api_v0.ObservabilityStackInstance
	nameUsed := true
	result := h.DB.Where("name = ?", observabilityStackInstance.Name).First(&existingObservabilityStackInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&observabilityStackInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*observabilityStackInstance.Reconciled {
		notifPayload, err := observabilityStackInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all observability stack instances.
// @Description Get all observability stack instances from the Threeport database.
// @ID get-v0-observabilityStackInstances
// @Accept json
// @Produce json
// @Param name query string false "observability stack instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances [GET]
func (h Handler) GetObservabilityStackInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.ObservabilityStackInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.ObservabilityStackInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.ObservabilityStackInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a observability stack instance.
// @Description Get a particular observability stack instance from the database.
// @ID get-v0-observabilityStackInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances/{id} [GET]
func (h Handler) GetObservabilityStackInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	observabilityStackInstanceID := c.Param("id")
	var observabilityStackInstance api_v0.ObservabilityStackInstance
	if result := h.DB.First(&observabilityStackInstance, observabilityStackInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing observability stack instance.
// @Description Update a observability stack instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating observability stack instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-observabilityStackInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityStackInstance body api_v0.ObservabilityStackInstance true "ObservabilityStackInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances/{id} [PATCH]
func (h Handler) UpdateObservabilityStackInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	observabilityStackInstanceID := c.Param("id")
	var existingObservabilityStackInstance api_v0.ObservabilityStackInstance
	if result := h.DB.First(&existingObservabilityStackInstance, observabilityStackInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityStackInstance api_v0.ObservabilityStackInstance
	if err := c.Bind(&updatedObservabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingObservabilityStackInstance).Updates(updatedObservabilityStackInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingObservabilityStackInstance.Reconciled {
		notifPayload, err := existingObservabilityStackInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityStackInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing observability stack instance by replacing the entire object.
// @Description Replace a observability stack instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating observability stack instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-observabilityStackInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param observabilityStackInstance body api_v0.ObservabilityStackInstance true "ObservabilityStackInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances/{id} [PUT]
func (h Handler) ReplaceObservabilityStackInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	observabilityStackInstanceID := c.Param("id")
	var existingObservabilityStackInstance api_v0.ObservabilityStackInstance
	if result := h.DB.First(&existingObservabilityStackInstance, observabilityStackInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingObservabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedObservabilityStackInstance api_v0.ObservabilityStackInstance
	if err := c.Bind(&updatedObservabilityStackInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedObservabilityStackInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedObservabilityStackInstance.ID = existingObservabilityStackInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedObservabilityStackInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingObservabilityStackInstance, observabilityStackInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingObservabilityStackInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a observability stack instance.
// @Description Delete a observability stack instance by ID from the database.
// @ID delete-v0-observabilityStackInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/observability-stack-instances/{id} [DELETE]
func (h Handler) DeleteObservabilityStackInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeObservabilityStackInstance
	observabilityStackInstanceID := c.Param("id")
	var observabilityStackInstance api_v0.ObservabilityStackInstance
	if result := h.DB.First(&observabilityStackInstance, observabilityStackInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if observabilityStackInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledObservabilityStackInstance := api_v0.ObservabilityStackInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&observabilityStackInstance).Updates(scheduledObservabilityStackInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := observabilityStackInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.ObservabilityStackInstanceDeleteSubject, *notifPayload)
	} else {
		if observabilityStackInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*observabilityStackInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&observabilityStackInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, observabilityStackInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}
