// generated by 'threeport-sdk gen' - do not edit

package handlers

import (
	"errors"
	"fmt"
	echo "github.com/labstack/echo/v4"
	notif "github.com/threeport/threeport/internal/aws/notif"
	apiserver_lib "github.com/threeport/threeport/pkg/api-server/lib/v0"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// AwsAccount
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsAccountVersions gets the supported versions for the aws account API.
// @Description Get the supported API versions for aws accounts.
// @ID awsAccount-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-accounts/versions [GET]
func (h Handler) GetAwsAccountVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsAccount)])
}

// @Summary adds a new aws account.
// @Description Add a new aws account to the Threeport database.
// @ID add-v0-awsAccount
// @Accept json
// @Produce json
// @Param awsAccount body api_v0.AwsAccount true "AwsAccount object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts [POST]
func (h Handler) AddAwsAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	var awsAccount api_v0.AwsAccount

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsAccount, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsAccount api_v0.AwsAccount
	nameUsed := true
	result := h.DB.Where("name = ?", awsAccount.Name).First(&existingAwsAccount)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws accounts.
// @Description Get all aws accounts from the Threeport database.
// @ID get-v0-awsAccounts
// @Accept json
// @Produce json
// @Param name query string false "aws account search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts [GET]
func (h Handler) GetAwsAccounts(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsAccount
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsAccount{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsAccount{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws account.
// @Description Get a particular aws account from the database.
// @ID get-v0-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [GET]
func (h Handler) GetAwsAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var awsAccount api_v0.AwsAccount
	if result := h.DB.First(&awsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws account.
// @Description Update a aws account in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsAccount body api_v0.AwsAccount true "AwsAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [PATCH]
func (h Handler) UpdateAwsAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var existingAwsAccount api_v0.AwsAccount
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsAccount api_v0.AwsAccount
	if err := c.Bind(&updatedAwsAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsAccount).Updates(updatedAwsAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws account by replacing the entire object.
// @Description Replace a aws account in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsAccount body api_v0.AwsAccount true "AwsAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [PUT]
func (h Handler) ReplaceAwsAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var existingAwsAccount api_v0.AwsAccount
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsAccount api_v0.AwsAccount
	if err := c.Bind(&updatedAwsAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsAccount, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsAccount.ID = existingAwsAccount.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws account.
// @Description Delete a aws account by ID from the database.
// @ID delete-v0-awsAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-accounts/{id} [DELETE]
func (h Handler) DeleteAwsAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsAccount
	awsAccountID := c.Param("id")
	var awsAccount api_v0.AwsAccount
	if result := h.DB.First(&awsAccount, awsAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// delete object
	if result := h.DB.Delete(&awsAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsEksKubernetesRuntimeDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsEksKubernetesRuntimeDefinitionVersions gets the supported versions for the aws eks kubernetes runtime definition API.
// @Description Get the supported API versions for aws eks kubernetes runtime definitions.
// @ID awsEksKubernetesRuntimeDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-eks-kubernetes-runtime-definitions/versions [GET]
func (h Handler) GetAwsEksKubernetesRuntimeDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition)])
}

// @Summary adds a new aws eks kubernetes runtime definition.
// @Description Add a new aws eks kubernetes runtime definition to the Threeport database.
// @ID add-v0-awsEksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param awsEksKubernetesRuntimeDefinition body api_v0.AwsEksKubernetesRuntimeDefinition true "AwsEksKubernetesRuntimeDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions [POST]
func (h Handler) AddAwsEksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	var awsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsEksKubernetesRuntimeDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", awsEksKubernetesRuntimeDefinition.Name).First(&existingAwsEksKubernetesRuntimeDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsEksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws eks kubernetes runtime definitions.
// @Description Get all aws eks kubernetes runtime definitions from the Threeport database.
// @ID get-v0-awsEksKubernetesRuntimeDefinitions
// @Accept json
// @Produce json
// @Param name query string false "aws eks kubernetes runtime definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions [GET]
func (h Handler) GetAwsEksKubernetesRuntimeDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsEksKubernetesRuntimeDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsEksKubernetesRuntimeDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsEksKubernetesRuntimeDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws eks kubernetes runtime definition.
// @Description Get a particular aws eks kubernetes runtime definition from the database.
// @ID get-v0-awsEksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions/{id} [GET]
func (h Handler) GetAwsEksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	awsEksKubernetesRuntimeDefinitionID := c.Param("id")
	var awsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if result := h.DB.First(&awsEksKubernetesRuntimeDefinition, awsEksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws eks kubernetes runtime definition.
// @Description Update a aws eks kubernetes runtime definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws eks kubernetes runtime definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsEksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksKubernetesRuntimeDefinition body api_v0.AwsEksKubernetesRuntimeDefinition true "AwsEksKubernetesRuntimeDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions/{id} [PATCH]
func (h Handler) UpdateAwsEksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	awsEksKubernetesRuntimeDefinitionID := c.Param("id")
	var existingAwsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeDefinition, awsEksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if err := c.Bind(&updatedAwsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsEksKubernetesRuntimeDefinition).Updates(updatedAwsEksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsEksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws eks kubernetes runtime definition by replacing the entire object.
// @Description Replace a aws eks kubernetes runtime definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws eks kubernetes runtime definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsEksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksKubernetesRuntimeDefinition body api_v0.AwsEksKubernetesRuntimeDefinition true "AwsEksKubernetesRuntimeDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions/{id} [PUT]
func (h Handler) ReplaceAwsEksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	awsEksKubernetesRuntimeDefinitionID := c.Param("id")
	var existingAwsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeDefinition, awsEksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if err := c.Bind(&updatedAwsEksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsEksKubernetesRuntimeDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsEksKubernetesRuntimeDefinition.ID = existingAwsEksKubernetesRuntimeDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsEksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeDefinition, awsEksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsEksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws eks kubernetes runtime definition.
// @Description Delete a aws eks kubernetes runtime definition by ID from the database.
// @ID delete-v0-awsEksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-definitions/{id} [DELETE]
func (h Handler) DeleteAwsEksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeDefinition
	awsEksKubernetesRuntimeDefinitionID := c.Param("id")
	var awsEksKubernetesRuntimeDefinition api_v0.AwsEksKubernetesRuntimeDefinition
	if result := h.DB.Preload("AwsEksKubernetesRuntimeInstances").First(&awsEksKubernetesRuntimeDefinition, awsEksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(awsEksKubernetesRuntimeDefinition.AwsEksKubernetesRuntimeInstances) != 0 {
		err := errors.New("aws eks kubernetes runtime definition has related aws eks kubernetes runtime instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// delete object
	if result := h.DB.Delete(&awsEksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsEksKubernetesRuntimeInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsEksKubernetesRuntimeInstanceVersions gets the supported versions for the aws eks kubernetes runtime instance API.
// @Description Get the supported API versions for aws eks kubernetes runtime instances.
// @ID awsEksKubernetesRuntimeInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-eks-kubernetes-runtime-instances/versions [GET]
func (h Handler) GetAwsEksKubernetesRuntimeInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance)])
}

// @Summary adds a new aws eks kubernetes runtime instance.
// @Description Add a new aws eks kubernetes runtime instance to the Threeport database.
// @ID add-v0-awsEksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param awsEksKubernetesRuntimeInstance body api_v0.AwsEksKubernetesRuntimeInstance true "AwsEksKubernetesRuntimeInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances [POST]
func (h Handler) AddAwsEksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	var awsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsEksKubernetesRuntimeInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	nameUsed := true
	result := h.DB.Where("name = ?", awsEksKubernetesRuntimeInstance.Name).First(&existingAwsEksKubernetesRuntimeInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsEksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*awsEksKubernetesRuntimeInstance.Reconciled {
		notifPayload, err := awsEksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsEksKubernetesRuntimeInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws eks kubernetes runtime instances.
// @Description Get all aws eks kubernetes runtime instances from the Threeport database.
// @ID get-v0-awsEksKubernetesRuntimeInstances
// @Accept json
// @Produce json
// @Param name query string false "aws eks kubernetes runtime instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances [GET]
func (h Handler) GetAwsEksKubernetesRuntimeInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsEksKubernetesRuntimeInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsEksKubernetesRuntimeInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsEksKubernetesRuntimeInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws eks kubernetes runtime instance.
// @Description Get a particular aws eks kubernetes runtime instance from the database.
// @ID get-v0-awsEksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances/{id} [GET]
func (h Handler) GetAwsEksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	awsEksKubernetesRuntimeInstanceID := c.Param("id")
	var awsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if result := h.DB.First(&awsEksKubernetesRuntimeInstance, awsEksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws eks kubernetes runtime instance.
// @Description Update a aws eks kubernetes runtime instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws eks kubernetes runtime instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsEksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksKubernetesRuntimeInstance body api_v0.AwsEksKubernetesRuntimeInstance true "AwsEksKubernetesRuntimeInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances/{id} [PATCH]
func (h Handler) UpdateAwsEksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	awsEksKubernetesRuntimeInstanceID := c.Param("id")
	var existingAwsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeInstance, awsEksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if err := c.Bind(&updatedAwsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsEksKubernetesRuntimeInstance).Updates(updatedAwsEksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingAwsEksKubernetesRuntimeInstance.Reconciled {
		notifPayload, err := existingAwsEksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsEksKubernetesRuntimeInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsEksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws eks kubernetes runtime instance by replacing the entire object.
// @Description Replace a aws eks kubernetes runtime instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws eks kubernetes runtime instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsEksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsEksKubernetesRuntimeInstance body api_v0.AwsEksKubernetesRuntimeInstance true "AwsEksKubernetesRuntimeInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances/{id} [PUT]
func (h Handler) ReplaceAwsEksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	awsEksKubernetesRuntimeInstanceID := c.Param("id")
	var existingAwsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeInstance, awsEksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if err := c.Bind(&updatedAwsEksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsEksKubernetesRuntimeInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsEksKubernetesRuntimeInstance.ID = existingAwsEksKubernetesRuntimeInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsEksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsEksKubernetesRuntimeInstance, awsEksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsEksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws eks kubernetes runtime instance.
// @Description Delete a aws eks kubernetes runtime instance by ID from the database.
// @ID delete-v0-awsEksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-eks-kubernetes-runtime-instances/{id} [DELETE]
func (h Handler) DeleteAwsEksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsEksKubernetesRuntimeInstance
	awsEksKubernetesRuntimeInstanceID := c.Param("id")
	var awsEksKubernetesRuntimeInstance api_v0.AwsEksKubernetesRuntimeInstance
	if result := h.DB.First(&awsEksKubernetesRuntimeInstance, awsEksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if awsEksKubernetesRuntimeInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledAwsEksKubernetesRuntimeInstance := api_v0.AwsEksKubernetesRuntimeInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&awsEksKubernetesRuntimeInstance).Updates(scheduledAwsEksKubernetesRuntimeInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := awsEksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsEksKubernetesRuntimeInstanceDeleteSubject, *notifPayload)
	} else {
		if awsEksKubernetesRuntimeInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*awsEksKubernetesRuntimeInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&awsEksKubernetesRuntimeInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, awsEksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsObjectStorageBucketDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsObjectStorageBucketDefinitionVersions gets the supported versions for the aws object storage bucket definition API.
// @Description Get the supported API versions for aws object storage bucket definitions.
// @ID awsObjectStorageBucketDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-object-storage-bucket-definitions/versions [GET]
func (h Handler) GetAwsObjectStorageBucketDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsObjectStorageBucketDefinition)])
}

// @Summary adds a new aws object storage bucket definition.
// @Description Add a new aws object storage bucket definition to the Threeport database.
// @ID add-v0-awsObjectStorageBucketDefinition
// @Accept json
// @Produce json
// @Param awsObjectStorageBucketDefinition body api_v0.AwsObjectStorageBucketDefinition true "AwsObjectStorageBucketDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions [POST]
func (h Handler) AddAwsObjectStorageBucketDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	var awsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsObjectStorageBucketDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", awsObjectStorageBucketDefinition.Name).First(&existingAwsObjectStorageBucketDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsObjectStorageBucketDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws object storage bucket definitions.
// @Description Get all aws object storage bucket definitions from the Threeport database.
// @ID get-v0-awsObjectStorageBucketDefinitions
// @Accept json
// @Produce json
// @Param name query string false "aws object storage bucket definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions [GET]
func (h Handler) GetAwsObjectStorageBucketDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsObjectStorageBucketDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsObjectStorageBucketDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsObjectStorageBucketDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws object storage bucket definition.
// @Description Get a particular aws object storage bucket definition from the database.
// @ID get-v0-awsObjectStorageBucketDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions/{id} [GET]
func (h Handler) GetAwsObjectStorageBucketDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	awsObjectStorageBucketDefinitionID := c.Param("id")
	var awsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if result := h.DB.First(&awsObjectStorageBucketDefinition, awsObjectStorageBucketDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws object storage bucket definition.
// @Description Update a aws object storage bucket definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws object storage bucket definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsObjectStorageBucketDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsObjectStorageBucketDefinition body api_v0.AwsObjectStorageBucketDefinition true "AwsObjectStorageBucketDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions/{id} [PATCH]
func (h Handler) UpdateAwsObjectStorageBucketDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	awsObjectStorageBucketDefinitionID := c.Param("id")
	var existingAwsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if result := h.DB.First(&existingAwsObjectStorageBucketDefinition, awsObjectStorageBucketDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if err := c.Bind(&updatedAwsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsObjectStorageBucketDefinition).Updates(updatedAwsObjectStorageBucketDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsObjectStorageBucketDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws object storage bucket definition by replacing the entire object.
// @Description Replace a aws object storage bucket definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws object storage bucket definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsObjectStorageBucketDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsObjectStorageBucketDefinition body api_v0.AwsObjectStorageBucketDefinition true "AwsObjectStorageBucketDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions/{id} [PUT]
func (h Handler) ReplaceAwsObjectStorageBucketDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	awsObjectStorageBucketDefinitionID := c.Param("id")
	var existingAwsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if result := h.DB.First(&existingAwsObjectStorageBucketDefinition, awsObjectStorageBucketDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if err := c.Bind(&updatedAwsObjectStorageBucketDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsObjectStorageBucketDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsObjectStorageBucketDefinition.ID = existingAwsObjectStorageBucketDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsObjectStorageBucketDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsObjectStorageBucketDefinition, awsObjectStorageBucketDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsObjectStorageBucketDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws object storage bucket definition.
// @Description Delete a aws object storage bucket definition by ID from the database.
// @ID delete-v0-awsObjectStorageBucketDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-definitions/{id} [DELETE]
func (h Handler) DeleteAwsObjectStorageBucketDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketDefinition
	awsObjectStorageBucketDefinitionID := c.Param("id")
	var awsObjectStorageBucketDefinition api_v0.AwsObjectStorageBucketDefinition
	if result := h.DB.Preload("AwsObjectStorageBucketInstances").First(&awsObjectStorageBucketDefinition, awsObjectStorageBucketDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(awsObjectStorageBucketDefinition.AwsObjectStorageBucketInstances) != 0 {
		err := errors.New("aws object storage bucket definition has related aws object storage bucket instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// delete object
	if result := h.DB.Delete(&awsObjectStorageBucketDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsObjectStorageBucketInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsObjectStorageBucketInstanceVersions gets the supported versions for the aws object storage bucket instance API.
// @Description Get the supported API versions for aws object storage bucket instances.
// @ID awsObjectStorageBucketInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-object-storage-bucket-instances/versions [GET]
func (h Handler) GetAwsObjectStorageBucketInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsObjectStorageBucketInstance)])
}

// @Summary adds a new aws object storage bucket instance.
// @Description Add a new aws object storage bucket instance to the Threeport database.
// @ID add-v0-awsObjectStorageBucketInstance
// @Accept json
// @Produce json
// @Param awsObjectStorageBucketInstance body api_v0.AwsObjectStorageBucketInstance true "AwsObjectStorageBucketInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances [POST]
func (h Handler) AddAwsObjectStorageBucketInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	var awsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsObjectStorageBucketInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	nameUsed := true
	result := h.DB.Where("name = ?", awsObjectStorageBucketInstance.Name).First(&existingAwsObjectStorageBucketInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsObjectStorageBucketInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*awsObjectStorageBucketInstance.Reconciled {
		notifPayload, err := awsObjectStorageBucketInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsObjectStorageBucketInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws object storage bucket instances.
// @Description Get all aws object storage bucket instances from the Threeport database.
// @ID get-v0-awsObjectStorageBucketInstances
// @Accept json
// @Produce json
// @Param name query string false "aws object storage bucket instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances [GET]
func (h Handler) GetAwsObjectStorageBucketInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsObjectStorageBucketInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsObjectStorageBucketInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsObjectStorageBucketInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws object storage bucket instance.
// @Description Get a particular aws object storage bucket instance from the database.
// @ID get-v0-awsObjectStorageBucketInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances/{id} [GET]
func (h Handler) GetAwsObjectStorageBucketInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	awsObjectStorageBucketInstanceID := c.Param("id")
	var awsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if result := h.DB.First(&awsObjectStorageBucketInstance, awsObjectStorageBucketInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws object storage bucket instance.
// @Description Update a aws object storage bucket instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws object storage bucket instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsObjectStorageBucketInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsObjectStorageBucketInstance body api_v0.AwsObjectStorageBucketInstance true "AwsObjectStorageBucketInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances/{id} [PATCH]
func (h Handler) UpdateAwsObjectStorageBucketInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	awsObjectStorageBucketInstanceID := c.Param("id")
	var existingAwsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if result := h.DB.First(&existingAwsObjectStorageBucketInstance, awsObjectStorageBucketInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if err := c.Bind(&updatedAwsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsObjectStorageBucketInstance).Updates(updatedAwsObjectStorageBucketInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingAwsObjectStorageBucketInstance.Reconciled {
		notifPayload, err := existingAwsObjectStorageBucketInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsObjectStorageBucketInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsObjectStorageBucketInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws object storage bucket instance by replacing the entire object.
// @Description Replace a aws object storage bucket instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws object storage bucket instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsObjectStorageBucketInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsObjectStorageBucketInstance body api_v0.AwsObjectStorageBucketInstance true "AwsObjectStorageBucketInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances/{id} [PUT]
func (h Handler) ReplaceAwsObjectStorageBucketInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	awsObjectStorageBucketInstanceID := c.Param("id")
	var existingAwsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if result := h.DB.First(&existingAwsObjectStorageBucketInstance, awsObjectStorageBucketInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if err := c.Bind(&updatedAwsObjectStorageBucketInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsObjectStorageBucketInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsObjectStorageBucketInstance.ID = existingAwsObjectStorageBucketInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsObjectStorageBucketInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsObjectStorageBucketInstance, awsObjectStorageBucketInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsObjectStorageBucketInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws object storage bucket instance.
// @Description Delete a aws object storage bucket instance by ID from the database.
// @ID delete-v0-awsObjectStorageBucketInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-object-storage-bucket-instances/{id} [DELETE]
func (h Handler) DeleteAwsObjectStorageBucketInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsObjectStorageBucketInstance
	awsObjectStorageBucketInstanceID := c.Param("id")
	var awsObjectStorageBucketInstance api_v0.AwsObjectStorageBucketInstance
	if result := h.DB.First(&awsObjectStorageBucketInstance, awsObjectStorageBucketInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if awsObjectStorageBucketInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledAwsObjectStorageBucketInstance := api_v0.AwsObjectStorageBucketInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&awsObjectStorageBucketInstance).Updates(scheduledAwsObjectStorageBucketInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := awsObjectStorageBucketInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsObjectStorageBucketInstanceDeleteSubject, *notifPayload)
	} else {
		if awsObjectStorageBucketInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*awsObjectStorageBucketInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&awsObjectStorageBucketInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, awsObjectStorageBucketInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsRelationalDatabaseDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsRelationalDatabaseDefinitionVersions gets the supported versions for the aws relational database definition API.
// @Description Get the supported API versions for aws relational database definitions.
// @ID awsRelationalDatabaseDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-relational-database-definitions/versions [GET]
func (h Handler) GetAwsRelationalDatabaseDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsRelationalDatabaseDefinition)])
}

// @Summary adds a new aws relational database definition.
// @Description Add a new aws relational database definition to the Threeport database.
// @ID add-v0-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param awsRelationalDatabaseDefinition body api_v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions [POST]
func (h Handler) AddAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	var awsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsRelationalDatabaseDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", awsRelationalDatabaseDefinition.Name).First(&existingAwsRelationalDatabaseDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsRelationalDatabaseDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws relational database definitions.
// @Description Get all aws relational database definitions from the Threeport database.
// @ID get-v0-awsRelationalDatabaseDefinitions
// @Accept json
// @Produce json
// @Param name query string false "aws relational database definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions [GET]
func (h Handler) GetAwsRelationalDatabaseDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsRelationalDatabaseDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsRelationalDatabaseDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws relational database definition.
// @Description Get a particular aws relational database definition from the database.
// @ID get-v0-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [GET]
func (h Handler) GetAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var awsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&awsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws relational database definition.
// @Description Update a aws relational database definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws relational database definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseDefinition body api_v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [PATCH]
func (h Handler) UpdateAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var existingAwsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&updatedAwsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsRelationalDatabaseDefinition).Updates(updatedAwsRelationalDatabaseDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsRelationalDatabaseDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws relational database definition by replacing the entire object.
// @Description Replace a aws relational database definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws relational database definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseDefinition body api_v0.AwsRelationalDatabaseDefinition true "AwsRelationalDatabaseDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [PUT]
func (h Handler) ReplaceAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var existingAwsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if err := c.Bind(&updatedAwsRelationalDatabaseDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsRelationalDatabaseDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsRelationalDatabaseDefinition.ID = existingAwsRelationalDatabaseDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsRelationalDatabaseDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsRelationalDatabaseDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws relational database definition.
// @Description Delete a aws relational database definition by ID from the database.
// @ID delete-v0-awsRelationalDatabaseDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-definitions/{id} [DELETE]
func (h Handler) DeleteAwsRelationalDatabaseDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseDefinition
	awsRelationalDatabaseDefinitionID := c.Param("id")
	var awsRelationalDatabaseDefinition api_v0.AwsRelationalDatabaseDefinition
	if result := h.DB.Preload("AwsRelationalDatabaseInstances").First(&awsRelationalDatabaseDefinition, awsRelationalDatabaseDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(awsRelationalDatabaseDefinition.AwsRelationalDatabaseInstances) != 0 {
		err := errors.New("aws relational database definition has related aws relational database instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// delete object
	if result := h.DB.Delete(&awsRelationalDatabaseDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AwsRelationalDatabaseInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAwsRelationalDatabaseInstanceVersions gets the supported versions for the aws relational database instance API.
// @Description Get the supported API versions for aws relational database instances.
// @ID awsRelationalDatabaseInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /aws-relational-database-instances/versions [GET]
func (h Handler) GetAwsRelationalDatabaseInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAwsRelationalDatabaseInstance)])
}

// @Summary adds a new aws relational database instance.
// @Description Add a new aws relational database instance to the Threeport database.
// @ID add-v0-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param awsRelationalDatabaseInstance body api_v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances [POST]
func (h Handler) AddAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	var awsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, false, objectType, awsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&awsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, awsRelationalDatabaseInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAwsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	nameUsed := true
	result := h.DB.Where("name = ?", awsRelationalDatabaseInstance.Name).First(&existingAwsRelationalDatabaseInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&awsRelationalDatabaseInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*awsRelationalDatabaseInstance.Reconciled {
		notifPayload, err := awsRelationalDatabaseInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsRelationalDatabaseInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all aws relational database instances.
// @Description Get all aws relational database instances from the Threeport database.
// @ID get-v0-awsRelationalDatabaseInstances
// @Accept json
// @Produce json
// @Param name query string false "aws relational database instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances [GET]
func (h Handler) GetAwsRelationalDatabaseInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AwsRelationalDatabaseInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AwsRelationalDatabaseInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a aws relational database instance.
// @Description Get a particular aws relational database instance from the database.
// @ID get-v0-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [GET]
func (h Handler) GetAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var awsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&awsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing aws relational database instance.
// @Description Update a aws relational database instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating aws relational database instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseInstance body api_v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [PATCH]
func (h Handler) UpdateAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var existingAwsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&updatedAwsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAwsRelationalDatabaseInstance).Updates(updatedAwsRelationalDatabaseInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingAwsRelationalDatabaseInstance.Reconciled {
		notifPayload, err := existingAwsRelationalDatabaseInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsRelationalDatabaseInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsRelationalDatabaseInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing aws relational database instance by replacing the entire object.
// @Description Replace a aws relational database instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating aws relational database instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param awsRelationalDatabaseInstance body api_v0.AwsRelationalDatabaseInstance true "AwsRelationalDatabaseInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [PUT]
func (h Handler) ReplaceAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var existingAwsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, true, objectType, existingAwsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAwsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if err := c.Bind(&updatedAwsRelationalDatabaseInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAwsRelationalDatabaseInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAwsRelationalDatabaseInstance.ID = existingAwsRelationalDatabaseInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAwsRelationalDatabaseInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAwsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAwsRelationalDatabaseInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a aws relational database instance.
// @Description Delete a aws relational database instance by ID from the database.
// @ID delete-v0-awsRelationalDatabaseInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/aws-relational-database-instances/{id} [DELETE]
func (h Handler) DeleteAwsRelationalDatabaseInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAwsRelationalDatabaseInstance
	awsRelationalDatabaseInstanceID := c.Param("id")
	var awsRelationalDatabaseInstance api_v0.AwsRelationalDatabaseInstance
	if result := h.DB.First(&awsRelationalDatabaseInstance, awsRelationalDatabaseInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if awsRelationalDatabaseInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledAwsRelationalDatabaseInstance := api_v0.AwsRelationalDatabaseInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&awsRelationalDatabaseInstance).Updates(scheduledAwsRelationalDatabaseInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := awsRelationalDatabaseInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AwsRelationalDatabaseInstanceDeleteSubject, *notifPayload)
	} else {
		if awsRelationalDatabaseInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*awsRelationalDatabaseInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&awsRelationalDatabaseInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, awsRelationalDatabaseInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}
