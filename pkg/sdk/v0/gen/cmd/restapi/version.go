package restapi

import (
	"fmt"
	"path/filepath"

	. "github.com/dave/jennifer/jen"

	cli "github.com/threeport/threeport/pkg/cli/v0"
	"github.com/threeport/threeport/pkg/sdk/v0/gen"
	"github.com/threeport/threeport/pkg/sdk/v0/util"
)

// GenUtilVersion generates the REST API's /version route response so the API
// can provide an endpoint with its version.
func GenUtilVersion(gen *gen.Generator) error {
	f := NewFile("util")
	f.HeaderComment("generated by 'threeport-sdk gen' - do not edit")
	f.ImportAlias("github.com/labstack/echo/v4", "echo")

	f.Comment("RestApiVersion provides the version of the REST API binary.")
	f.Type().Id("RestApiVersion").Struct(
		Id("Version").String().Tag(map[string]string{"json": "Version", "validate": "required"}),
	)

	f.Comment("VersionRoute adds the /version route to the server to return the API")
	f.Comment("server's version.")
	f.Func().Id("VersionRoute").Params(Id("e").Op("*").Qual("github.com/labstack/echo/v4", "Echo")).Block(
		Id("e").Dot("GET").Call(
			Lit("/version"),
			Func().Params(Id("c").Qual("github.com/labstack/echo/v4", "Context")).Error().Block(
				Return(Id("c").Dot("JSON").Call(
					Line().Qual("net/http", "StatusOK"),
					Line().Id("RestApiVersion").Values(Dict{
						Line().Id("Version"): Qual(
							fmt.Sprintf("%s/internal/version", gen.ModulePath),
							"GetVersion",
						).Call().Op(",").Line(),
					}),
					Line(),
				)),
			),
		),
	)

	// write code to file
	genFilepath := filepath.Join("cmd", "rest-api", "util", "version_gen.go")
	_, err := util.WriteCodeToFile(f, genFilepath, true)
	if err != nil {
		return fmt.Errorf("failed to write generated code to file %s: %w", genFilepath, err)
	}
	cli.Info(fmt.Sprintf("source code for API server version route written to %s", genFilepath))

	return nil
}
