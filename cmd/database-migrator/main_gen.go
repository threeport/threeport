// generated by 'threeport-sdk gen' - do not edit

package main

import (
	"context"
	"flag"
	"fmt"
	godotenv "github.com/joho/godotenv"
	_ "github.com/lib/pq"
	goose "github.com/pressly/goose/v3"
	_ "github.com/threeport/threeport/cmd/database-migrator/migrations"
	database "github.com/threeport/threeport/pkg/api-server/v0/database"
	cli "github.com/threeport/threeport/pkg/cli/v0"
	log "github.com/threeport/threeport/pkg/log/v0"
	installer "github.com/threeport/threeport/pkg/threeport-installer/v0"
	zap "go.uber.org/zap"
	postgres "gorm.io/driver/postgres"
	gorm "gorm.io/gorm"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"
)

var (
	gooseCommands = []string{"up", "up-to", "up-by-one", "down", "down-to", "redo", "status"}
	envFile       = ""
)

func main() {
	flag.StringVar(&envFile, "env-file", "", "File from which to load environment")
	flag.Parse()

	// initialize logger
	logger, err := log.NewLogger(false)
	if err != nil {
		returnErr("could not create logger", err)
	}

	// env vars for database connection
	if envFile != "" {
		if err := godotenv.Load(envFile); err != nil {
			returnErr("failed to load environment variables", err)
		}
	}

	args := flag.Args()
	command := args[0]
	arguments := []string{}
	if len(args) > 1 {
		arguments = args[1:]
	}

	// validate command arg
	var found bool
	for _, c := range validArgs() {
		if command == c {
			found = true
			break
		}
	}
	if !found {
		returnErr("", fmt.Errorf("%s is not a valid argument", command))
	}

	switch command {
	case "initialize":
		if err := initializeDb(logger); err != nil {
			returnErr("failed to initialize database and user", err)
		}
		os.Exit(0)
	default:
		if err := migrateDb(command, arguments, logger); err != nil {
			returnErr("failed to migrate database schema", err)
		}
	}

	os.Exit(0)
}

// migrateDb runs the provided goose command - usually the 'up' command to apply
// migrations.
func migrateDb(
	command string,
	arguments []string,
	logger zap.Logger,
) error {
	// get non-root database connection string
	dsn, err := database.GetDsn(false)
	if err != nil {
		returnErr("failed to populate DB DSN from environment", err)
	}

	// configure goose driver
	db, err := goose.OpenDBWithDriver("postgres", dsn)
	if err != nil {
		returnErr("goose failed to open DB", err)
	}
	defer func() {
		if err := db.Close(); err != nil {
			returnErr("goose failed to close DB", err)
		}
	}()

	// configure gorm DB
	gormdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: &database.ZapLogger{Logger: &logger},
		NowFunc: func() time.Time {
			utc, _ := time.LoadLocation("UTC")
			return time.Now().In(utc).Truncate(time.Microsecond)
		},
	})
	if err != nil {
		returnErr("could not create gorm db object", err)
	}

	// run migrations
	ctx := context.WithValue(context.TODO(), "gormdb", gormdb)
	goose.SetTableName("threeport_goose_db_version")
	if err := goose.RunContext(ctx, command, db, ".", arguments...); err != nil {
		returnErr(fmt.Sprintf("goose %s command failed", command), err)
	}

	logger.Info("database schema successfully migrated")

	return nil
}

// initializeDb creates the database and user using root database user.
func initializeDb(logger zap.Logger) error {
	dsn, err := database.GetDsn(true)
	if err != nil {
		return fmt.Errorf("failed to get data source string: %w", err)
	}

	// at deployment time, this is the first database connection made so we
	// retry the connection for 5 min before returning an error
	var connAttemptsMax = 30
	var connAttemptIntervalSeconds = 10
	var connAttempts = 0
	var gormDb *gorm.DB
	var dbConnErr error
	for connAttempts < connAttemptsMax {
		db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
			Logger: &database.ZapLogger{Logger: &logger},
			NowFunc: func() time.Time {
				utc, _ := time.LoadLocation("UTC")
				return time.Now().In(utc).Truncate(time.Microsecond)
			},
		})
		if err != nil {
			logger.Info(fmt.Sprintf(
				"failed to make DB connection, retrying in %d seconds",
				connAttemptIntervalSeconds,
			))
			dbConnErr = err
		} else {
			gormDb = db
			break
		}
		connAttempts++
		time.Sleep(time.Second * time.Duration(connAttemptIntervalSeconds))
	}
	if gormDb == nil {
		return fmt.Errorf("timed out after 5 mim attempting to make database connection: %w", dbConnErr)
	}

	// execute SQL init script
	sqlFile := filepath.Join(installer.DbInitLocation, installer.DbInitFilename)
	sqlScript, err := ioutil.ReadFile(sqlFile)
	if err != nil {
		returnErr("failed to read SQL init script", err)
	}
	if err := gormDb.Exec(string(sqlScript)).Error; err != nil {
		returnErr("failed to execute SQL init script", err)
	}

	logger.Info("database successfully initialized")

	return nil
}

// returnErr returns errors with usage info and exits with non-zero
func returnErr(msg string, err error) {
	cli.Error(msg, err)
	usage()
	os.Exit(1)
}

// usage prints the usage info for database-migrator
func usage() {
	args := validArgs()
	fmt.Printf("database-migrator initializes and manages the database schema for the Threeport API\n\nusage: database-migrator [-env-file /path/to/environment_file] <arguments>\n\nvalid arguments: %s\n\nexamples:\n\tInitialize the database by creating database and user:\n\tdatabase-migrator -env-file=/etc/threeport/env initialize\n\n\tRun database migrations to apply database schema:\n\tdatabase-migrator -env-file=/etc/threeport/env up\n}\\n", args)
}

// validArgs returns all valid arguments to database-migrator
func validArgs() []string {
	return append(gooseCommands, "initialize")
}
