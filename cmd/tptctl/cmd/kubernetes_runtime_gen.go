// generated by 'threeport-sdk gen' - do not edit

package cmd

import (
	"encoding/json"
	"errors"
	"fmt"
	ghodss_yaml "github.com/ghodss/yaml"
	cobra "github.com/spf13/cobra"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	cli "github.com/threeport/threeport/pkg/cli/v0"
	client_v0 "github.com/threeport/threeport/pkg/client/v0"
	config_v0 "github.com/threeport/threeport/pkg/config/v0"
	encryption "github.com/threeport/threeport/pkg/encryption/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	yaml "gopkg.in/yaml.v2"
	"os"
)

///////////////////////////////////////////////////////////////////////////////
// KubernetesRuntimeDefinition
///////////////////////////////////////////////////////////////////////////////

var getKubernetesRuntimeDefinitionVersion string

// GetKubernetesRuntimeDefinitionsCmd represents the kubernetes-runtime-definition command
var GetKubernetesRuntimeDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get kubernetes-runtime-definitions",
	Long:    "Get kubernetes runtime definitions from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getKubernetesRuntimeDefinitionVersion {
		case "v0":
			// get kubernetes runtime definitions
			kubernetesRuntimeDefinitions, err := client_v0.GetKubernetesRuntimeDefinitions(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve kubernetes runtime definitions", err)
				os.Exit(1)
			}

			// write the output
			if len(*kubernetesRuntimeDefinitions) == 0 {
				cli.Info(fmt.Sprintf(
					"No kubernetes runtime definitions currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0KubernetesRuntimeDefinitionsCmd(
				kubernetesRuntimeDefinitions,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get kubernetes runtime definitions from the system",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-definitions",
}

func init() {
	GetCmd.AddCommand(GetKubernetesRuntimeDefinitionsCmd)

	GetKubernetesRuntimeDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetKubernetesRuntimeDefinitionsCmd.Flags().StringVarP(
		&getKubernetesRuntimeDefinitionVersion,
		"version", "v", "v0", "Version of kubernetes runtime definitions object to retrieve. One of: [v0]",
	)
}

var (
	createKubernetesRuntimeDefinitionConfigPath string
	createKubernetesRuntimeDefinitionVersion    string
)

// CreateKubernetesRuntimeDefinitionCmd represents the kubernetes-runtime-definition command
var CreateKubernetesRuntimeDefinitionCmd = &cobra.Command{
	Example: "  tptctl create kubernetes-runtime-definition --config path/to/config.yaml",
	Long:    "Create a new kubernetes runtime definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read kubernetes runtime definition config
		configContent, err := os.ReadFile(createKubernetesRuntimeDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create kubernetes runtime definition based on version
		switch createKubernetesRuntimeDefinitionVersion {
		case "v0":
			var kubernetesRuntimeDefinitionConfig config_v0.KubernetesRuntimeDefinitionConfig
			if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create kubernetes runtime definition
			kubernetesRuntimeDefinition := kubernetesRuntimeDefinitionConfig.KubernetesRuntimeDefinition
			createdKubernetesRuntimeDefinition, err := kubernetesRuntimeDefinition.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create kubernetes runtime definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("kubernetes runtime definition %s created", *createdKubernetesRuntimeDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new kubernetes runtime definition",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-definition",
}

func init() {
	CreateCmd.AddCommand(CreateKubernetesRuntimeDefinitionCmd)

	CreateKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&createKubernetesRuntimeDefinitionConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime definition config.",
	)
	CreateKubernetesRuntimeDefinitionCmd.MarkFlagRequired("config")
	CreateKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&createKubernetesRuntimeDefinitionVersion,
		"version", "v", "v0", "Version of kubernetes runtime definitions object to create. One of: [v0]",
	)
}

var (
	deleteKubernetesRuntimeDefinitionConfigPath string
	deleteKubernetesRuntimeDefinitionName       string
	deleteKubernetesRuntimeDefinitionVersion    string
)

// DeleteKubernetesRuntimeDefinitionCmd represents the kubernetes-runtime-definition command
var DeleteKubernetesRuntimeDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete kubernetes-runtime-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete kubernetes-runtime-definition --name some-kubernetes-runtime-definition",
	Long:    "Delete an existing kubernetes runtime definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteKubernetesRuntimeDefinitionConfigPath,
			deleteKubernetesRuntimeDefinitionName,
			"kubernetes runtime definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete kubernetes runtime definition based on version
		switch deleteKubernetesRuntimeDefinitionVersion {
		case "v0":
			var kubernetesRuntimeDefinitionConfig config_v0.KubernetesRuntimeDefinitionConfig
			if deleteKubernetesRuntimeDefinitionConfigPath != "" {
				// load kubernetes runtime definition config
				configContent, err := os.ReadFile(deleteKubernetesRuntimeDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				kubernetesRuntimeDefinitionConfig = config_v0.KubernetesRuntimeDefinitionConfig{
					KubernetesRuntimeDefinition: config_v0.KubernetesRuntimeDefinitionValues{
						Name: &deleteKubernetesRuntimeDefinitionName,
					},
				}
			}

			// delete kubernetes runtime definition
			kubernetesRuntimeDefinition := kubernetesRuntimeDefinitionConfig.KubernetesRuntimeDefinition
			deletedKubernetesRuntimeDefinition, err := kubernetesRuntimeDefinition.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete kubernetes runtime definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("kubernetes runtime definition %s deleted", *deletedKubernetesRuntimeDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing kubernetes runtime definition",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteKubernetesRuntimeDefinitionCmd)

	DeleteKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeDefinitionConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime definition config.",
	)
	DeleteKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeDefinitionName,
		"name", "n", "", "Name of kubernetes runtime definition.",
	)
	DeleteKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeDefinitionVersion,
		"version", "v", "v0", "Version of kubernetes runtime definitions object to delete. One of: [v0]",
	)
}

var (
	describeKubernetesRuntimeDefinitionConfigPath string
	describeKubernetesRuntimeDefinitionName       string
	describeKubernetesRuntimeDefinitionField      string
	describeKubernetesRuntimeDefinitionOutput     string
	describeKubernetesRuntimeDefinitionVersion    string
)

// DescribeKubernetesRuntimeDefinitionCmd representes the kubernetes-runtime-definition command
var DescribeKubernetesRuntimeDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a kubernetes runtime definition\n  tptctl describe kubernetes-runtime-definition -n some-kubernetes-runtime-definition\n\n  # Get JSON output for a kubernetes runtime definition\n  tptctl describe kubernetes-runtime-definition -n some-kubernetes-runtime-definition -o json\n\n  # Get the value of the Name field for a kubernetes runtime definition\n  tptctl describe kubernetes-runtime-definition -n some-kubernetes-runtime-definition -f Name ",
	Long:    "Describe a kubernetes runtime definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeKubernetesRuntimeDefinitionConfigPath,
			describeKubernetesRuntimeDefinitionName,
			"kubernetes runtime definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeKubernetesRuntimeDefinitionOutput,
			"kubernetes runtime definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get kubernetes runtime definition
		var kubernetesRuntimeDefinition interface{}
		switch describeKubernetesRuntimeDefinitionVersion {
		case "v0":
			// load kubernetes runtime definition config by name or config file
			var kubernetesRuntimeDefinitionConfig config_v0.KubernetesRuntimeDefinitionConfig
			if describeKubernetesRuntimeDefinitionConfigPath != "" {
				configContent, err := os.ReadFile(describeKubernetesRuntimeDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				kubernetesRuntimeDefinitionConfig = config_v0.KubernetesRuntimeDefinitionConfig{
					KubernetesRuntimeDefinition: config_v0.KubernetesRuntimeDefinitionValues{
						Name: &describeKubernetesRuntimeDefinitionName,
					},
				}
			}

			// get kubernetes runtime definition object by name
			obj, err := client_v0.GetKubernetesRuntimeDefinitionByName(
				apiClient,
				apiEndpoint,
				*kubernetesRuntimeDefinitionConfig.KubernetesRuntimeDefinition.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve kubernetes runtime definition details", err)
				os.Exit(1)
			}
			kubernetesRuntimeDefinition = obj

			// return plain output if requested
			if describeKubernetesRuntimeDefinitionOutput == "plain" {
				if err := outputDescribev0KubernetesRuntimeDefinitionCmd(
					kubernetesRuntimeDefinition.(*api_v0.KubernetesRuntimeDefinition),
					&kubernetesRuntimeDefinitionConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe kubernetes runtime definition", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeKubernetesRuntimeDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				kubernetesRuntimeDefinition,
				describeKubernetesRuntimeDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from kubernetes runtime definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(kubernetesRuntimeDefinition, describeKubernetesRuntimeDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeKubernetesRuntimeDefinitionOutput {
		case "json":
			// redact encrypted values
			redactedKubernetesRuntimeDefinition := encryption.RedactEncryptedValues(kubernetesRuntimeDefinition)

			// marshal to JSON then print
			kubernetesRuntimeDefinitionJson, err := json.MarshalIndent(redactedKubernetesRuntimeDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal kubernetes runtime definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(kubernetesRuntimeDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedKubernetesRuntimeDefinition := encryption.RedactEncryptedValues(kubernetesRuntimeDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			kubernetesRuntimeDefinitionJson, err := json.MarshalIndent(redactedKubernetesRuntimeDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal kubernetes runtime definition into JSON", err)
				os.Exit(1)
			}
			kubernetesRuntimeDefinitionYaml, err := ghodss_yaml.JSONToYAML(kubernetesRuntimeDefinitionJson)
			if err != nil {
				cli.Error("failed to convert kubernetes runtime definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(kubernetesRuntimeDefinitionYaml))
		}
	},
	Short:        "Describe a kubernetes runtime definition",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeKubernetesRuntimeDefinitionCmd)

	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&describeKubernetesRuntimeDefinitionConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime definition config.",
	)
	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&describeKubernetesRuntimeDefinitionName,
		"name", "n", "", "Name of kubernetes runtime definition.",
	)
	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&describeKubernetesRuntimeDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&describeKubernetesRuntimeDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeKubernetesRuntimeDefinitionCmd.Flags().StringVarP(
		&describeKubernetesRuntimeDefinitionVersion,
		"version", "v", "v0", "Version of kubernetes runtime definitions object to describe. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// KubernetesRuntime
///////////////////////////////////////////////////////////////////////////////

// GetKubernetesRuntimesCmd represents the kubernetes-runtime command
var GetKubernetesRuntimesCmd = &cobra.Command{
	Example: "  tptctl get kubernetes-runtimes",
	Long:    "Get kubernetes runtimes from the system.\n\nA kubernetes runtime is a simple abstraction of kubernetes runtime definitions and kubernetes runtime instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		// get kubernetes runtimes
		v0kubernetesRuntimeInstances, err := client_v0.GetKubernetesRuntimeInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve kubernetes runtime instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*v0kubernetesRuntimeInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No kubernetes runtime instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetKubernetesRuntimesCmd(
			v0kubernetesRuntimeInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get kubernetes runtimes from the system",
	SilenceUsage: true,
	Use:          "kubernetes-runtimes",
}

func init() {
	GetCmd.AddCommand(GetKubernetesRuntimesCmd)

	GetKubernetesRuntimesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	createKubernetesRuntimeConfigPath string
	createKubernetesRuntimeVersion    string
)

// CreateKubernetesRuntimeCmd represents the kubernetes-runtime command
var CreateKubernetesRuntimeCmd = &cobra.Command{
	Example: "  tptctl create kubernetes-runtime --config path/to/config.yaml",
	Long:    "Create a new kubernetes runtime. This command creates a new kubernetes runtime definition and kubernetes runtime instance based on the kubernetes runtime config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read kubernetes runtime config
		configContent, err := os.ReadFile(createKubernetesRuntimeConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// create kubernetes runtime based on version
		switch createKubernetesRuntimeVersion {
		case "v0":
			var kubernetesRuntimeConfig config_v0.KubernetesRuntimeConfig
			if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create kubernetes runtime
			kubernetesRuntime := kubernetesRuntimeConfig.KubernetesRuntime
			createdKubernetesRuntimeDefinition, createdKubernetesRuntimeInstance, err := kubernetesRuntime.Create(
				apiClient,
				apiEndpoint,
			)
			if err != nil {
				cli.Error("failed to create kubernetes runtime", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("kubernetes runtime definition %s created", *createdKubernetesRuntimeDefinition.Name))
			cli.Info(fmt.Sprintf("kubernetes runtime instance %s created", *createdKubernetesRuntimeInstance.Name))
			cli.Complete(fmt.Sprintf("kubernetes runtime %s created", *kubernetesRuntimeConfig.KubernetesRuntime.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new kubernetes runtime",
	SilenceUsage: true,
	Use:          "kubernetes-runtime",
}

func init() {
	CreateCmd.AddCommand(CreateKubernetesRuntimeCmd)

	CreateKubernetesRuntimeCmd.Flags().StringVarP(
		&createKubernetesRuntimeConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime config.",
	)
	CreateKubernetesRuntimeCmd.MarkFlagRequired("config")
	CreateKubernetesRuntimeCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateKubernetesRuntimeCmd.Flags().StringVarP(
		&createKubernetesRuntimeVersion,
		"version", "v", "v0", "Version of kubernetes runtimes object to create. One of: [v0]",
	)
}

var (
	deleteKubernetesRuntimeConfigPath string
	deleteKubernetesRuntimeName       string
	deleteKubernetesRuntimeVersion    string
)

// DeleteKubernetesRuntimeCmd represents the kubernetes-runtime command
var DeleteKubernetesRuntimeCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete kubernetes-runtime --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete kubernetes-runtime --name some-kubernetes-runtime",
	Long:    "Delete an existing kubernetes runtime. This command deletes an existing kubernetes runtime definition and kubernetes runtime instance based on the kubernetes runtime config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if deleteKubernetesRuntimeConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		// read kubernetes runtime config
		configContent, err := os.ReadFile(deleteKubernetesRuntimeConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// delete kubernetes runtime based on version
		switch deleteKubernetesRuntimeVersion {
		case "v0":
			var kubernetesRuntimeConfig config_v0.KubernetesRuntimeConfig
			if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// delete kubernetes runtime
			kubernetesRuntime := kubernetesRuntimeConfig.KubernetesRuntime
			_, _, err = kubernetesRuntime.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete kubernetes runtime", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("kubernetes runtime definition %s deleted", *kubernetesRuntime.Name))
			cli.Info(fmt.Sprintf("kubernetes runtime instance %s deleted", *kubernetesRuntime.Name))
			cli.Complete(fmt.Sprintf("kubernetes runtime %s deleted", *kubernetesRuntimeConfig.KubernetesRuntime.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing kubernetes runtime",
	SilenceUsage: true,
	Use:          "kubernetes-runtime",
}

func init() {
	DeleteCmd.AddCommand(DeleteKubernetesRuntimeCmd)

	DeleteKubernetesRuntimeCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime config.",
	)
	DeleteKubernetesRuntimeCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteKubernetesRuntimeCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeVersion,
		"version", "v", "v0", "Version of kubernetes runtimes object to delete. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// KubernetesRuntimeInstance
///////////////////////////////////////////////////////////////////////////////

var getKubernetesRuntimeInstanceVersion string

// GetKubernetesRuntimeInstancesCmd represents the kubernetes-runtime-instance command
var GetKubernetesRuntimeInstancesCmd = &cobra.Command{
	Example: "  tptctl get kubernetes-runtime-instances",
	Long:    "Get kubernetes runtime instances from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getKubernetesRuntimeInstanceVersion {
		case "v0":
			// get kubernetes runtime instances
			kubernetesRuntimeInstances, err := client_v0.GetKubernetesRuntimeInstances(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve kubernetes runtime instances", err)
				os.Exit(1)
			}

			// write the output
			if len(*kubernetesRuntimeInstances) == 0 {
				cli.Info(fmt.Sprintf(
					"No kubernetes runtime instances currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0KubernetesRuntimeInstancesCmd(
				kubernetesRuntimeInstances,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get kubernetes runtime instances from the system",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-instances",
}

func init() {
	GetCmd.AddCommand(GetKubernetesRuntimeInstancesCmd)

	GetKubernetesRuntimeInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetKubernetesRuntimeInstancesCmd.Flags().StringVarP(
		&getKubernetesRuntimeInstanceVersion,
		"version", "v", "v0", "Version of kubernetes runtime instances object to retrieve. One of: [v0]",
	)
}

var (
	createKubernetesRuntimeInstanceConfigPath string
	createKubernetesRuntimeInstanceVersion    string
)

// CreateKubernetesRuntimeInstanceCmd represents the kubernetes-runtime-instance command
var CreateKubernetesRuntimeInstanceCmd = &cobra.Command{
	Example: "  tptctl create kubernetes-runtime-instance --config path/to/config.yaml",
	Long:    "Create a new kubernetes runtime instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read kubernetes runtime instance config
		configContent, err := os.ReadFile(createKubernetesRuntimeInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create kubernetes runtime instance based on version
		switch createKubernetesRuntimeInstanceVersion {
		case "v0":
			var kubernetesRuntimeInstanceConfig config_v0.KubernetesRuntimeInstanceConfig
			if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create kubernetes runtime instance
			kubernetesRuntimeInstance := kubernetesRuntimeInstanceConfig.KubernetesRuntimeInstance
			createdKubernetesRuntimeInstance, err := kubernetesRuntimeInstance.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create kubernetes runtime instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("kubernetes runtime instance %s created", *createdKubernetesRuntimeInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new kubernetes runtime instance",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-instance",
}

func init() {
	CreateCmd.AddCommand(CreateKubernetesRuntimeInstanceCmd)

	CreateKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&createKubernetesRuntimeInstanceConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime instance config.",
	)
	CreateKubernetesRuntimeInstanceCmd.MarkFlagRequired("config")
	CreateKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&createKubernetesRuntimeInstanceVersion,
		"version", "v", "v0", "Version of kubernetes runtime instances object to create. One of: [v0]",
	)
}

var (
	deleteKubernetesRuntimeInstanceConfigPath string
	deleteKubernetesRuntimeInstanceName       string
	deleteKubernetesRuntimeInstanceVersion    string
)

// DeleteKubernetesRuntimeInstanceCmd represents the kubernetes-runtime-instance command
var DeleteKubernetesRuntimeInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete kubernetes-runtime-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete kubernetes-runtime-instance --name some-kubernetes-runtime-instance",
	Long:    "Delete an existing kubernetes runtime instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteKubernetesRuntimeInstanceConfigPath,
			deleteKubernetesRuntimeInstanceName,
			"kubernetes runtime instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete kubernetes runtime instance based on version
		switch deleteKubernetesRuntimeInstanceVersion {
		case "v0":
			var kubernetesRuntimeInstanceConfig config_v0.KubernetesRuntimeInstanceConfig
			if deleteKubernetesRuntimeInstanceConfigPath != "" {
				// load kubernetes runtime instance config
				configContent, err := os.ReadFile(deleteKubernetesRuntimeInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				kubernetesRuntimeInstanceConfig = config_v0.KubernetesRuntimeInstanceConfig{
					KubernetesRuntimeInstance: config_v0.KubernetesRuntimeInstanceValues{
						Name: &deleteKubernetesRuntimeInstanceName,
					},
				}
			}

			// delete kubernetes runtime instance
			kubernetesRuntimeInstance := kubernetesRuntimeInstanceConfig.KubernetesRuntimeInstance
			deletedKubernetesRuntimeInstance, err := kubernetesRuntimeInstance.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete kubernetes runtime instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("kubernetes runtime instance %s deleted", *deletedKubernetesRuntimeInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing kubernetes runtime instance",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteKubernetesRuntimeInstanceCmd)

	DeleteKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeInstanceConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime instance config.",
	)
	DeleteKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeInstanceName,
		"name", "n", "", "Name of kubernetes runtime instance.",
	)
	DeleteKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&deleteKubernetesRuntimeInstanceVersion,
		"version", "v", "v0", "Version of kubernetes runtime instances object to delete. One of: [v0]",
	)
}

var (
	describeKubernetesRuntimeInstanceConfigPath string
	describeKubernetesRuntimeInstanceName       string
	describeKubernetesRuntimeInstanceField      string
	describeKubernetesRuntimeInstanceOutput     string
	describeKubernetesRuntimeInstanceVersion    string
)

// DescribeKubernetesRuntimeInstanceCmd representes the kubernetes-runtime-instance command
var DescribeKubernetesRuntimeInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a kubernetes runtime instance\n  tptctl describe kubernetes-runtime-instance -n some-kubernetes-runtime-instance\n\n  # Get JSON output for a kubernetes runtime instance\n  tptctl describe kubernetes-runtime-instance -n some-kubernetes-runtime-instance -o json\n\n  # Get the value of the Name field for a kubernetes runtime instance\n  tptctl describe kubernetes-runtime-instance -n some-kubernetes-runtime-instance -f Name ",
	Long:    "Describe a kubernetes runtime instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeKubernetesRuntimeInstanceConfigPath,
			describeKubernetesRuntimeInstanceName,
			"kubernetes runtime instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeKubernetesRuntimeInstanceOutput,
			"kubernetes runtime instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get kubernetes runtime instance
		var kubernetesRuntimeInstance interface{}
		switch describeKubernetesRuntimeInstanceVersion {
		case "v0":
			// load kubernetes runtime instance config by name or config file
			var kubernetesRuntimeInstanceConfig config_v0.KubernetesRuntimeInstanceConfig
			if describeKubernetesRuntimeInstanceConfigPath != "" {
				configContent, err := os.ReadFile(describeKubernetesRuntimeInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &kubernetesRuntimeInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				kubernetesRuntimeInstanceConfig = config_v0.KubernetesRuntimeInstanceConfig{
					KubernetesRuntimeInstance: config_v0.KubernetesRuntimeInstanceValues{
						Name: &describeKubernetesRuntimeInstanceName,
					},
				}
			}

			// get kubernetes runtime instance object by name
			obj, err := client_v0.GetKubernetesRuntimeInstanceByName(
				apiClient,
				apiEndpoint,
				*kubernetesRuntimeInstanceConfig.KubernetesRuntimeInstance.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve kubernetes runtime instance details", err)
				os.Exit(1)
			}
			kubernetesRuntimeInstance = obj

			// return plain output if requested
			if describeKubernetesRuntimeInstanceOutput == "plain" {
				if err := outputDescribev0KubernetesRuntimeInstanceCmd(
					kubernetesRuntimeInstance.(*api_v0.KubernetesRuntimeInstance),
					&kubernetesRuntimeInstanceConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe kubernetes runtime instance", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeKubernetesRuntimeInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				kubernetesRuntimeInstance,
				describeKubernetesRuntimeInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from kubernetes runtime instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(kubernetesRuntimeInstance, describeKubernetesRuntimeInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeKubernetesRuntimeInstanceOutput {
		case "json":
			// redact encrypted values
			redactedKubernetesRuntimeInstance := encryption.RedactEncryptedValues(kubernetesRuntimeInstance)

			// marshal to JSON then print
			kubernetesRuntimeInstanceJson, err := json.MarshalIndent(redactedKubernetesRuntimeInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal kubernetes runtime instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(kubernetesRuntimeInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedKubernetesRuntimeInstance := encryption.RedactEncryptedValues(kubernetesRuntimeInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			kubernetesRuntimeInstanceJson, err := json.MarshalIndent(redactedKubernetesRuntimeInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal kubernetes runtime instance into JSON", err)
				os.Exit(1)
			}
			kubernetesRuntimeInstanceYaml, err := ghodss_yaml.JSONToYAML(kubernetesRuntimeInstanceJson)
			if err != nil {
				cli.Error("failed to convert kubernetes runtime instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(kubernetesRuntimeInstanceYaml))
		}
	},
	Short:        "Describe a kubernetes runtime instance",
	SilenceUsage: true,
	Use:          "kubernetes-runtime-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeKubernetesRuntimeInstanceCmd)

	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&describeKubernetesRuntimeInstanceConfigPath,
		"config", "c", "", "Path to file with kubernetes runtime instance config.",
	)
	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&describeKubernetesRuntimeInstanceName,
		"name", "n", "", "Name of kubernetes runtime instance.",
	)
	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&describeKubernetesRuntimeInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&describeKubernetesRuntimeInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeKubernetesRuntimeInstanceCmd.Flags().StringVarP(
		&describeKubernetesRuntimeInstanceVersion,
		"version", "v", "v0", "Version of kubernetes runtime instances object to describe. One of: [v0]",
	)
}
