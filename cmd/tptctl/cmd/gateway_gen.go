// generated by 'threeport-sdk gen' - do not edit

package cmd

import (
	"encoding/json"
	"errors"
	"fmt"
	ghodss_yaml "github.com/ghodss/yaml"
	cobra "github.com/spf13/cobra"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	cli "github.com/threeport/threeport/pkg/cli/v0"
	client_v0 "github.com/threeport/threeport/pkg/client/v0"
	config_v0 "github.com/threeport/threeport/pkg/config/v0"
	encryption "github.com/threeport/threeport/pkg/encryption/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	yaml "gopkg.in/yaml.v2"
	"os"
)

///////////////////////////////////////////////////////////////////////////////
// DomainNameDefinition
///////////////////////////////////////////////////////////////////////////////

var getDomainNameDefinitionVersion string

// GetDomainNameDefinitionsCmd represents the domain-name-definition command
var GetDomainNameDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get domain-name-definitions",
	Long:    "Get domain name definitions from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getDomainNameDefinitionVersion {
		case "v0":
			// get domain name definitions
			domainNameDefinitions, err := client_v0.GetDomainNameDefinitions(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve domain name definitions", err)
				os.Exit(1)
			}

			// write the output
			if len(*domainNameDefinitions) == 0 {
				cli.Info(fmt.Sprintf(
					"No domain name definitions currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0DomainNameDefinitionsCmd(
				domainNameDefinitions,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get domain name definitions from the system",
	SilenceUsage: true,
	Use:          "domain-name-definitions",
}

func init() {
	GetCmd.AddCommand(GetDomainNameDefinitionsCmd)

	GetDomainNameDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetDomainNameDefinitionsCmd.Flags().StringVarP(
		&getDomainNameDefinitionVersion,
		"version", "v", "v0", "Version of domain name definitions object to retrieve. One of: [v0]",
	)
}

var (
	createDomainNameDefinitionConfigPath string
	createDomainNameDefinitionVersion    string
)

// CreateDomainNameDefinitionCmd represents the domain-name-definition command
var CreateDomainNameDefinitionCmd = &cobra.Command{
	Example: "  tptctl create domain-name-definition --config path/to/config.yaml",
	Long:    "Create a new domain name definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read domain name definition config
		configContent, err := os.ReadFile(createDomainNameDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create domain name definition based on version
		switch createDomainNameDefinitionVersion {
		case "v0":
			var domainNameDefinitionConfig config_v0.DomainNameDefinitionConfig
			if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create domain name definition
			domainNameDefinition := domainNameDefinitionConfig.DomainNameDefinition
			createdDomainNameDefinition, err := domainNameDefinition.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create domain name definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("domain name definition %s created", *createdDomainNameDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameDefinitionCmd)

	CreateDomainNameDefinitionCmd.Flags().StringVarP(
		&createDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.",
	)
	CreateDomainNameDefinitionCmd.MarkFlagRequired("config")
	CreateDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateDomainNameDefinitionCmd.Flags().StringVarP(
		&createDomainNameDefinitionVersion,
		"version", "v", "v0", "Version of domain name definitions object to create. One of: [v0]",
	)
}

var (
	deleteDomainNameDefinitionConfigPath string
	deleteDomainNameDefinitionName       string
	deleteDomainNameDefinitionVersion    string
)

// DeleteDomainNameDefinitionCmd represents the domain-name-definition command
var DeleteDomainNameDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name-definition --name some-domain-name-definition",
	Long:    "Delete an existing domain name definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteDomainNameDefinitionConfigPath,
			deleteDomainNameDefinitionName,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete domain name definition based on version
		switch deleteDomainNameDefinitionVersion {
		case "v0":
			var domainNameDefinitionConfig config_v0.DomainNameDefinitionConfig
			if deleteDomainNameDefinitionConfigPath != "" {
				// load domain name definition config
				configContent, err := os.ReadFile(deleteDomainNameDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				domainNameDefinitionConfig = config_v0.DomainNameDefinitionConfig{
					DomainNameDefinition: config_v0.DomainNameDefinitionValues{
						Name: &deleteDomainNameDefinitionName,
					},
				}
			}

			// delete domain name definition
			domainNameDefinition := domainNameDefinitionConfig.DomainNameDefinition
			deletedDomainNameDefinition, err := domainNameDefinition.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete domain name definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("domain name definition %s deleted", *deletedDomainNameDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameDefinitionCmd)

	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&deleteDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.",
	)
	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&deleteDomainNameDefinitionName,
		"name", "n", "", "Name of domain name definition.",
	)
	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&deleteDomainNameDefinitionVersion,
		"version", "v", "v0", "Version of domain name definitions object to delete. One of: [v0]",
	)
}

var (
	describeDomainNameDefinitionConfigPath string
	describeDomainNameDefinitionName       string
	describeDomainNameDefinitionField      string
	describeDomainNameDefinitionOutput     string
	describeDomainNameDefinitionVersion    string
)

// DescribeDomainNameDefinitionCmd representes the domain-name-definition command
var DescribeDomainNameDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition\n\n  # Get JSON output for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition -o json\n\n  # Get the value of the Name field for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition -f Name ",
	Long:    "Describe a domain name definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeDomainNameDefinitionConfigPath,
			describeDomainNameDefinitionName,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeDomainNameDefinitionOutput,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get domain name definition
		var domainNameDefinition interface{}
		switch describeDomainNameDefinitionVersion {
		case "v0":
			// load domain name definition config by name or config file
			var domainNameDefinitionConfig config_v0.DomainNameDefinitionConfig
			if describeDomainNameDefinitionConfigPath != "" {
				configContent, err := os.ReadFile(describeDomainNameDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				domainNameDefinitionConfig = config_v0.DomainNameDefinitionConfig{
					DomainNameDefinition: config_v0.DomainNameDefinitionValues{
						Name: &describeDomainNameDefinitionName,
					},
				}
			}

			// get domain name definition object by name
			obj, err := client_v0.GetDomainNameDefinitionByName(
				apiClient,
				apiEndpoint,
				*domainNameDefinitionConfig.DomainNameDefinition.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve domain name definition details", err)
				os.Exit(1)
			}
			domainNameDefinition = obj

			// return plain output if requested
			if describeDomainNameDefinitionOutput == "plain" {
				if err := outputDescribev0DomainNameDefinitionCmd(
					domainNameDefinition.(*api_v0.DomainNameDefinition),
					&domainNameDefinitionConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe domain name definition", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeDomainNameDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				domainNameDefinition,
				describeDomainNameDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from domain name definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(domainNameDefinition, describeDomainNameDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeDomainNameDefinitionOutput {
		case "json":
			// redact encrypted values
			redactedDomainNameDefinition := encryption.RedactEncryptedValues(domainNameDefinition)

			// marshal to JSON then print
			domainNameDefinitionJson, err := json.MarshalIndent(redactedDomainNameDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedDomainNameDefinition := encryption.RedactEncryptedValues(domainNameDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			domainNameDefinitionJson, err := json.MarshalIndent(redactedDomainNameDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name definition into JSON", err)
				os.Exit(1)
			}
			domainNameDefinitionYaml, err := ghodss_yaml.JSONToYAML(domainNameDefinitionJson)
			if err != nil {
				cli.Error("failed to convert domain name definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameDefinitionYaml))
		}
	},
	Short:        "Describe a domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeDomainNameDefinitionCmd)

	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.",
	)
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionName,
		"name", "n", "", "Name of domain name definition.",
	)
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionVersion,
		"version", "v", "v0", "Version of domain name definitions object to describe. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// DomainName
///////////////////////////////////////////////////////////////////////////////

// GetDomainNamesCmd represents the domain-name command
var GetDomainNamesCmd = &cobra.Command{
	Example: "  tptctl get domain-names",
	Long:    "Get domain names from the system.\n\nA domain name is a simple abstraction of domain name definitions and domain name instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		// get domain names
		v0domainNameInstances, err := client_v0.GetDomainNameInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve domain name instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*v0domainNameInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No domain name instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetDomainNamesCmd(
			v0domainNameInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get domain names from the system",
	SilenceUsage: true,
	Use:          "domain-names",
}

func init() {
	GetCmd.AddCommand(GetDomainNamesCmd)

	GetDomainNamesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	createDomainNameConfigPath string
	createDomainNameVersion    string
)

// CreateDomainNameCmd represents the domain-name command
var CreateDomainNameCmd = &cobra.Command{
	Example: "  tptctl create domain-name --config path/to/config.yaml",
	Long:    "Create a new domain name. This command creates a new domain name definition and domain name instance based on the domain name config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read domain name config
		configContent, err := os.ReadFile(createDomainNameConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// create domain name based on version
		switch createDomainNameVersion {
		case "v0":
			var domainNameConfig config_v0.DomainNameConfig
			if err := yaml.UnmarshalStrict(configContent, &domainNameConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create domain name
			domainName := domainNameConfig.DomainName
			createdDomainNameDefinition, createdDomainNameInstance, err := domainName.Create(
				apiClient,
				apiEndpoint,
			)
			if err != nil {
				cli.Error("failed to create domain name", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("domain name definition %s created", *createdDomainNameDefinition.Name))
			cli.Info(fmt.Sprintf("domain name instance %s created", *createdDomainNameInstance.Name))
			cli.Complete(fmt.Sprintf("domain name %s created", *domainNameConfig.DomainName.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new domain name",
	SilenceUsage: true,
	Use:          "domain-name",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameCmd)

	CreateDomainNameCmd.Flags().StringVarP(
		&createDomainNameConfigPath,
		"config", "c", "", "Path to file with domain name config.",
	)
	CreateDomainNameCmd.MarkFlagRequired("config")
	CreateDomainNameCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateDomainNameCmd.Flags().StringVarP(
		&createDomainNameVersion,
		"version", "v", "v0", "Version of domain names object to create. One of: [v0]",
	)
}

var (
	deleteDomainNameConfigPath string
	deleteDomainNameName       string
	deleteDomainNameVersion    string
)

// DeleteDomainNameCmd represents the domain-name command
var DeleteDomainNameCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name --name some-domain-name",
	Long:    "Delete an existing domain name. This command deletes an existing domain name definition and domain name instance based on the domain name config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if deleteDomainNameConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		// read domain name config
		configContent, err := os.ReadFile(deleteDomainNameConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// delete domain name based on version
		switch deleteDomainNameVersion {
		case "v0":
			var domainNameConfig config_v0.DomainNameConfig
			if err := yaml.UnmarshalStrict(configContent, &domainNameConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// delete domain name
			domainName := domainNameConfig.DomainName
			_, _, err = domainName.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete domain name", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("domain name definition %s deleted", *domainName.Name))
			cli.Info(fmt.Sprintf("domain name instance %s deleted", *domainName.Name))
			cli.Complete(fmt.Sprintf("domain name %s deleted", *domainNameConfig.DomainName.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing domain name",
	SilenceUsage: true,
	Use:          "domain-name",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameCmd)

	DeleteDomainNameCmd.Flags().StringVarP(
		&deleteDomainNameConfigPath,
		"config", "c", "", "Path to file with domain name config.",
	)
	DeleteDomainNameCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteDomainNameCmd.Flags().StringVarP(
		&deleteDomainNameVersion,
		"version", "v", "v0", "Version of domain names object to delete. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// DomainNameInstance
///////////////////////////////////////////////////////////////////////////////

var getDomainNameInstanceVersion string

// GetDomainNameInstancesCmd represents the domain-name-instance command
var GetDomainNameInstancesCmd = &cobra.Command{
	Example: "  tptctl get domain-name-instances",
	Long:    "Get domain name instances from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getDomainNameInstanceVersion {
		case "v0":
			// get domain name instances
			domainNameInstances, err := client_v0.GetDomainNameInstances(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve domain name instances", err)
				os.Exit(1)
			}

			// write the output
			if len(*domainNameInstances) == 0 {
				cli.Info(fmt.Sprintf(
					"No domain name instances currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0DomainNameInstancesCmd(
				domainNameInstances,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get domain name instances from the system",
	SilenceUsage: true,
	Use:          "domain-name-instances",
}

func init() {
	GetCmd.AddCommand(GetDomainNameInstancesCmd)

	GetDomainNameInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetDomainNameInstancesCmd.Flags().StringVarP(
		&getDomainNameInstanceVersion,
		"version", "v", "v0", "Version of domain name instances object to retrieve. One of: [v0]",
	)
}

var (
	createDomainNameInstanceConfigPath string
	createDomainNameInstanceVersion    string
)

// CreateDomainNameInstanceCmd represents the domain-name-instance command
var CreateDomainNameInstanceCmd = &cobra.Command{
	Example: "  tptctl create domain-name-instance --config path/to/config.yaml",
	Long:    "Create a new domain name instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read domain name instance config
		configContent, err := os.ReadFile(createDomainNameInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create domain name instance based on version
		switch createDomainNameInstanceVersion {
		case "v0":
			var domainNameInstanceConfig config_v0.DomainNameInstanceConfig
			if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create domain name instance
			domainNameInstance := domainNameInstanceConfig.DomainNameInstance
			createdDomainNameInstance, err := domainNameInstance.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create domain name instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("domain name instance %s created", *createdDomainNameInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameInstanceCmd)

	CreateDomainNameInstanceCmd.Flags().StringVarP(
		&createDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.",
	)
	CreateDomainNameInstanceCmd.MarkFlagRequired("config")
	CreateDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateDomainNameInstanceCmd.Flags().StringVarP(
		&createDomainNameInstanceVersion,
		"version", "v", "v0", "Version of domain name instances object to create. One of: [v0]",
	)
}

var (
	deleteDomainNameInstanceConfigPath string
	deleteDomainNameInstanceName       string
	deleteDomainNameInstanceVersion    string
)

// DeleteDomainNameInstanceCmd represents the domain-name-instance command
var DeleteDomainNameInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name-instance --name some-domain-name-instance",
	Long:    "Delete an existing domain name instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteDomainNameInstanceConfigPath,
			deleteDomainNameInstanceName,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete domain name instance based on version
		switch deleteDomainNameInstanceVersion {
		case "v0":
			var domainNameInstanceConfig config_v0.DomainNameInstanceConfig
			if deleteDomainNameInstanceConfigPath != "" {
				// load domain name instance config
				configContent, err := os.ReadFile(deleteDomainNameInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				domainNameInstanceConfig = config_v0.DomainNameInstanceConfig{
					DomainNameInstance: config_v0.DomainNameInstanceValues{
						Name: &deleteDomainNameInstanceName,
					},
				}
			}

			// delete domain name instance
			domainNameInstance := domainNameInstanceConfig.DomainNameInstance
			deletedDomainNameInstance, err := domainNameInstance.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete domain name instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("domain name instance %s deleted", *deletedDomainNameInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameInstanceCmd)

	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&deleteDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.",
	)
	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&deleteDomainNameInstanceName,
		"name", "n", "", "Name of domain name instance.",
	)
	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&deleteDomainNameInstanceVersion,
		"version", "v", "v0", "Version of domain name instances object to delete. One of: [v0]",
	)
}

var (
	describeDomainNameInstanceConfigPath string
	describeDomainNameInstanceName       string
	describeDomainNameInstanceField      string
	describeDomainNameInstanceOutput     string
	describeDomainNameInstanceVersion    string
)

// DescribeDomainNameInstanceCmd representes the domain-name-instance command
var DescribeDomainNameInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance\n\n  # Get JSON output for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance -o json\n\n  # Get the value of the Name field for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance -f Name ",
	Long:    "Describe a domain name instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeDomainNameInstanceConfigPath,
			describeDomainNameInstanceName,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeDomainNameInstanceOutput,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get domain name instance
		var domainNameInstance interface{}
		switch describeDomainNameInstanceVersion {
		case "v0":
			// load domain name instance config by name or config file
			var domainNameInstanceConfig config_v0.DomainNameInstanceConfig
			if describeDomainNameInstanceConfigPath != "" {
				configContent, err := os.ReadFile(describeDomainNameInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				domainNameInstanceConfig = config_v0.DomainNameInstanceConfig{
					DomainNameInstance: config_v0.DomainNameInstanceValues{
						Name: &describeDomainNameInstanceName,
					},
				}
			}

			// get domain name instance object by name
			obj, err := client_v0.GetDomainNameInstanceByName(
				apiClient,
				apiEndpoint,
				*domainNameInstanceConfig.DomainNameInstance.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve domain name instance details", err)
				os.Exit(1)
			}
			domainNameInstance = obj

			// return plain output if requested
			if describeDomainNameInstanceOutput == "plain" {
				if err := outputDescribev0DomainNameInstanceCmd(
					domainNameInstance.(*api_v0.DomainNameInstance),
					&domainNameInstanceConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe domain name instance", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeDomainNameInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				domainNameInstance,
				describeDomainNameInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from domain name instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(domainNameInstance, describeDomainNameInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeDomainNameInstanceOutput {
		case "json":
			// redact encrypted values
			redactedDomainNameInstance := encryption.RedactEncryptedValues(domainNameInstance)

			// marshal to JSON then print
			domainNameInstanceJson, err := json.MarshalIndent(redactedDomainNameInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedDomainNameInstance := encryption.RedactEncryptedValues(domainNameInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			domainNameInstanceJson, err := json.MarshalIndent(redactedDomainNameInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name instance into JSON", err)
				os.Exit(1)
			}
			domainNameInstanceYaml, err := ghodss_yaml.JSONToYAML(domainNameInstanceJson)
			if err != nil {
				cli.Error("failed to convert domain name instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameInstanceYaml))
		}
	},
	Short:        "Describe a domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeDomainNameInstanceCmd)

	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.",
	)
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceName,
		"name", "n", "", "Name of domain name instance.",
	)
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceVersion,
		"version", "v", "v0", "Version of domain name instances object to describe. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// GatewayDefinition
///////////////////////////////////////////////////////////////////////////////

var getGatewayDefinitionVersion string

// GetGatewayDefinitionsCmd represents the gateway-definition command
var GetGatewayDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get gateway-definitions",
	Long:    "Get gateway definitions from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getGatewayDefinitionVersion {
		case "v0":
			// get gateway definitions
			gatewayDefinitions, err := client_v0.GetGatewayDefinitions(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve gateway definitions", err)
				os.Exit(1)
			}

			// write the output
			if len(*gatewayDefinitions) == 0 {
				cli.Info(fmt.Sprintf(
					"No gateway definitions currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0GatewayDefinitionsCmd(
				gatewayDefinitions,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get gateway definitions from the system",
	SilenceUsage: true,
	Use:          "gateway-definitions",
}

func init() {
	GetCmd.AddCommand(GetGatewayDefinitionsCmd)

	GetGatewayDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetGatewayDefinitionsCmd.Flags().StringVarP(
		&getGatewayDefinitionVersion,
		"version", "v", "v0", "Version of gateway definitions object to retrieve. One of: [v0]",
	)
}

var (
	createGatewayDefinitionConfigPath string
	createGatewayDefinitionVersion    string
)

// CreateGatewayDefinitionCmd represents the gateway-definition command
var CreateGatewayDefinitionCmd = &cobra.Command{
	Example: "  tptctl create gateway-definition --config path/to/config.yaml",
	Long:    "Create a new gateway definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read gateway definition config
		configContent, err := os.ReadFile(createGatewayDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create gateway definition based on version
		switch createGatewayDefinitionVersion {
		case "v0":
			var gatewayDefinitionConfig config_v0.GatewayDefinitionConfig
			if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create gateway definition
			gatewayDefinition := gatewayDefinitionConfig.GatewayDefinition
			createdGatewayDefinition, err := gatewayDefinition.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create gateway definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("gateway definition %s created", *createdGatewayDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayDefinitionCmd)

	CreateGatewayDefinitionCmd.Flags().StringVarP(
		&createGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.",
	)
	CreateGatewayDefinitionCmd.MarkFlagRequired("config")
	CreateGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateGatewayDefinitionCmd.Flags().StringVarP(
		&createGatewayDefinitionVersion,
		"version", "v", "v0", "Version of gateway definitions object to create. One of: [v0]",
	)
}

var (
	deleteGatewayDefinitionConfigPath string
	deleteGatewayDefinitionName       string
	deleteGatewayDefinitionVersion    string
)

// DeleteGatewayDefinitionCmd represents the gateway-definition command
var DeleteGatewayDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway-definition --name some-gateway-definition",
	Long:    "Delete an existing gateway definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteGatewayDefinitionConfigPath,
			deleteGatewayDefinitionName,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete gateway definition based on version
		switch deleteGatewayDefinitionVersion {
		case "v0":
			var gatewayDefinitionConfig config_v0.GatewayDefinitionConfig
			if deleteGatewayDefinitionConfigPath != "" {
				// load gateway definition config
				configContent, err := os.ReadFile(deleteGatewayDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				gatewayDefinitionConfig = config_v0.GatewayDefinitionConfig{
					GatewayDefinition: config_v0.GatewayDefinitionValues{
						Name: &deleteGatewayDefinitionName,
					},
				}
			}

			// delete gateway definition
			gatewayDefinition := gatewayDefinitionConfig.GatewayDefinition
			deletedGatewayDefinition, err := gatewayDefinition.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete gateway definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("gateway definition %s deleted", *deletedGatewayDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayDefinitionCmd)

	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&deleteGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.",
	)
	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&deleteGatewayDefinitionName,
		"name", "n", "", "Name of gateway definition.",
	)
	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&deleteGatewayDefinitionVersion,
		"version", "v", "v0", "Version of gateway definitions object to delete. One of: [v0]",
	)
}

var (
	describeGatewayDefinitionConfigPath string
	describeGatewayDefinitionName       string
	describeGatewayDefinitionField      string
	describeGatewayDefinitionOutput     string
	describeGatewayDefinitionVersion    string
)

// DescribeGatewayDefinitionCmd representes the gateway-definition command
var DescribeGatewayDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition\n\n  # Get JSON output for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition -o json\n\n  # Get the value of the Name field for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition -f Name ",
	Long:    "Describe a gateway definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeGatewayDefinitionConfigPath,
			describeGatewayDefinitionName,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeGatewayDefinitionOutput,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get gateway definition
		var gatewayDefinition interface{}
		switch describeGatewayDefinitionVersion {
		case "v0":
			// load gateway definition config by name or config file
			var gatewayDefinitionConfig config_v0.GatewayDefinitionConfig
			if describeGatewayDefinitionConfigPath != "" {
				configContent, err := os.ReadFile(describeGatewayDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				gatewayDefinitionConfig = config_v0.GatewayDefinitionConfig{
					GatewayDefinition: config_v0.GatewayDefinitionValues{
						Name: &describeGatewayDefinitionName,
					},
				}
			}

			// get gateway definition object by name
			obj, err := client_v0.GetGatewayDefinitionByName(
				apiClient,
				apiEndpoint,
				*gatewayDefinitionConfig.GatewayDefinition.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve gateway definition details", err)
				os.Exit(1)
			}
			gatewayDefinition = obj

			// return plain output if requested
			if describeGatewayDefinitionOutput == "plain" {
				if err := outputDescribev0GatewayDefinitionCmd(
					gatewayDefinition.(*api_v0.GatewayDefinition),
					&gatewayDefinitionConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe gateway definition", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeGatewayDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				gatewayDefinition,
				describeGatewayDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from gateway definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(gatewayDefinition, describeGatewayDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeGatewayDefinitionOutput {
		case "json":
			// redact encrypted values
			redactedGatewayDefinition := encryption.RedactEncryptedValues(gatewayDefinition)

			// marshal to JSON then print
			gatewayDefinitionJson, err := json.MarshalIndent(redactedGatewayDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedGatewayDefinition := encryption.RedactEncryptedValues(gatewayDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			gatewayDefinitionJson, err := json.MarshalIndent(redactedGatewayDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway definition into JSON", err)
				os.Exit(1)
			}
			gatewayDefinitionYaml, err := ghodss_yaml.JSONToYAML(gatewayDefinitionJson)
			if err != nil {
				cli.Error("failed to convert gateway definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayDefinitionYaml))
		}
	},
	Short:        "Describe a gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeGatewayDefinitionCmd)

	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.",
	)
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionName,
		"name", "n", "", "Name of gateway definition.",
	)
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionVersion,
		"version", "v", "v0", "Version of gateway definitions object to describe. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// Gateway
///////////////////////////////////////////////////////////////////////////////

// GetGatewaysCmd represents the gateway command
var GetGatewaysCmd = &cobra.Command{
	Example: "  tptctl get gateways",
	Long:    "Get gateways from the system.\n\nA gateway is a simple abstraction of gateway definitions and gateway instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		// get gateways
		v0gatewayInstances, err := client_v0.GetGatewayInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve gateway instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*v0gatewayInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No gateway instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetGatewaysCmd(
			v0gatewayInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get gateways from the system",
	SilenceUsage: true,
	Use:          "gateways",
}

func init() {
	GetCmd.AddCommand(GetGatewaysCmd)

	GetGatewaysCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	createGatewayConfigPath string
	createGatewayVersion    string
)

// CreateGatewayCmd represents the gateway command
var CreateGatewayCmd = &cobra.Command{
	Example: "  tptctl create gateway --config path/to/config.yaml",
	Long:    "Create a new gateway. This command creates a new gateway definition and gateway instance based on the gateway config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read gateway config
		configContent, err := os.ReadFile(createGatewayConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// create gateway based on version
		switch createGatewayVersion {
		case "v0":
			var gatewayConfig config_v0.GatewayConfig
			if err := yaml.UnmarshalStrict(configContent, &gatewayConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create gateway
			gateway := gatewayConfig.Gateway
			createdGatewayDefinition, createdGatewayInstance, err := gateway.Create(
				apiClient,
				apiEndpoint,
			)
			if err != nil {
				cli.Error("failed to create gateway", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("gateway definition %s created", *createdGatewayDefinition.Name))
			cli.Info(fmt.Sprintf("gateway instance %s created", *createdGatewayInstance.Name))
			cli.Complete(fmt.Sprintf("gateway %s created", *gatewayConfig.Gateway.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new gateway",
	SilenceUsage: true,
	Use:          "gateway",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayCmd)

	CreateGatewayCmd.Flags().StringVarP(
		&createGatewayConfigPath,
		"config", "c", "", "Path to file with gateway config.",
	)
	CreateGatewayCmd.MarkFlagRequired("config")
	CreateGatewayCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateGatewayCmd.Flags().StringVarP(
		&createGatewayVersion,
		"version", "v", "v0", "Version of gateways object to create. One of: [v0]",
	)
}

var (
	deleteGatewayConfigPath string
	deleteGatewayName       string
	deleteGatewayVersion    string
)

// DeleteGatewayCmd represents the gateway command
var DeleteGatewayCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway --name some-gateway",
	Long:    "Delete an existing gateway. This command deletes an existing gateway definition and gateway instance based on the gateway config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if deleteGatewayConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		// read gateway config
		configContent, err := os.ReadFile(deleteGatewayConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// delete gateway based on version
		switch deleteGatewayVersion {
		case "v0":
			var gatewayConfig config_v0.GatewayConfig
			if err := yaml.UnmarshalStrict(configContent, &gatewayConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// delete gateway
			gateway := gatewayConfig.Gateway
			_, _, err = gateway.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete gateway", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("gateway definition %s deleted", *gateway.Name))
			cli.Info(fmt.Sprintf("gateway instance %s deleted", *gateway.Name))
			cli.Complete(fmt.Sprintf("gateway %s deleted", *gatewayConfig.Gateway.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing gateway",
	SilenceUsage: true,
	Use:          "gateway",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayCmd)

	DeleteGatewayCmd.Flags().StringVarP(
		&deleteGatewayConfigPath,
		"config", "c", "", "Path to file with gateway config.",
	)
	DeleteGatewayCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteGatewayCmd.Flags().StringVarP(
		&deleteGatewayVersion,
		"version", "v", "v0", "Version of gateways object to delete. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// GatewayInstance
///////////////////////////////////////////////////////////////////////////////

var getGatewayInstanceVersion string

// GetGatewayInstancesCmd represents the gateway-instance command
var GetGatewayInstancesCmd = &cobra.Command{
	Example: "  tptctl get gateway-instances",
	Long:    "Get gateway instances from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getGatewayInstanceVersion {
		case "v0":
			// get gateway instances
			gatewayInstances, err := client_v0.GetGatewayInstances(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve gateway instances", err)
				os.Exit(1)
			}

			// write the output
			if len(*gatewayInstances) == 0 {
				cli.Info(fmt.Sprintf(
					"No gateway instances currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0GatewayInstancesCmd(
				gatewayInstances,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get gateway instances from the system",
	SilenceUsage: true,
	Use:          "gateway-instances",
}

func init() {
	GetCmd.AddCommand(GetGatewayInstancesCmd)

	GetGatewayInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetGatewayInstancesCmd.Flags().StringVarP(
		&getGatewayInstanceVersion,
		"version", "v", "v0", "Version of gateway instances object to retrieve. One of: [v0]",
	)
}

var (
	createGatewayInstanceConfigPath string
	createGatewayInstanceVersion    string
)

// CreateGatewayInstanceCmd represents the gateway-instance command
var CreateGatewayInstanceCmd = &cobra.Command{
	Example: "  tptctl create gateway-instance --config path/to/config.yaml",
	Long:    "Create a new gateway instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read gateway instance config
		configContent, err := os.ReadFile(createGatewayInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create gateway instance based on version
		switch createGatewayInstanceVersion {
		case "v0":
			var gatewayInstanceConfig config_v0.GatewayInstanceConfig
			if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create gateway instance
			gatewayInstance := gatewayInstanceConfig.GatewayInstance
			createdGatewayInstance, err := gatewayInstance.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create gateway instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("gateway instance %s created", *createdGatewayInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayInstanceCmd)

	CreateGatewayInstanceCmd.Flags().StringVarP(
		&createGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.",
	)
	CreateGatewayInstanceCmd.MarkFlagRequired("config")
	CreateGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateGatewayInstanceCmd.Flags().StringVarP(
		&createGatewayInstanceVersion,
		"version", "v", "v0", "Version of gateway instances object to create. One of: [v0]",
	)
}

var (
	deleteGatewayInstanceConfigPath string
	deleteGatewayInstanceName       string
	deleteGatewayInstanceVersion    string
)

// DeleteGatewayInstanceCmd represents the gateway-instance command
var DeleteGatewayInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway-instance --name some-gateway-instance",
	Long:    "Delete an existing gateway instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteGatewayInstanceConfigPath,
			deleteGatewayInstanceName,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete gateway instance based on version
		switch deleteGatewayInstanceVersion {
		case "v0":
			var gatewayInstanceConfig config_v0.GatewayInstanceConfig
			if deleteGatewayInstanceConfigPath != "" {
				// load gateway instance config
				configContent, err := os.ReadFile(deleteGatewayInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				gatewayInstanceConfig = config_v0.GatewayInstanceConfig{
					GatewayInstance: config_v0.GatewayInstanceValues{
						Name: &deleteGatewayInstanceName,
					},
				}
			}

			// delete gateway instance
			gatewayInstance := gatewayInstanceConfig.GatewayInstance
			deletedGatewayInstance, err := gatewayInstance.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete gateway instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("gateway instance %s deleted", *deletedGatewayInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayInstanceCmd)

	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&deleteGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.",
	)
	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&deleteGatewayInstanceName,
		"name", "n", "", "Name of gateway instance.",
	)
	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&deleteGatewayInstanceVersion,
		"version", "v", "v0", "Version of gateway instances object to delete. One of: [v0]",
	)
}

var (
	describeGatewayInstanceConfigPath string
	describeGatewayInstanceName       string
	describeGatewayInstanceField      string
	describeGatewayInstanceOutput     string
	describeGatewayInstanceVersion    string
)

// DescribeGatewayInstanceCmd representes the gateway-instance command
var DescribeGatewayInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance\n\n  # Get JSON output for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance -o json\n\n  # Get the value of the Name field for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance -f Name ",
	Long:    "Describe a gateway instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeGatewayInstanceConfigPath,
			describeGatewayInstanceName,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeGatewayInstanceOutput,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get gateway instance
		var gatewayInstance interface{}
		switch describeGatewayInstanceVersion {
		case "v0":
			// load gateway instance config by name or config file
			var gatewayInstanceConfig config_v0.GatewayInstanceConfig
			if describeGatewayInstanceConfigPath != "" {
				configContent, err := os.ReadFile(describeGatewayInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				gatewayInstanceConfig = config_v0.GatewayInstanceConfig{
					GatewayInstance: config_v0.GatewayInstanceValues{
						Name: &describeGatewayInstanceName,
					},
				}
			}

			// get gateway instance object by name
			obj, err := client_v0.GetGatewayInstanceByName(
				apiClient,
				apiEndpoint,
				*gatewayInstanceConfig.GatewayInstance.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve gateway instance details", err)
				os.Exit(1)
			}
			gatewayInstance = obj

			// return plain output if requested
			if describeGatewayInstanceOutput == "plain" {
				if err := outputDescribev0GatewayInstanceCmd(
					gatewayInstance.(*api_v0.GatewayInstance),
					&gatewayInstanceConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe gateway instance", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeGatewayInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				gatewayInstance,
				describeGatewayInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from gateway instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(gatewayInstance, describeGatewayInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeGatewayInstanceOutput {
		case "json":
			// redact encrypted values
			redactedGatewayInstance := encryption.RedactEncryptedValues(gatewayInstance)

			// marshal to JSON then print
			gatewayInstanceJson, err := json.MarshalIndent(redactedGatewayInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedGatewayInstance := encryption.RedactEncryptedValues(gatewayInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			gatewayInstanceJson, err := json.MarshalIndent(redactedGatewayInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway instance into JSON", err)
				os.Exit(1)
			}
			gatewayInstanceYaml, err := ghodss_yaml.JSONToYAML(gatewayInstanceJson)
			if err != nil {
				cli.Error("failed to convert gateway instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayInstanceYaml))
		}
	},
	Short:        "Describe a gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeGatewayInstanceCmd)

	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.",
	)
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceName,
		"name", "n", "", "Name of gateway instance.",
	)
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceVersion,
		"version", "v", "v0", "Version of gateway instances object to describe. One of: [v0]",
	)
}
