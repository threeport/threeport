// generated by 'threeport-sdk codegen api-model' - do not edit

package cmd

import (
	"encoding/json"
	"errors"
	"fmt"
	ghodss_yaml "github.com/ghodss/yaml"
	cobra "github.com/spf13/cobra"
	cli "github.com/threeport/threeport/pkg/cli/v0"
	client "github.com/threeport/threeport/pkg/client/v0"
	config "github.com/threeport/threeport/pkg/config/v0"
	encryption "github.com/threeport/threeport/pkg/encryption/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	yaml "gopkg.in/yaml.v2"
	"os"
)

///////////////////////////////////////////////////////////////////////////////
// Gateway
///////////////////////////////////////////////////////////////////////////////

// GetGatewaysCmd represents the gateway command
var GetGatewaysCmd = &cobra.Command{
	Example: "  tptctl get gateways",
	Long:    "Get gateways from the system.\n\nA gateway is a simple abstraction of gateway definitions and gateway instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get gateways
		gatewayInstances, err := client.GetGatewayInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve gateway instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*gatewayInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No gateway instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetGatewaysCmd(
			gatewayInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get gateways from the system",
	SilenceUsage: true,
	Use:          "gateways",
}

func init() {
	GetCmd.AddCommand(GetGatewaysCmd)

	GetGatewaysCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createGatewayConfigPath string

// CreateGatewayCmd represents the gateway command
var CreateGatewayCmd = &cobra.Command{
	Example: "  tptctl create gateway --config path/to/config.yaml",
	Long:    "Create a new gateway. This command creates a new gateway definition and gateway instance based on the gateway config.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load gateway config
		configContent, err := os.ReadFile(createGatewayConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var gatewayConfig config.GatewayConfig
		if err := yaml.UnmarshalStrict(configContent, &gatewayConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create gateway
		gateway := gatewayConfig.Gateway
		createdGatewayDefinition, createdGatewayInstance, err := gateway.Create(
			apiClient,
			apiEndpoint,
		)
		if err != nil {
			cli.Error("failed to create gateway", err)
			os.Exit(1)
		}

		cli.Info(fmt.Sprintf("gateway definition %s created", *createdGatewayDefinition.Name))
		cli.Info(fmt.Sprintf("gateway instance %s created", *createdGatewayInstance.Name))
		cli.Complete(fmt.Sprintf("gateway %s created", gatewayConfig.Gateway.Name))
	},
	Short:        "Create a new gateway",
	SilenceUsage: true,
	Use:          "gateway",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayCmd)

	CreateGatewayCmd.Flags().StringVarP(
		&createGatewayConfigPath,
		"config", "c", "", "Path to file with gateway config.",
	)
	CreateGatewayCmd.MarkFlagRequired("config")
	CreateGatewayCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteGatewayConfigPath string
	deleteGatewayName       string
)

// DeleteGatewayCmd represents the gateway command
var DeleteGatewayCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway --name some-gateway",
	Long:    "Delete an existing gateway. This command deletes an existing gateway definition and gateway instance based on the gateway config.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if deleteGatewayConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		var gatewayConfig config.GatewayConfig
		// load gateway config
		configContent, err := os.ReadFile(deleteGatewayConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		if err := yaml.UnmarshalStrict(configContent, &gatewayConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// delete gateway
		gateway := gatewayConfig.Gateway
		_, _, err = gateway.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete gateway", err)
			os.Exit(1)
		}

		cli.Info(fmt.Sprintf("gateway definition %s deleted", gateway.Name))
		cli.Info(fmt.Sprintf("gateway instance %s deleted", gateway.Name))
		cli.Complete(fmt.Sprintf("gateway %s deleted", gatewayConfig.Gateway.Name))
	},
	Short:        "Delete an existing gateway",
	SilenceUsage: true,
	Use:          "gateway",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayCmd)

	DeleteGatewayCmd.Flags().StringVarP(
		&deleteGatewayConfigPath,
		"config", "c", "", "Path to file with gateway config.",
	)
	DeleteGatewayCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

///////////////////////////////////////////////////////////////////////////////
// GatewayDefinition
///////////////////////////////////////////////////////////////////////////////

// GetGatewayDefinitionsCmd represents the gateway-definition command
var GetGatewayDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get gateway-definitions",
	Long:    "Get gateway definitions from the system.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get gateway definitions
		gatewayDefinitions, err := client.GetGatewayDefinitions(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve gateway definitions", err)
			os.Exit(1)
		}

		// write the output
		if len(*gatewayDefinitions) == 0 {
			cli.Info(fmt.Sprintf(
				"No gateway definitions currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetGatewayDefinitionsCmd(
			gatewayDefinitions,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output", err)
			os.Exit(0)
		}
	},
	Short:        "Get gateway definitions from the system",
	SilenceUsage: true,
	Use:          "gateway-definitions",
}

func init() {
	GetCmd.AddCommand(GetGatewayDefinitionsCmd)

	GetGatewayDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createGatewayDefinitionConfigPath string

// CreateGatewayDefinitionCmd represents the gateway-definition command
var CreateGatewayDefinitionCmd = &cobra.Command{
	Example: "  tptctl create gateway-definition --config path/to/config.yaml",
	Long:    "Create a new gateway definition.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load gateway definition config
		configContent, err := os.ReadFile(createGatewayDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var gatewayDefinitionConfig config.GatewayDefinitionConfig
		if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create gateway definition
		gatewayDefinition := gatewayDefinitionConfig.GatewayDefinition
		createdGatewayDefinition, err := gatewayDefinition.Create(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to create gateway definition", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("gateway definition %s created", *createdGatewayDefinition.Name))
	},
	Short:        "Create a new gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayDefinitionCmd)

	CreateGatewayDefinitionCmd.Flags().StringVarP(
		&createGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.",
	)
	CreateGatewayDefinitionCmd.MarkFlagRequired("config")
	CreateGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteGatewayDefinitionConfigPath string
	deleteGatewayDefinitionName       string
)

// DeleteGatewayDefinitionCmd represents the gateway-definition command
var DeleteGatewayDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway-definition --name some-gateway-definition",
	Long:    "Delete an existing gateway definition.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteGatewayDefinitionConfigPath,
			deleteGatewayDefinitionName,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		var gatewayDefinitionConfig config.GatewayDefinitionConfig
		if deleteGatewayDefinitionConfigPath != "" {
			// load gateway definition config
			configContent, err := os.ReadFile(deleteGatewayDefinitionConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			gatewayDefinitionConfig = config.GatewayDefinitionConfig{
				GatewayDefinition: config.GatewayDefinitionValues{
					Name: deleteGatewayDefinitionName,
				},
			}
		}

		// delete gateway definition
		gatewayDefinition := gatewayDefinitionConfig.GatewayDefinition
		deletedGatewayDefinition, err := gatewayDefinition.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete gateway definition", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("gateway definition %s deleted", *deletedGatewayDefinition.Name))
	},
	Short:        "Delete an existing gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayDefinitionCmd)

	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&deleteGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.",
	)
	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&deleteGatewayDefinitionName,
		"name", "n", "", "Name of gateway definition.",
	)
	DeleteGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	describeGatewayDefinitionConfigPath string
	describeGatewayDefinitionName       string
	describeGatewayDefinitionField      string
	describeGatewayDefinitionOutput     string
)

// DescribeGatewayDefinitionCmd representes the gateway-definition command
var DescribeGatewayDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition\n\n  # Get JSON output for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition -o json\n\n  # Get the value of the Name field for a gateway definition\n  tptctl describe gateway-definition -n some-gateway-definition -f Name ",
	Long:    "Describe a gateway definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeGatewayDefinitionConfigPath,
			describeGatewayDefinitionName,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeGatewayDefinitionOutput,
			"gateway definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// load gateway definition config by name or config file
		var gatewayDefinitionConfig config.GatewayDefinitionConfig
		if describeGatewayDefinitionConfigPath != "" {
			configContent, err := os.ReadFile(describeGatewayDefinitionConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &gatewayDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			gatewayDefinitionConfig = config.GatewayDefinitionConfig{
				GatewayDefinition: config.GatewayDefinitionValues{
					Name: describeGatewayDefinitionName,
				},
			}
		}

		// get gateway definition
		gatewayDefinition, err := client.GetGatewayDefinitionByName(
			apiClient,
			apiEndpoint,
			gatewayDefinitionConfig.GatewayDefinition.Name,
		)
		if err != nil {
			cli.Error("failed to retrieve gateway definition details", err)
			os.Exit(1)
		}

		// return field value if specified
		if describeGatewayDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				gatewayDefinition,
				describeGatewayDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from gateway definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(gatewayDefinition, describeGatewayDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		switch describeGatewayDefinitionOutput {
		case "plain":
			// produce plain object description output
			if err := outputDescribeGatewayDefinitionCmd(
				gatewayDefinition,
				&gatewayDefinitionConfig,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to describe gateway definition", err)
				os.Exit(1)
			}
		case "json":
			// redact encrypted values
			redactedGatewayDefinition := encryption.RedactEncryptedValues(gatewayDefinition)

			// marshal to JSON then print
			gatewayDefinitionJson, err := json.MarshalIndent(redactedGatewayDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedGatewayDefinition := encryption.RedactEncryptedValues(gatewayDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			gatewayDefinitionJson, err := json.MarshalIndent(redactedGatewayDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway definition into JSON", err)
				os.Exit(1)
			}
			gatewayDefinitionYaml, err := ghodss_yaml.JSONToYAML(gatewayDefinitionJson)
			if err != nil {
				cli.Error("failed to convert gateway definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayDefinitionYaml))
		}
	},
	Short:        "Describe a gateway definition",
	SilenceUsage: true,
	Use:          "gateway-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeGatewayDefinitionCmd)

	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionConfigPath,
		"config", "c", "", "Path to file with gateway definition config.")
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionName,
		"name", "n", "", "Name of gateway definition.")
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object")
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&describeGatewayDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.")
	DescribeGatewayDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

///////////////////////////////////////////////////////////////////////////////
// GatewayInstance
///////////////////////////////////////////////////////////////////////////////

// GetGatewayInstancesCmd represents the gateway-instance command
var GetGatewayInstancesCmd = &cobra.Command{
	Example: "  tptctl get gateway-instances",
	Long:    "Get gateway instances from the system.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get gateway instances
		gatewayInstances, err := client.GetGatewayInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve gateway instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*gatewayInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No gateway instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetGatewayInstancesCmd(
			gatewayInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output", err)
			os.Exit(0)
		}
	},
	Short:        "Get gateway instances from the system",
	SilenceUsage: true,
	Use:          "gateway-instances",
}

func init() {
	GetCmd.AddCommand(GetGatewayInstancesCmd)

	GetGatewayInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createGatewayInstanceConfigPath string

// CreateGatewayInstanceCmd represents the gateway-instance command
var CreateGatewayInstanceCmd = &cobra.Command{
	Example: "  tptctl create gateway-instance --config path/to/config.yaml",
	Long:    "Create a new gateway instance.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load gateway instance config
		configContent, err := os.ReadFile(createGatewayInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var gatewayInstanceConfig config.GatewayInstanceConfig
		if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create gateway instance
		gatewayInstance := gatewayInstanceConfig.GatewayInstance
		createdGatewayInstance, err := gatewayInstance.Create(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to create gateway instance", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("gateway instance %s created", *createdGatewayInstance.Name))
	},
	Short:        "Create a new gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	CreateCmd.AddCommand(CreateGatewayInstanceCmd)

	CreateGatewayInstanceCmd.Flags().StringVarP(
		&createGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.",
	)
	CreateGatewayInstanceCmd.MarkFlagRequired("config")
	CreateGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteGatewayInstanceConfigPath string
	deleteGatewayInstanceName       string
)

// DeleteGatewayInstanceCmd represents the gateway-instance command
var DeleteGatewayInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete gateway-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete gateway-instance --name some-gateway-instance",
	Long:    "Delete an existing gateway instance.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteGatewayInstanceConfigPath,
			deleteGatewayInstanceName,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		var gatewayInstanceConfig config.GatewayInstanceConfig
		if deleteGatewayInstanceConfigPath != "" {
			// load gateway instance config
			configContent, err := os.ReadFile(deleteGatewayInstanceConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			gatewayInstanceConfig = config.GatewayInstanceConfig{
				GatewayInstance: config.GatewayInstanceValues{
					Name: deleteGatewayInstanceName,
				},
			}
		}

		// delete gateway instance
		gatewayInstance := gatewayInstanceConfig.GatewayInstance
		deletedGatewayInstance, err := gatewayInstance.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete gateway instance", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("gateway instance %s deleted", *deletedGatewayInstance.Name))
	},
	Short:        "Delete an existing gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteGatewayInstanceCmd)

	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&deleteGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.",
	)
	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&deleteGatewayInstanceName,
		"name", "n", "", "Name of gateway instance.",
	)
	DeleteGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	describeGatewayInstanceConfigPath string
	describeGatewayInstanceName       string
	describeGatewayInstanceField      string
	describeGatewayInstanceOutput     string
)

// DescribeGatewayInstanceCmd representes the gateway-instance command
var DescribeGatewayInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance\n\n  # Get JSON output for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance -o json\n\n  # Get the value of the Name field for a gateway instance\n  tptctl describe gateway-instance -n some-gateway-instance -f Name ",
	Long:    "Describe a gateway instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeGatewayInstanceConfigPath,
			describeGatewayInstanceName,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeGatewayInstanceOutput,
			"gateway instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// load gateway instance config by name or config file
		var gatewayInstanceConfig config.GatewayInstanceConfig
		if describeGatewayInstanceConfigPath != "" {
			configContent, err := os.ReadFile(describeGatewayInstanceConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &gatewayInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			gatewayInstanceConfig = config.GatewayInstanceConfig{
				GatewayInstance: config.GatewayInstanceValues{
					Name: describeGatewayInstanceName,
				},
			}
		}

		// get gateway instance
		gatewayInstance, err := client.GetGatewayInstanceByName(
			apiClient,
			apiEndpoint,
			gatewayInstanceConfig.GatewayInstance.Name,
		)
		if err != nil {
			cli.Error("failed to retrieve gateway instance details", err)
			os.Exit(1)
		}

		// return field value if specified
		if describeGatewayInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				gatewayInstance,
				describeGatewayInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from gateway instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(gatewayInstance, describeGatewayInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		switch describeGatewayInstanceOutput {
		case "plain":
			// produce plain object description output
			if err := outputDescribeGatewayInstanceCmd(
				gatewayInstance,
				&gatewayInstanceConfig,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to describe gateway instance", err)
				os.Exit(1)
			}
		case "json":
			// redact encrypted values
			redactedGatewayInstance := encryption.RedactEncryptedValues(gatewayInstance)

			// marshal to JSON then print
			gatewayInstanceJson, err := json.MarshalIndent(redactedGatewayInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedGatewayInstance := encryption.RedactEncryptedValues(gatewayInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			gatewayInstanceJson, err := json.MarshalIndent(redactedGatewayInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal gateway instance into JSON", err)
				os.Exit(1)
			}
			gatewayInstanceYaml, err := ghodss_yaml.JSONToYAML(gatewayInstanceJson)
			if err != nil {
				cli.Error("failed to convert gateway instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(gatewayInstanceYaml))
		}
	},
	Short:        "Describe a gateway instance",
	SilenceUsage: true,
	Use:          "gateway-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeGatewayInstanceCmd)

	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceConfigPath,
		"config", "c", "", "Path to file with gateway instance config.")
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceName,
		"name", "n", "", "Name of gateway instance.")
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object")
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&describeGatewayInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.")
	DescribeGatewayInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

///////////////////////////////////////////////////////////////////////////////
// DomainName
///////////////////////////////////////////////////////////////////////////////

// GetDomainNamesCmd represents the domain-name command
var GetDomainNamesCmd = &cobra.Command{
	Example: "  tptctl get domain-names",
	Long:    "Get domain names from the system.\n\nA domain name is a simple abstraction of domain name definitions and domain name instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get domain names
		domainNameInstances, err := client.GetDomainNameInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve domain name instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*domainNameInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No domain name instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetDomainNamesCmd(
			domainNameInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get domain names from the system",
	SilenceUsage: true,
	Use:          "domain-names",
}

func init() {
	GetCmd.AddCommand(GetDomainNamesCmd)

	GetDomainNamesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createDomainNameConfigPath string

// CreateDomainNameCmd represents the domain-name command
var CreateDomainNameCmd = &cobra.Command{
	Example: "  tptctl create domain-name --config path/to/config.yaml",
	Long:    "Create a new domain name. This command creates a new domain name definition and domain name instance based on the domain name config.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load domain name config
		configContent, err := os.ReadFile(createDomainNameConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var domainNameConfig config.DomainNameConfig
		if err := yaml.UnmarshalStrict(configContent, &domainNameConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create domain name
		domainName := domainNameConfig.DomainName
		createdDomainNameDefinition, createdDomainNameInstance, err := domainName.Create(
			apiClient,
			apiEndpoint,
		)
		if err != nil {
			cli.Error("failed to create domain name", err)
			os.Exit(1)
		}

		cli.Info(fmt.Sprintf("domain name definition %s created", *createdDomainNameDefinition.Name))
		cli.Info(fmt.Sprintf("domain name instance %s created", *createdDomainNameInstance.Name))
		cli.Complete(fmt.Sprintf("domain name %s created", domainNameConfig.DomainName.Name))
	},
	Short:        "Create a new domain name",
	SilenceUsage: true,
	Use:          "domain-name",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameCmd)

	CreateDomainNameCmd.Flags().StringVarP(
		&createDomainNameConfigPath,
		"config", "c", "", "Path to file with domain name config.",
	)
	CreateDomainNameCmd.MarkFlagRequired("config")
	CreateDomainNameCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteDomainNameConfigPath string
	deleteDomainNameName       string
)

// DeleteDomainNameCmd represents the domain-name command
var DeleteDomainNameCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name --name some-domain-name",
	Long:    "Delete an existing domain name. This command deletes an existing domain name definition and domain name instance based on the domain name config.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if deleteDomainNameConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		var domainNameConfig config.DomainNameConfig
		// load domain name config
		configContent, err := os.ReadFile(deleteDomainNameConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		if err := yaml.UnmarshalStrict(configContent, &domainNameConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// delete domain name
		domainName := domainNameConfig.DomainName
		_, _, err = domainName.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete domain name", err)
			os.Exit(1)
		}

		cli.Info(fmt.Sprintf("domain name definition %s deleted", domainName.Name))
		cli.Info(fmt.Sprintf("domain name instance %s deleted", domainName.Name))
		cli.Complete(fmt.Sprintf("domain name %s deleted", domainNameConfig.DomainName.Name))
	},
	Short:        "Delete an existing domain name",
	SilenceUsage: true,
	Use:          "domain-name",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameCmd)

	DeleteDomainNameCmd.Flags().StringVarP(
		&deleteDomainNameConfigPath,
		"config", "c", "", "Path to file with domain name config.",
	)
	DeleteDomainNameCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

///////////////////////////////////////////////////////////////////////////////
// DomainNameDefinition
///////////////////////////////////////////////////////////////////////////////

// GetDomainNameDefinitionsCmd represents the domain-name-definition command
var GetDomainNameDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get domain-name-definitions",
	Long:    "Get domain name definitions from the system.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get domain name definitions
		domainNameDefinitions, err := client.GetDomainNameDefinitions(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve domain name definitions", err)
			os.Exit(1)
		}

		// write the output
		if len(*domainNameDefinitions) == 0 {
			cli.Info(fmt.Sprintf(
				"No domain name definitions currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetDomainNameDefinitionsCmd(
			domainNameDefinitions,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output", err)
			os.Exit(0)
		}
	},
	Short:        "Get domain name definitions from the system",
	SilenceUsage: true,
	Use:          "domain-name-definitions",
}

func init() {
	GetCmd.AddCommand(GetDomainNameDefinitionsCmd)

	GetDomainNameDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createDomainNameDefinitionConfigPath string

// CreateDomainNameDefinitionCmd represents the domain-name-definition command
var CreateDomainNameDefinitionCmd = &cobra.Command{
	Example: "  tptctl create domain-name-definition --config path/to/config.yaml",
	Long:    "Create a new domain name definition.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load domain name definition config
		configContent, err := os.ReadFile(createDomainNameDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var domainNameDefinitionConfig config.DomainNameDefinitionConfig
		if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create domain name definition
		domainNameDefinition := domainNameDefinitionConfig.DomainNameDefinition
		createdDomainNameDefinition, err := domainNameDefinition.Create(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to create domain name definition", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("domain name definition %s created", *createdDomainNameDefinition.Name))
	},
	Short:        "Create a new domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameDefinitionCmd)

	CreateDomainNameDefinitionCmd.Flags().StringVarP(
		&createDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.",
	)
	CreateDomainNameDefinitionCmd.MarkFlagRequired("config")
	CreateDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteDomainNameDefinitionConfigPath string
	deleteDomainNameDefinitionName       string
)

// DeleteDomainNameDefinitionCmd represents the domain-name-definition command
var DeleteDomainNameDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name-definition --name some-domain-name-definition",
	Long:    "Delete an existing domain name definition.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteDomainNameDefinitionConfigPath,
			deleteDomainNameDefinitionName,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		var domainNameDefinitionConfig config.DomainNameDefinitionConfig
		if deleteDomainNameDefinitionConfigPath != "" {
			// load domain name definition config
			configContent, err := os.ReadFile(deleteDomainNameDefinitionConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			domainNameDefinitionConfig = config.DomainNameDefinitionConfig{
				DomainNameDefinition: config.DomainNameDefinitionValues{
					Name: deleteDomainNameDefinitionName,
				},
			}
		}

		// delete domain name definition
		domainNameDefinition := domainNameDefinitionConfig.DomainNameDefinition
		deletedDomainNameDefinition, err := domainNameDefinition.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete domain name definition", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("domain name definition %s deleted", *deletedDomainNameDefinition.Name))
	},
	Short:        "Delete an existing domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameDefinitionCmd)

	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&deleteDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.",
	)
	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&deleteDomainNameDefinitionName,
		"name", "n", "", "Name of domain name definition.",
	)
	DeleteDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	describeDomainNameDefinitionConfigPath string
	describeDomainNameDefinitionName       string
	describeDomainNameDefinitionField      string
	describeDomainNameDefinitionOutput     string
)

// DescribeDomainNameDefinitionCmd representes the domain-name-definition command
var DescribeDomainNameDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition\n\n  # Get JSON output for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition -o json\n\n  # Get the value of the Name field for a domain name definition\n  tptctl describe domain-name-definition -n some-domain-name-definition -f Name ",
	Long:    "Describe a domain name definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeDomainNameDefinitionConfigPath,
			describeDomainNameDefinitionName,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeDomainNameDefinitionOutput,
			"domain name definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// load domain name definition config by name or config file
		var domainNameDefinitionConfig config.DomainNameDefinitionConfig
		if describeDomainNameDefinitionConfigPath != "" {
			configContent, err := os.ReadFile(describeDomainNameDefinitionConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &domainNameDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			domainNameDefinitionConfig = config.DomainNameDefinitionConfig{
				DomainNameDefinition: config.DomainNameDefinitionValues{
					Name: describeDomainNameDefinitionName,
				},
			}
		}

		// get domain name definition
		domainNameDefinition, err := client.GetDomainNameDefinitionByName(
			apiClient,
			apiEndpoint,
			domainNameDefinitionConfig.DomainNameDefinition.Name,
		)
		if err != nil {
			cli.Error("failed to retrieve domain name definition details", err)
			os.Exit(1)
		}

		// return field value if specified
		if describeDomainNameDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				domainNameDefinition,
				describeDomainNameDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from domain name definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(domainNameDefinition, describeDomainNameDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		switch describeDomainNameDefinitionOutput {
		case "plain":
			// produce plain object description output
			if err := outputDescribeDomainNameDefinitionCmd(
				domainNameDefinition,
				&domainNameDefinitionConfig,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to describe domain name definition", err)
				os.Exit(1)
			}
		case "json":
			// redact encrypted values
			redactedDomainNameDefinition := encryption.RedactEncryptedValues(domainNameDefinition)

			// marshal to JSON then print
			domainNameDefinitionJson, err := json.MarshalIndent(redactedDomainNameDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedDomainNameDefinition := encryption.RedactEncryptedValues(domainNameDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			domainNameDefinitionJson, err := json.MarshalIndent(redactedDomainNameDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name definition into JSON", err)
				os.Exit(1)
			}
			domainNameDefinitionYaml, err := ghodss_yaml.JSONToYAML(domainNameDefinitionJson)
			if err != nil {
				cli.Error("failed to convert domain name definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameDefinitionYaml))
		}
	},
	Short:        "Describe a domain name definition",
	SilenceUsage: true,
	Use:          "domain-name-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeDomainNameDefinitionCmd)

	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionConfigPath,
		"config", "c", "", "Path to file with domain name definition config.")
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionName,
		"name", "n", "", "Name of domain name definition.")
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object")
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&describeDomainNameDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.")
	DescribeDomainNameDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

///////////////////////////////////////////////////////////////////////////////
// DomainNameInstance
///////////////////////////////////////////////////////////////////////////////

// GetDomainNameInstancesCmd represents the domain-name-instance command
var GetDomainNameInstancesCmd = &cobra.Command{
	Example: "  tptctl get domain-name-instances",
	Long:    "Get domain name instances from the system.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := getClientContext(cmd)

		// get domain name instances
		domainNameInstances, err := client.GetDomainNameInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve domain name instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*domainNameInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No domain name instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetDomainNameInstancesCmd(
			domainNameInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output", err)
			os.Exit(0)
		}
	},
	Short:        "Get domain name instances from the system",
	SilenceUsage: true,
	Use:          "domain-name-instances",
}

func init() {
	GetCmd.AddCommand(GetDomainNameInstancesCmd)

	GetDomainNameInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var createDomainNameInstanceConfigPath string

// CreateDomainNameInstanceCmd represents the domain-name-instance command
var CreateDomainNameInstanceCmd = &cobra.Command{
	Example: "  tptctl create domain-name-instance --config path/to/config.yaml",
	Long:    "Create a new domain name instance.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// load domain name instance config
		configContent, err := os.ReadFile(createDomainNameInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		var domainNameInstanceConfig config.DomainNameInstanceConfig
		if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
			cli.Error("failed to unmarshal config file yaml content", err)
			os.Exit(1)
		}

		// create domain name instance
		domainNameInstance := domainNameInstanceConfig.DomainNameInstance
		createdDomainNameInstance, err := domainNameInstance.Create(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to create domain name instance", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("domain name instance %s created", *createdDomainNameInstance.Name))
	},
	Short:        "Create a new domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	CreateCmd.AddCommand(CreateDomainNameInstanceCmd)

	CreateDomainNameInstanceCmd.Flags().StringVarP(
		&createDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.",
	)
	CreateDomainNameInstanceCmd.MarkFlagRequired("config")
	CreateDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	deleteDomainNameInstanceConfigPath string
	deleteDomainNameInstanceName       string
)

// DeleteDomainNameInstanceCmd represents the domain-name-instance command
var DeleteDomainNameInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete domain-name-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete domain-name-instance --name some-domain-name-instance",
	Long:    "Delete an existing domain name instance.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteDomainNameInstanceConfigPath,
			deleteDomainNameInstanceName,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		var domainNameInstanceConfig config.DomainNameInstanceConfig
		if deleteDomainNameInstanceConfigPath != "" {
			// load domain name instance config
			configContent, err := os.ReadFile(deleteDomainNameInstanceConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			domainNameInstanceConfig = config.DomainNameInstanceConfig{
				DomainNameInstance: config.DomainNameInstanceValues{
					Name: deleteDomainNameInstanceName,
				},
			}
		}

		// delete domain name instance
		domainNameInstance := domainNameInstanceConfig.DomainNameInstance
		deletedDomainNameInstance, err := domainNameInstance.Delete(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to delete domain name instance", err)
			os.Exit(1)
		}

		cli.Complete(fmt.Sprintf("domain name instance %s deleted", *deletedDomainNameInstance.Name))
	},
	Short:        "Delete an existing domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteDomainNameInstanceCmd)

	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&deleteDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.",
	)
	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&deleteDomainNameInstanceName,
		"name", "n", "", "Name of domain name instance.",
	)
	DeleteDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	describeDomainNameInstanceConfigPath string
	describeDomainNameInstanceName       string
	describeDomainNameInstanceField      string
	describeDomainNameInstanceOutput     string
)

// DescribeDomainNameInstanceCmd representes the domain-name-instance command
var DescribeDomainNameInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance\n\n  # Get JSON output for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance -o json\n\n  # Get the value of the Name field for a domain name instance\n  tptctl describe domain-name-instance -n some-domain-name-instance -f Name ",
	Long:    "Describe a domain name instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  commandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := getClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeDomainNameInstanceConfigPath,
			describeDomainNameInstanceName,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeDomainNameInstanceOutput,
			"domain name instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// load domain name instance config by name or config file
		var domainNameInstanceConfig config.DomainNameInstanceConfig
		if describeDomainNameInstanceConfigPath != "" {
			configContent, err := os.ReadFile(describeDomainNameInstanceConfigPath)
			if err != nil {
				cli.Error("failed to read config file", err)
				os.Exit(1)
			}
			if err := yaml.UnmarshalStrict(configContent, &domainNameInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}
		} else {
			domainNameInstanceConfig = config.DomainNameInstanceConfig{
				DomainNameInstance: config.DomainNameInstanceValues{
					Name: describeDomainNameInstanceName,
				},
			}
		}

		// get domain name instance
		domainNameInstance, err := client.GetDomainNameInstanceByName(
			apiClient,
			apiEndpoint,
			domainNameInstanceConfig.DomainNameInstance.Name,
		)
		if err != nil {
			cli.Error("failed to retrieve domain name instance details", err)
			os.Exit(1)
		}

		// return field value if specified
		if describeDomainNameInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				domainNameInstance,
				describeDomainNameInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from domain name instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(domainNameInstance, describeDomainNameInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		switch describeDomainNameInstanceOutput {
		case "plain":
			// produce plain object description output
			if err := outputDescribeDomainNameInstanceCmd(
				domainNameInstance,
				&domainNameInstanceConfig,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to describe domain name instance", err)
				os.Exit(1)
			}
		case "json":
			// redact encrypted values
			redactedDomainNameInstance := encryption.RedactEncryptedValues(domainNameInstance)

			// marshal to JSON then print
			domainNameInstanceJson, err := json.MarshalIndent(redactedDomainNameInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedDomainNameInstance := encryption.RedactEncryptedValues(domainNameInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			domainNameInstanceJson, err := json.MarshalIndent(redactedDomainNameInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal domain name instance into JSON", err)
				os.Exit(1)
			}
			domainNameInstanceYaml, err := ghodss_yaml.JSONToYAML(domainNameInstanceJson)
			if err != nil {
				cli.Error("failed to convert domain name instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(domainNameInstanceYaml))
		}
	},
	Short:        "Describe a domain name instance",
	SilenceUsage: true,
	Use:          "domain-name-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeDomainNameInstanceCmd)

	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceConfigPath,
		"config", "c", "", "Path to file with domain name instance config.")
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceName,
		"name", "n", "", "Name of domain name instance.")
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object")
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&describeDomainNameInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.")
	DescribeDomainNameInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}
