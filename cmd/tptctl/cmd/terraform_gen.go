// generated by 'threeport-sdk gen' - do not edit

package cmd

import (
	"encoding/json"
	"errors"
	"fmt"
	ghodss_yaml "github.com/ghodss/yaml"
	cobra "github.com/spf13/cobra"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	cli "github.com/threeport/threeport/pkg/cli/v0"
	client_v0 "github.com/threeport/threeport/pkg/client/v0"
	config_v0 "github.com/threeport/threeport/pkg/config/v0"
	encryption "github.com/threeport/threeport/pkg/encryption/v0"
	util "github.com/threeport/threeport/pkg/util/v0"
	yaml "gopkg.in/yaml.v2"
	"os"
)

///////////////////////////////////////////////////////////////////////////////
// TerraformDefinition
///////////////////////////////////////////////////////////////////////////////

var getTerraformDefinitionVersion string

// GetTerraformDefinitionsCmd represents the terraform-definition command
var GetTerraformDefinitionsCmd = &cobra.Command{
	Example: "  tptctl get terraform-definitions",
	Long:    "Get terraform definitions from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getTerraformDefinitionVersion {
		case "v0":
			// get terraform definitions
			terraformDefinitions, err := client_v0.GetTerraformDefinitions(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve terraform definitions", err)
				os.Exit(1)
			}

			// write the output
			if len(*terraformDefinitions) == 0 {
				cli.Info(fmt.Sprintf(
					"No terraform definitions currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0TerraformDefinitionsCmd(
				terraformDefinitions,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get terraform definitions from the system",
	SilenceUsage: true,
	Use:          "terraform-definitions",
}

func init() {
	GetCmd.AddCommand(GetTerraformDefinitionsCmd)

	GetTerraformDefinitionsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetTerraformDefinitionsCmd.Flags().StringVarP(
		&getTerraformDefinitionVersion,
		"version", "v", "v0", "Version of terraform definitions object to retrieve. One of: [v0]",
	)
}

var (
	createTerraformDefinitionConfigPath string
	createTerraformDefinitionVersion    string
)

// CreateTerraformDefinitionCmd represents the terraform-definition command
var CreateTerraformDefinitionCmd = &cobra.Command{
	Example: "  tptctl create terraform-definition --config path/to/config.yaml",
	Long:    "Create a new terraform definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read terraform definition config
		configContent, err := os.ReadFile(createTerraformDefinitionConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create terraform definition based on version
		switch createTerraformDefinitionVersion {
		case "v0":
			var terraformDefinitionConfig config_v0.TerraformDefinitionConfig
			if err := yaml.UnmarshalStrict(configContent, &terraformDefinitionConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create terraform definition
			terraformDefinition := terraformDefinitionConfig.TerraformDefinition
			terraformDefinition.TerraformConfigPath = &createTerraformDefinitionConfigPath
			createdTerraformDefinition, err := terraformDefinition.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create terraform definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("terraform definition %s created", *createdTerraformDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new terraform definition",
	SilenceUsage: true,
	Use:          "terraform-definition",
}

func init() {
	CreateCmd.AddCommand(CreateTerraformDefinitionCmd)

	CreateTerraformDefinitionCmd.Flags().StringVarP(
		&createTerraformDefinitionConfigPath,
		"config", "c", "", "Path to file with terraform definition config.",
	)
	CreateTerraformDefinitionCmd.MarkFlagRequired("config")
	CreateTerraformDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateTerraformDefinitionCmd.Flags().StringVarP(
		&createTerraformDefinitionVersion,
		"version", "v", "v0", "Version of terraform definitions object to create. One of: [v0]",
	)
}

var (
	deleteTerraformDefinitionConfigPath string
	deleteTerraformDefinitionName       string
	deleteTerraformDefinitionVersion    string
)

// DeleteTerraformDefinitionCmd represents the terraform-definition command
var DeleteTerraformDefinitionCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete terraform-definition --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete terraform-definition --name some-terraform-definition",
	Long:    "Delete an existing terraform definition.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteTerraformDefinitionConfigPath,
			deleteTerraformDefinitionName,
			"terraform definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete terraform definition based on version
		switch deleteTerraformDefinitionVersion {
		case "v0":
			var terraformDefinitionConfig config_v0.TerraformDefinitionConfig
			if deleteTerraformDefinitionConfigPath != "" {
				// load terraform definition config
				configContent, err := os.ReadFile(deleteTerraformDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &terraformDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				terraformDefinitionConfig = config_v0.TerraformDefinitionConfig{
					TerraformDefinition: config_v0.TerraformDefinitionValues{
						Name: &deleteTerraformDefinitionName,
					},
				}
			}

			// delete terraform definition
			terraformDefinition := terraformDefinitionConfig.TerraformDefinition
			terraformDefinition.TerraformConfigPath = &deleteTerraformDefinitionConfigPath
			deletedTerraformDefinition, err := terraformDefinition.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete terraform definition", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("terraform definition %s deleted", *deletedTerraformDefinition.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing terraform definition",
	SilenceUsage: true,
	Use:          "terraform-definition",
}

func init() {
	DeleteCmd.AddCommand(DeleteTerraformDefinitionCmd)

	DeleteTerraformDefinitionCmd.Flags().StringVarP(
		&deleteTerraformDefinitionConfigPath,
		"config", "c", "", "Path to file with terraform definition config.",
	)
	DeleteTerraformDefinitionCmd.Flags().StringVarP(
		&deleteTerraformDefinitionName,
		"name", "n", "", "Name of terraform definition.",
	)
	DeleteTerraformDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteTerraformDefinitionCmd.Flags().StringVarP(
		&deleteTerraformDefinitionVersion,
		"version", "v", "v0", "Version of terraform definitions object to delete. One of: [v0]",
	)
}

var (
	describeTerraformDefinitionConfigPath string
	describeTerraformDefinitionName       string
	describeTerraformDefinitionField      string
	describeTerraformDefinitionOutput     string
	describeTerraformDefinitionVersion    string
)

// DescribeTerraformDefinitionCmd representes the terraform-definition command
var DescribeTerraformDefinitionCmd = &cobra.Command{
	Example: "  # Get the plain output description for a terraform definition\n  tptctl describe terraform-definition -n some-terraform-definition\n\n  # Get JSON output for a terraform definition\n  tptctl describe terraform-definition -n some-terraform-definition -o json\n\n  # Get the value of the Name field for a terraform definition\n  tptctl describe terraform-definition -n some-terraform-definition -f Name ",
	Long:    "Describe a terraform definition.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeTerraformDefinitionConfigPath,
			describeTerraformDefinitionName,
			"terraform definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeTerraformDefinitionOutput,
			"terraform definition",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get terraform definition
		var terraformDefinition interface{}
		switch describeTerraformDefinitionVersion {
		case "v0":
			// load terraform definition config by name or config file
			var terraformDefinitionConfig config_v0.TerraformDefinitionConfig
			if describeTerraformDefinitionConfigPath != "" {
				configContent, err := os.ReadFile(describeTerraformDefinitionConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &terraformDefinitionConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				terraformDefinitionConfig = config_v0.TerraformDefinitionConfig{
					TerraformDefinition: config_v0.TerraformDefinitionValues{
						Name: &describeTerraformDefinitionName,
					},
				}
			}

			// get terraform definition object by name
			obj, err := client_v0.GetTerraformDefinitionByName(
				apiClient,
				apiEndpoint,
				*terraformDefinitionConfig.TerraformDefinition.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve terraform definition details", err)
				os.Exit(1)
			}
			terraformDefinition = obj

			// return plain output if requested
			if describeTerraformDefinitionOutput == "plain" {
				if err := outputDescribev0TerraformDefinitionCmd(
					terraformDefinition.(*api_v0.TerraformDefinition),
					&terraformDefinitionConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe terraform definition", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeTerraformDefinitionField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				terraformDefinition,
				describeTerraformDefinitionField,
			)
			if err != nil {
				cli.Error("failed to get field value from terraform definition", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(terraformDefinition, describeTerraformDefinitionField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeTerraformDefinitionOutput {
		case "json":
			// redact encrypted values
			redactedTerraformDefinition := encryption.RedactEncryptedValues(terraformDefinition)

			// marshal to JSON then print
			terraformDefinitionJson, err := json.MarshalIndent(redactedTerraformDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal terraform definition into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(terraformDefinitionJson))
		case "yaml":
			// redact encrypted values
			redactedTerraformDefinition := encryption.RedactEncryptedValues(terraformDefinition)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			terraformDefinitionJson, err := json.MarshalIndent(redactedTerraformDefinition, "", "  ")
			if err != nil {
				cli.Error("failed to marshal terraform definition into JSON", err)
				os.Exit(1)
			}
			terraformDefinitionYaml, err := ghodss_yaml.JSONToYAML(terraformDefinitionJson)
			if err != nil {
				cli.Error("failed to convert terraform definition JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(terraformDefinitionYaml))
		}
	},
	Short:        "Describe a terraform definition",
	SilenceUsage: true,
	Use:          "terraform-definition",
}

func init() {
	DescribeCmd.AddCommand(DescribeTerraformDefinitionCmd)

	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&describeTerraformDefinitionConfigPath,
		"config", "c", "", "Path to file with terraform definition config.",
	)
	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&describeTerraformDefinitionName,
		"name", "n", "", "Name of terraform definition.",
	)
	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&describeTerraformDefinitionOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&describeTerraformDefinitionField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeTerraformDefinitionCmd.Flags().StringVarP(
		&describeTerraformDefinitionVersion,
		"version", "v", "v0", "Version of terraform definitions object to describe. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// Terraform
///////////////////////////////////////////////////////////////////////////////

// GetTerraformsCmd represents the terraform command
var GetTerraformsCmd = &cobra.Command{
	Example: "  tptctl get terraforms",
	Long:    "Get terraforms from the system.\n\nA terraform is a simple abstraction of terraform definitions and terraform instances.\nThis command displays all instances and the definitions used to configure them.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		// get terraforms
		v0terraformInstances, err := client_v0.GetTerraformInstances(apiClient, apiEndpoint)
		if err != nil {
			cli.Error("failed to retrieve terraform instances", err)
			os.Exit(1)
		}

		// write the output
		if len(*v0terraformInstances) == 0 {
			cli.Info(fmt.Sprintf(
				"No terraform instances currently managed by %s threeport control plane",
				requestedControlPlane,
			))
			os.Exit(0)
		}
		if err := outputGetTerraformsCmd(
			v0terraformInstances,
			apiClient,
			apiEndpoint,
		); err != nil {
			cli.Error("failed to produce output: %s", err)
			os.Exit(0)
		}
	},
	Short:        "Get terraforms from the system",
	SilenceUsage: true,
	Use:          "terraforms",
}

func init() {
	GetCmd.AddCommand(GetTerraformsCmd)

	GetTerraformsCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
}

var (
	createTerraformConfigPath string
	createTerraformVersion    string
)

// CreateTerraformCmd represents the terraform command
var CreateTerraformCmd = &cobra.Command{
	Example: "  tptctl create terraform --config path/to/config.yaml",
	Long:    "Create a new terraform. This command creates a new terraform definition and terraform instance based on the terraform config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read terraform config
		configContent, err := os.ReadFile(createTerraformConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// create terraform based on version
		switch createTerraformVersion {
		case "v0":
			var terraformConfig config_v0.TerraformConfig
			if err := yaml.UnmarshalStrict(configContent, &terraformConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create terraform
			terraform := terraformConfig.Terraform
			terraform.TerraformConfigPath = &createTerraformConfigPath
			createdTerraformDefinition, createdTerraformInstance, err := terraform.Create(
				apiClient,
				apiEndpoint,
			)
			if err != nil {
				cli.Error("failed to create terraform", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("terraform definition %s created", *createdTerraformDefinition.Name))
			cli.Info(fmt.Sprintf("terraform instance %s created", *createdTerraformInstance.Name))
			cli.Complete(fmt.Sprintf("terraform %s created", *terraformConfig.Terraform.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new terraform",
	SilenceUsage: true,
	Use:          "terraform",
}

func init() {
	CreateCmd.AddCommand(CreateTerraformCmd)

	CreateTerraformCmd.Flags().StringVarP(
		&createTerraformConfigPath,
		"config", "c", "", "Path to file with terraform config.",
	)
	CreateTerraformCmd.MarkFlagRequired("config")
	CreateTerraformCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateTerraformCmd.Flags().StringVarP(
		&createTerraformVersion,
		"version", "v", "v0", "Version of terraforms object to create. One of: [v0]",
	)
}

var (
	deleteTerraformConfigPath string
	deleteTerraformName       string
	deleteTerraformVersion    string
)

// DeleteTerraformCmd represents the terraform command
var DeleteTerraformCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete terraform --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete terraform --name some-terraform",
	Long:    "Delete an existing terraform. This command deletes an existing terraform definition and terraform instance based on the terraform config.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if deleteTerraformConfigPath == "" {
			cli.Error("flag validation failed", errors.New("config file path is required"))
		}

		// read terraform config
		configContent, err := os.ReadFile(deleteTerraformConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}

		// delete terraform based on version
		switch deleteTerraformVersion {
		case "v0":
			var terraformConfig config_v0.TerraformConfig
			if err := yaml.UnmarshalStrict(configContent, &terraformConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// delete terraform
			terraform := terraformConfig.Terraform
			terraform.TerraformConfigPath = &deleteTerraformConfigPath
			_, _, err = terraform.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete terraform", err)
				os.Exit(1)
			}

			cli.Info(fmt.Sprintf("terraform definition %s deleted", *terraform.Name))
			cli.Info(fmt.Sprintf("terraform instance %s deleted", *terraform.Name))
			cli.Complete(fmt.Sprintf("terraform %s deleted", *terraformConfig.Terraform.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing terraform",
	SilenceUsage: true,
	Use:          "terraform",
}

func init() {
	DeleteCmd.AddCommand(DeleteTerraformCmd)

	DeleteTerraformCmd.Flags().StringVarP(
		&deleteTerraformConfigPath,
		"config", "c", "", "Path to file with terraform config.",
	)
	DeleteTerraformCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteTerraformCmd.Flags().StringVarP(
		&deleteTerraformVersion,
		"version", "v", "v0", "Version of terraforms object to delete. One of: [v0]",
	)
}

///////////////////////////////////////////////////////////////////////////////
// TerraformInstance
///////////////////////////////////////////////////////////////////////////////

var getTerraformInstanceVersion string

// GetTerraformInstancesCmd represents the terraform-instance command
var GetTerraformInstancesCmd = &cobra.Command{
	Example: "  tptctl get terraform-instances",
	Long:    "Get terraform instances from the system.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, requestedControlPlane := GetClientContext(cmd)

		switch getTerraformInstanceVersion {
		case "v0":
			// get terraform instances
			terraformInstances, err := client_v0.GetTerraformInstances(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to retrieve terraform instances", err)
				os.Exit(1)
			}

			// write the output
			if len(*terraformInstances) == 0 {
				cli.Info(fmt.Sprintf(
					"No terraform instances currently managed by %s threeport control plane",
					requestedControlPlane,
				))
				os.Exit(0)
			}
			if err := outputGetv0TerraformInstancesCmd(
				terraformInstances,
				apiClient,
				apiEndpoint,
			); err != nil {
				cli.Error("failed to produce output", err)
				os.Exit(0)
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Get terraform instances from the system",
	SilenceUsage: true,
	Use:          "terraform-instances",
}

func init() {
	GetCmd.AddCommand(GetTerraformInstancesCmd)

	GetTerraformInstancesCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	GetTerraformInstancesCmd.Flags().StringVarP(
		&getTerraformInstanceVersion,
		"version", "v", "v0", "Version of terraform instances object to retrieve. One of: [v0]",
	)
}

var (
	createTerraformInstanceConfigPath string
	createTerraformInstanceVersion    string
)

// CreateTerraformInstanceCmd represents the terraform-instance command
var CreateTerraformInstanceCmd = &cobra.Command{
	Example: "  tptctl create terraform-instance --config path/to/config.yaml",
	Long:    "Create a new terraform instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// read terraform instance config
		configContent, err := os.ReadFile(createTerraformInstanceConfigPath)
		if err != nil {
			cli.Error("failed to read config file", err)
			os.Exit(1)
		}
		// create terraform instance based on version
		switch createTerraformInstanceVersion {
		case "v0":
			var terraformInstanceConfig config_v0.TerraformInstanceConfig
			if err := yaml.UnmarshalStrict(configContent, &terraformInstanceConfig); err != nil {
				cli.Error("failed to unmarshal config file yaml content", err)
				os.Exit(1)
			}

			// create terraform instance
			terraformInstance := terraformInstanceConfig.TerraformInstance
			terraformInstance.TerraformConfigPath = &createTerraformInstanceConfigPath
			createdTerraformInstance, err := terraformInstance.Create(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to create terraform instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("terraform instance %s created", *createdTerraformInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Create a new terraform instance",
	SilenceUsage: true,
	Use:          "terraform-instance",
}

func init() {
	CreateCmd.AddCommand(CreateTerraformInstanceCmd)

	CreateTerraformInstanceCmd.Flags().StringVarP(
		&createTerraformInstanceConfigPath,
		"config", "c", "", "Path to file with terraform instance config.",
	)
	CreateTerraformInstanceCmd.MarkFlagRequired("config")
	CreateTerraformInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	CreateTerraformInstanceCmd.Flags().StringVarP(
		&createTerraformInstanceVersion,
		"version", "v", "v0", "Version of terraform instances object to create. One of: [v0]",
	)
}

var (
	deleteTerraformInstanceConfigPath string
	deleteTerraformInstanceName       string
	deleteTerraformInstanceVersion    string
)

// DeleteTerraformInstanceCmd represents the terraform-instance command
var DeleteTerraformInstanceCmd = &cobra.Command{
	Example: "  # delete based on config file\n  tptctl delete terraform-instance --config path/to/config.yaml\n\n  # delete based on name\n  tptctl delete terraform-instance --name some-terraform-instance",
	Long:    "Delete an existing terraform instance.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			deleteTerraformInstanceConfigPath,
			deleteTerraformInstanceName,
			"terraform instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// delete terraform instance based on version
		switch deleteTerraformInstanceVersion {
		case "v0":
			var terraformInstanceConfig config_v0.TerraformInstanceConfig
			if deleteTerraformInstanceConfigPath != "" {
				// load terraform instance config
				configContent, err := os.ReadFile(deleteTerraformInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &terraformInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				terraformInstanceConfig = config_v0.TerraformInstanceConfig{
					TerraformInstance: config_v0.TerraformInstanceValues{
						Name: &deleteTerraformInstanceName,
					},
				}
			}

			// delete terraform instance
			terraformInstance := terraformInstanceConfig.TerraformInstance
			terraformInstance.TerraformConfigPath = &deleteTerraformInstanceConfigPath
			deletedTerraformInstance, err := terraformInstance.Delete(apiClient, apiEndpoint)
			if err != nil {
				cli.Error("failed to delete terraform instance", err)
				os.Exit(1)
			}

			cli.Complete(fmt.Sprintf("terraform instance %s deleted", *deletedTerraformInstance.Name))
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}
	},
	Short:        "Delete an existing terraform instance",
	SilenceUsage: true,
	Use:          "terraform-instance",
}

func init() {
	DeleteCmd.AddCommand(DeleteTerraformInstanceCmd)

	DeleteTerraformInstanceCmd.Flags().StringVarP(
		&deleteTerraformInstanceConfigPath,
		"config", "c", "", "Path to file with terraform instance config.",
	)
	DeleteTerraformInstanceCmd.Flags().StringVarP(
		&deleteTerraformInstanceName,
		"name", "n", "", "Name of terraform instance.",
	)
	DeleteTerraformInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DeleteTerraformInstanceCmd.Flags().StringVarP(
		&deleteTerraformInstanceVersion,
		"version", "v", "v0", "Version of terraform instances object to delete. One of: [v0]",
	)
}

var (
	describeTerraformInstanceConfigPath string
	describeTerraformInstanceName       string
	describeTerraformInstanceField      string
	describeTerraformInstanceOutput     string
	describeTerraformInstanceVersion    string
)

// DescribeTerraformInstanceCmd representes the terraform-instance command
var DescribeTerraformInstanceCmd = &cobra.Command{
	Example: "  # Get the plain output description for a terraform instance\n  tptctl describe terraform-instance -n some-terraform-instance\n\n  # Get JSON output for a terraform instance\n  tptctl describe terraform-instance -n some-terraform-instance -o json\n\n  # Get the value of the Name field for a terraform instance\n  tptctl describe terraform-instance -n some-terraform-instance -f Name ",
	Long:    "Describe a terraform instance.  This command can give you a plain output description, output all fields in JSON or YAML format, or provide the value of any specific field.\n\nNote: any values that are encrypted in the database will be redacted unless the field is specifically requested with the --field flag.",
	PreRun:  CommandPreRunFunc,
	Run: func(cmd *cobra.Command, args []string) {
		apiClient, _, apiEndpoint, _ := GetClientContext(cmd)

		// flag validation
		if err := cli.ValidateConfigNameFlags(
			describeTerraformInstanceConfigPath,
			describeTerraformInstanceName,
			"terraform instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		if err := cli.ValidateDescribeOutputFlag(
			describeTerraformInstanceOutput,
			"terraform instance",
		); err != nil {
			cli.Error("flag validation failed", err)
			os.Exit(1)
		}

		// get terraform instance
		var terraformInstance interface{}
		switch describeTerraformInstanceVersion {
		case "v0":
			// load terraform instance config by name or config file
			var terraformInstanceConfig config_v0.TerraformInstanceConfig
			if describeTerraformInstanceConfigPath != "" {
				configContent, err := os.ReadFile(describeTerraformInstanceConfigPath)
				if err != nil {
					cli.Error("failed to read config file", err)
					os.Exit(1)
				}
				if err := yaml.UnmarshalStrict(configContent, &terraformInstanceConfig); err != nil {
					cli.Error("failed to unmarshal config file yaml content", err)
					os.Exit(1)
				}
			} else {
				terraformInstanceConfig = config_v0.TerraformInstanceConfig{
					TerraformInstance: config_v0.TerraformInstanceValues{
						Name: &describeTerraformInstanceName,
					},
				}
			}

			// get terraform instance object by name
			obj, err := client_v0.GetTerraformInstanceByName(
				apiClient,
				apiEndpoint,
				*terraformInstanceConfig.TerraformInstance.Name,
			)
			if err != nil {
				cli.Error("failed to retrieve terraform instance details", err)
				os.Exit(1)
			}
			terraformInstance = obj

			// return plain output if requested
			if describeTerraformInstanceOutput == "plain" {
				if err := outputDescribev0TerraformInstanceCmd(
					terraformInstance.(*api_v0.TerraformInstance),
					&terraformInstanceConfig,
					apiClient,
					apiEndpoint,
				); err != nil {
					cli.Error("failed to describe terraform instance", err)
					os.Exit(1)
				}
			}
		default:
			cli.Error("", errors.New("unrecognized object version"))
			os.Exit(1)
		}

		// return field value if specified
		if describeTerraformInstanceField != "" {
			fieldVal, err := util.GetObjectFieldValue(
				terraformInstance,
				describeTerraformInstanceField,
			)
			if err != nil {
				cli.Error("failed to get field value from terraform instance", err)
				os.Exit(1)
			}

			// decrypt value as needed
			encrypted, err := encryption.IsEncryptedField(terraformInstance, describeTerraformInstanceField)
			if err != nil {
				cli.Error("", err)
			}
			if encrypted {
				// get encryption key from threeport config
				threeportConfig, requestedControlPlane, err := config_v0.GetThreeportConfig(cliArgs.ControlPlaneName)
				if err != nil {
					cli.Error("failed to get threeport config: %w", err)
					os.Exit(1)
				}
				encryptionKey, err := threeportConfig.GetThreeportEncryptionKey(requestedControlPlane)
				if err != nil {
					cli.Error("failed to get encryption key from threeport config: %w", err)
					os.Exit(1)
				}

				// decrypt value for output
				decryptedVal, err := encryption.Decrypt(encryptionKey, fieldVal.String())
				if err != nil {
					cli.Error("failed to decrypt value: %w", err)
				}
				fmt.Println(decryptedVal)
				os.Exit(0)
			} else {
				fmt.Println(fieldVal.Interface())
				os.Exit(0)
			}
		}

		// produce json or yaml output if requested
		switch describeTerraformInstanceOutput {
		case "json":
			// redact encrypted values
			redactedTerraformInstance := encryption.RedactEncryptedValues(terraformInstance)

			// marshal to JSON then print
			terraformInstanceJson, err := json.MarshalIndent(redactedTerraformInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal terraform instance into JSON", err)
				os.Exit(1)
			}

			fmt.Println(string(terraformInstanceJson))
		case "yaml":
			// redact encrypted values
			redactedTerraformInstance := encryption.RedactEncryptedValues(terraformInstance)

			// marshal to JSON then convert to YAML - this results in field
			// names with correct capitalization vs marshalling directly to YAML
			terraformInstanceJson, err := json.MarshalIndent(redactedTerraformInstance, "", "  ")
			if err != nil {
				cli.Error("failed to marshal terraform instance into JSON", err)
				os.Exit(1)
			}
			terraformInstanceYaml, err := ghodss_yaml.JSONToYAML(terraformInstanceJson)
			if err != nil {
				cli.Error("failed to convert terraform instance JSON to YAML", err)
				os.Exit(1)
			}

			fmt.Println(string(terraformInstanceYaml))
		}
	},
	Short:        "Describe a terraform instance",
	SilenceUsage: true,
	Use:          "terraform-instance",
}

func init() {
	DescribeCmd.AddCommand(DescribeTerraformInstanceCmd)

	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&describeTerraformInstanceConfigPath,
		"config", "c", "", "Path to file with terraform instance config.",
	)
	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&describeTerraformInstanceName,
		"name", "n", "", "Name of terraform instance.",
	)
	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&describeTerraformInstanceOutput,
		"output", "o", "plain", "Output format for object description. One of 'plain','json','yaml'.  Will be ignored if the --field flag is also used.  Plain output produces select details about the object.  JSON and YAML output formats include all direct attributes of the object",
	)
	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&describeTerraformInstanceField,
		"field", "f", "", "Object field to get value for. If used, --output flag will be ignored.  *Only* the value of the desired field will be returned.  Will not return information on related objects, only direct attributes of the object itself.",
	)
	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&cliArgs.ControlPlaneName,
		"control-plane-name", "i", "", "Optional. Name of control plane. Will default to current control plane if not provided.",
	)
	DescribeTerraformInstanceCmd.Flags().StringVarP(
		&describeTerraformInstanceVersion,
		"version", "v", "v0", "Version of terraform instances object to describe. One of: [v0]",
	)
}
